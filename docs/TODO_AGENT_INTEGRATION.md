# Agent Integration: DSL-Driven Deterministic Outcomes

**Generated by**: Opus 4.5 Architecture Review  
**Date**: 2025-12-14  
**Priority**: HIGH - Core value proposition for the platform

---

## Philosophy

```
┌─────────────────────────────────────────────────────────────────┐
│                        AGENT (Claude)                           │
│  • Understands intent ("onboard this fund with these people")   │
│  • Makes decisions ("need KYC case, need UBO calculation")      │
│  • Handles ambiguity ("did you mean John Smith or John Smythe?")│
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼ Natural Language
┌─────────────────────────────────────────────────────────────────┐
│                     TRANSLATION LAYER                           │
│  • Intent → Workflow template                                   │
│  • Entities → DSL arguments                                     │
│  • Disambiguation → Agent query                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼ DSL Source
┌─────────────────────────────────────────────────────────────────┐
│                     DSL PLATFORM (Deterministic)                │
│  • Validates all references against live DB                     │
│  • Ensures correct execution order (DAG)                        │
│  • Atomic transactions                                          │
│  • Audit trail                                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼ Structured Results
┌─────────────────────────────────────────────────────────────────┐
│                     FEEDBACK TO AGENT                           │
│  • Success: created entities, assigned roles                    │
│  • Failure: specific validation errors with suggestions         │
│  • Partial: what succeeded, what needs fixing                   │
└─────────────────────────────────────────────────────────────────┘
```

**Key Insight**: Agent is non-deterministic (creative, adaptive). DSL is deterministic (validated, ordered, transactional). The combination gives you intelligent automation with reliable outcomes.

---

## Architecture Overview

```
┌────────────────────────────────────────────────────────────────────────────┐
│                              MCP SERVER                                    │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐      │
│  │ dsl_validate │ │ dsl_execute  │ │ dsl_plan     │ │ entity_search│      │
│  └──────────────┘ └──────────────┘ └──────────────┘ └──────────────┘      │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐      │
│  │ suggest_verb │ │ get_schema   │ │ workflow_    │ │ session_     │      │
│  │              │ │              │ │ template     │ │ context      │      │
│  └──────────────┘ └──────────────┘ └──────────────┘ └──────────────┘      │
└────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌────────────────────────────────────────────────────────────────────────────┐
│                           DSL PLATFORM                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐       │
│  │   Parser    │→ │  Validator  │→ │  Compiler   │→ │  Executor   │       │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘       │
│         │               │                │                │               │
│         ▼               ▼                ▼                ▼               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐       │
│  │ AST + Spans │  │ Diagnostics │  │    Ops      │  │   Results   │       │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘       │
└────────────────────────────────────────────────────────────────────────────┘
```

---

## Part 1: MCP Tool Definitions

### 1.1 `dsl_validate` - Check DSL Without Executing

```rust
/// Validate DSL source, return structured diagnostics
#[tool(name = "dsl_validate")]
pub struct DslValidateTool {
    /// DSL source code to validate
    source: String,
    /// Optional: session ID for REPL context (knows about prior bindings)
    session_id: Option<String>,
}

#[tool_output]
pub struct ValidationOutput {
    /// Is the DSL valid and ready to execute?
    valid: bool,
    /// Structured errors/warnings
    diagnostics: Vec<AgentDiagnostic>,
    /// If valid, what will be created/modified
    plan_summary: Option<String>,
    /// Suggested fixes for errors
    suggested_fixes: Vec<SuggestedFix>,
}

pub struct AgentDiagnostic {
    severity: String,        // "error", "warning", "hint"
    message: String,         // Human-readable
    location: Option<String>, // Line/column for context
    code: String,            // Machine-readable error code
    // For agent decision-making:
    resolution_options: Vec<ResolutionOption>,
}

pub struct ResolutionOption {
    description: String,     // "Use existing entity 'John Smith (uuid-123)'"
    action: String,          // "replace_value"
    replacement: String,     // The corrected DSL fragment
}
```

**Agent Flow**:
1. Agent generates DSL from natural language
2. Calls `dsl_validate` to check
3. If errors, examines `resolution_options` to auto-fix or ask user
4. Iterates until valid

---

### 1.2 `dsl_execute` - Run Validated DSL

```rust
#[tool(name = "dsl_execute")]
pub struct DslExecuteTool {
    /// DSL source (should be pre-validated)
    source: String,
    /// Session ID for REPL context
    session_id: Option<String>,
    /// Dry run - show plan without executing
    dry_run: bool,
}

#[tool_output]
pub struct ExecutionOutput {
    success: bool,
    /// What was created/modified
    results: Vec<StepResultSummary>,
    /// Bindings created (for subsequent DSL)
    bindings: HashMap<String, String>, // name → uuid
    /// If failed, where and why
    error: Option<ExecutionError>,
    /// Human-readable summary
    summary: String,
}

pub struct StepResultSummary {
    verb: String,           // "cbu.create"
    action: String,         // "created", "updated", "linked"
    entity_type: String,    // "cbu", "entity", "role"
    entity_id: String,      // UUID
    entity_display: String, // "Apex Fund (Luxembourg)"
    binding: Option<String>, // "@fund" if bound
}
```

**Agent Flow**:
1. After successful validation, call `dsl_execute`
2. On success, record bindings for conversation context
3. On failure, examine error, potentially retry with fixes
4. Report outcome to user in natural language

---

### 1.3 `entity_search` - Find Existing Entities

```rust
#[tool(name = "entity_search")]
pub struct EntitySearchTool {
    /// What to search for
    query: String,
    /// Entity type filter: "cbu", "entity", "document", etc.
    entity_type: Option<String>,
    /// Max results
    limit: Option<u32>,
}

#[tool_output]
pub struct SearchOutput {
    matches: Vec<EntityMatch>,
    /// Did we find an exact match?
    exact_match: Option<EntityMatch>,
    /// Disambiguation needed?
    ambiguous: bool,
}

pub struct EntityMatch {
    id: String,              // UUID
    display: String,         // "John Smith"
    entity_type: String,     // "proper_person"
    score: f32,              // Relevance
    // Additional context for disambiguation
    context: HashMap<String, String>, // e.g., {"nationality": "US", "role": "Director at Apex Fund"}
}
```

**Agent Flow**:
1. User says "add John Smith as director"
2. Agent calls `entity_search(query: "John Smith", entity_type: "entity")`
3. If `ambiguous: true`, ask user "Did you mean John Smith (US) or John Smith (UK)?"
4. Use resolved UUID in DSL

---

### 1.4 `suggest_verb` - Get Verb for Intent

```rust
#[tool(name = "suggest_verb")]
pub struct SuggestVerbTool {
    /// What the user wants to do
    intent: String,
    /// Context: what entities are involved
    context: HashMap<String, String>,
}

#[tool_output]
pub struct VerbSuggestion {
    /// Recommended verb
    verb: String,
    /// Why this verb
    rationale: String,
    /// Template DSL with placeholders
    template: String,
    /// What arguments are needed
    required_args: Vec<ArgInfo>,
    optional_args: Vec<ArgInfo>,
    /// Alternative verbs if this doesn't fit
    alternatives: Vec<String>,
}

pub struct ArgInfo {
    name: String,
    arg_type: String,       // "string", "uuid", "decimal"
    description: String,
    /// For lookups: what entity type to search
    lookup_type: Option<String>,
    /// Example values
    examples: Vec<String>,
}
```

**Agent Flow**:
1. User says "I need to set up KYC for this client"
2. Agent calls `suggest_verb(intent: "setup KYC", context: {cbu: "uuid-123"})`
3. Gets back `kyc-case.open` with template and required args
4. Fills in template, validates, executes

---

### 1.5 `workflow_template` - Get Multi-Step Workflow

```rust
#[tool(name = "workflow_template")]
pub struct WorkflowTemplateTool {
    /// Workflow type
    workflow: WorkflowType,
    /// Parameters for the workflow
    params: HashMap<String, String>,
}

pub enum WorkflowType {
    OnboardIndividual,
    OnboardCorporate,
    OnboardFund,
    AddUBO,
    PeriodicReview,
    Remediation,
}

#[tool_output]
pub struct WorkflowTemplate {
    /// Steps in order
    steps: Vec<WorkflowStep>,
    /// Complete DSL template with placeholders
    dsl_template: String,
    /// What information is needed from user
    required_inputs: Vec<InputRequirement>,
}

pub struct WorkflowStep {
    order: u32,
    description: String,
    verb: String,
    /// Depends on outputs from these steps
    depends_on: Vec<u32>,
}

pub struct InputRequirement {
    name: String,
    description: String,
    input_type: String,     // "text", "date", "country", "percentage"
    required: bool,
    /// Validation pattern if applicable
    pattern: Option<String>,
}
```

**Agent Flow**:
1. User: "Onboard Apex Fund as a new Luxembourg fund"
2. Agent calls `workflow_template(workflow: OnboardFund, params: {jurisdiction: "LU"})`
3. Gets back multi-step template requiring: fund name, fund type, directors, UBOs, etc.
4. Agent gathers info conversationally, fills template, executes

---

### 1.6 `session_context` - Manage Conversation State

```rust
#[tool(name = "session_context")]
pub struct SessionContextTool {
    action: SessionAction,
    session_id: Option<String>,
}

pub enum SessionAction {
    /// Create new session
    Create,
    /// Get current bindings and state
    Get { session_id: String },
    /// Add executed bindings
    Update { session_id: String, bindings: HashMap<String, String> },
    /// Undo last execution block
    Undo { session_id: String },
    /// Clear session
    Clear { session_id: String },
}

#[tool_output]
pub struct SessionState {
    session_id: String,
    /// All bindings from this conversation
    bindings: HashMap<String, BindingInfo>,
    /// Execution history
    history: Vec<ExecutionRecord>,
    /// Can undo?
    can_undo: bool,
}
```

**Agent Flow**:
1. Start conversation: `session_context(action: Create)`
2. After each execution: `session_context(action: Update, bindings: {...})`
3. User says "undo that": `session_context(action: Undo)`
4. Session persists bindings across multiple DSL executions in conversation

---

## Part 2: Natural Language → DSL Translation

### 2.1 Intent Classification

```rust
/// Classify user intent to route to appropriate workflow
pub enum UserIntent {
    // Onboarding
    OnboardNewClient { client_type: ClientType },
    AddEntityToClient { entity_type: String },
    AssignRole { role: Option<String> },
    
    // UBO/Ownership
    AddOwnership { owner: Option<String>, owned: Option<String> },
    CalculateUBO,
    VerifyUBO,
    
    // Documents
    UploadDocument { doc_type: Option<String> },
    ExtractFromDocument,
    
    // KYC
    OpenKycCase { case_type: Option<String> },
    UpdateKycStatus { status: Option<String> },
    
    // Queries
    GetClientStatus,
    ListEntities,
    SearchEntity { query: String },
    
    // Meta
    Undo,
    ShowPlan,
    Help,
    Clarify,
}

pub fn classify_intent(user_message: &str, context: &ConversationContext) -> IntentClassification {
    // This is where the agent's NLU happens
    // Returns structured intent + confidence + extracted entities
}
```

### 2.2 Entity Extraction

```rust
/// Extract entities from natural language
pub struct ExtractedEntities {
    /// Named entities found
    entities: Vec<ExtractedEntity>,
    /// Values that need resolution (lookup in DB)
    pending_resolution: Vec<PendingResolution>,
    /// Ambiguous references needing clarification
    ambiguous: Vec<AmbiguousReference>,
}

pub struct ExtractedEntity {
    text: String,           // "John Smith"
    entity_type: String,    // "person"
    role: Option<String>,   // "director"
    /// Confidence in extraction
    confidence: f32,
}

pub struct PendingResolution {
    text: String,
    expected_type: String,
    /// Slot in DSL template this fills
    target_arg: String,
}
```

### 2.3 DSL Generation Pipeline

```rust
pub async fn generate_dsl(
    intent: UserIntent,
    entities: ExtractedEntities,
    session: &SessionState,
) -> Result<GeneratedDsl, GenerationError> {
    // 1. Get workflow template for intent
    let template = get_template_for_intent(&intent)?;
    
    // 2. Resolve pending entities against DB
    let resolved = resolve_entities(&entities.pending_resolution).await?;
    
    // 3. Check for ambiguity
    if !resolved.ambiguous.is_empty() {
        return Err(GenerationError::NeedsDisambiguation(resolved.ambiguous));
    }
    
    // 4. Fill template with resolved values
    let dsl = fill_template(&template, &resolved, session)?;
    
    // 5. Validate before returning
    let validation = validate_dsl(&dsl).await?;
    if !validation.valid {
        return Err(GenerationError::ValidationFailed(validation.diagnostics));
    }
    
    Ok(GeneratedDsl {
        source: dsl,
        explanation: generate_explanation(&template, &resolved),
        plan: validation.plan_summary,
    })
}
```

---

## Part 3: Feedback Loop Design

### 3.1 Structured Error Recovery

```rust
/// When validation fails, provide actionable recovery options
pub struct RecoveryOptions {
    /// Can auto-fix without user input
    auto_fixable: Vec<AutoFix>,
    /// Need user to choose
    user_choice_required: Vec<UserChoice>,
    /// Need more information
    info_required: Vec<InfoRequest>,
    /// Cannot recover - fatal error
    fatal: Option<String>,
}

pub struct AutoFix {
    description: String,
    /// The corrected DSL
    fixed_dsl: String,
    /// What changed
    changes: Vec<String>,
}

pub struct UserChoice {
    question: String,
    options: Vec<ChoiceOption>,
}

pub struct ChoiceOption {
    label: String,
    value: String,
    /// If chosen, this is the corrected DSL fragment
    replacement: String,
}

pub struct InfoRequest {
    question: String,
    field: String,
    field_type: String,
    /// Validation for the answer
    validation: Option<String>,
}
```

### 3.2 Agent Decision Tree

```
User Input
    │
    ▼
┌─────────────────┐
│ Classify Intent │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Extract Entities│
└────────┬────────┘
         │
    ┌────┴────┐
    │Ambiguous│───Yes──▶ Ask user to clarify
    └────┬────┘          │
         │No             │
         ▼               │
┌─────────────────┐      │
│ Resolve Entities│◀─────┘
└────────┬────────┘
         │
    ┌────┴────┐
    │ Found?  │───No───▶ "Entity not found. Create new?"
    └────┬────┘          │
         │Yes            ▼
         │          ┌─────────────────┐
         │          │ Generate Create │
         │          │ DSL First       │
         │          └────────┬────────┘
         │                   │
         ▼                   │
┌─────────────────┐          │
│ Generate DSL    │◀─────────┘
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Validate DSL    │
└────────┬────────┘
         │
    ┌────┴────┐
    │ Valid?  │───No───▶ Examine errors
    └────┬────┘          │
         │Yes            ▼
         │          ┌─────────────────┐
         │          │ Auto-fixable?   │──Yes──▶ Apply fix, re-validate
         │          └────────┬────────┘
         │                   │No
         │                   ▼
         │          ┌─────────────────┐
         │          │ Ask user for    │
         │          │ missing info    │
         │          └────────┬────────┘
         │                   │
         ▼                   │
┌─────────────────┐          │
│ Show Plan       │◀─────────┘
│ "Will create X" │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ User confirms?  │───No───▶ "What would you like to change?"
└────────┬────────┘
         │Yes
         ▼
┌─────────────────┐
│ Execute DSL     │
└────────┬────────┘
         │
    ┌────┴────┐
    │Success? │───No───▶ Show error, offer recovery
    └────┬────┘
         │Yes
         ▼
┌─────────────────┐
│ Update Session  │
│ Report Success  │
└─────────────────┘
```

---

## Part 4: Example Agent Interactions

### 4.1 Simple Onboarding

```
User: "Create a new fund called Apex Growth Fund in Luxembourg"

Agent: [Internal]
  1. classify_intent → OnboardNewClient { client_type: Fund }
  2. extract_entities → {name: "Apex Growth Fund", jurisdiction: "Luxembourg"}
  3. entity_search("Luxembourg", type: "jurisdiction") → LU (exact match)
  4. workflow_template(OnboardFund) → template with cbu.create
  5. generate_dsl:
     (cbu.create :name "Apex Growth Fund" :jurisdiction "LU" :cbu-type "FUND" :as @fund)
  6. dsl_validate → valid: true, plan: "Create CBU: Apex Growth Fund"

Agent: "I'll create Apex Growth Fund as a Luxembourg fund. This will:
        • Create a new CBU record
        • Set jurisdiction to Luxembourg
        • Mark as Fund type
        
        Shall I proceed?"

User: "Yes"

Agent: [Internal]
  7. dsl_execute → success, binding: @fund → uuid-123

Agent: "Done! Created Apex Growth Fund (ID: uuid-123). 
        Would you like to add directors or beneficial owners?"
```

### 4.2 Disambiguation Required

```
User: "Add John Smith as a director"

Agent: [Internal]
  1. classify_intent → AssignRole { role: "DIRECTOR" }
  2. Need context: which CBU? Check session → @fund exists
  3. entity_search("John Smith") → 2 matches:
     - John Smith (US, born 1975)
     - John Smith (UK, born 1982)

Agent: "I found two people named John Smith:
        1. John Smith (US citizen, born 1975) - already director at Meridian Fund
        2. John Smith (UK citizen, born 1982) - no current roles
        
        Which John Smith should I add as director to Apex Growth Fund?"

User: "The UK one"

Agent: [Internal]
  4. resolved: John Smith UK → uuid-456
  5. generate_dsl:
     (cbu.assign-role :cbu-id @fund :entity-id "uuid-456" :role "DIRECTOR")
  6. validate → valid
  7. execute → success

Agent: "Added John Smith (UK) as Director of Apex Growth Fund."
```

### 4.3 Entity Creation Required

```
User: "Add Sarah Connor as the fund administrator"

Agent: [Internal]
  1. classify_intent → AssignRole { role: "FUND_ADMINISTRATOR" }
  2. entity_search("Sarah Connor") → no matches
  
Agent: "I don't have Sarah Connor in the system. To add her as Fund Administrator, 
        I'll need to create her profile first. Can you provide:
        • Full name
        • Date of birth
        • Nationality"

User: "Sarah Connor, born March 15 1965, American"

Agent: [Internal]
  3. generate_dsl:
     (entity.create-proper-person 
        :first-name "Sarah" 
        :last-name "Connor" 
        :date-of-birth "1965-03-15"
        :nationality "US"
        :as @sarah)
     (cbu.assign-role :cbu-id @fund :entity-id @sarah :role "FUND_ADMINISTRATOR")
  4. validate → valid
  5. Plan: Create entity, then assign role

Agent: "I'll:
        1. Create Sarah Connor (US, DOB 1965-03-15)
        2. Assign her as Fund Administrator of Apex Growth Fund
        
        Proceed?"

User: "Yes"

Agent: [execute both statements atomically]
       "Done! Sarah Connor is now Fund Administrator of Apex Growth Fund."
```

### 4.4 Complex Workflow

```
User: "Set up the full UBO structure - the fund is owned 60% by Holdco Ltd 
       which is owned by James Wilson"

Agent: [Internal]
  1. classify_intent → AddOwnership (complex)
  2. extract:
     - Apex Growth Fund (from session @fund)
     - Holdco Ltd (corporate, needs creation or lookup)
     - James Wilson (person, needs creation or lookup)
     - 60% ownership fund→holdco
     - 100% implied holdco→james (controls = owns for UBO)
  3. entity_search("Holdco Ltd") → not found
  4. entity_search("James Wilson") → not found

Agent: "I'll set up the ownership structure:
        
        James Wilson (100%)
             │
             ▼
        Holdco Ltd (60%)
             │
             ▼
        Apex Growth Fund
        
        I need to create both Holdco Ltd and James Wilson. Please provide:
        
        For Holdco Ltd:
        • Jurisdiction of incorporation
        • Registration number (optional)
        
        For James Wilson:
        • Date of birth
        • Nationality"

User: "Holdco is BVI registered. James is British, born 1970-05-20"

Agent: [Internal]
  5. generate_dsl:
     ; Create the corporate owner
     (entity.create-legal-entity 
        :legal-name "Holdco Ltd"
        :jurisdiction "VG"
        :entity-type "CORPORATION"
        :as @holdco)
     
     ; Create the UBO
     (entity.create-proper-person
        :first-name "James"
        :last-name "Wilson"
        :date-of-birth "1970-05-20"
        :nationality "GB"
        :as @james)
     
     ; Ownership: James → Holdco (100%)
     (ubo.add-ownership
        :owner-id @james
        :owned-id @holdco
        :percentage 100.0
        :ownership-type "DIRECT")
     
     ; Ownership: Holdco → Fund (60%)
     (ubo.add-ownership
        :owner-id @holdco
        :owned-id @fund
        :percentage 60.0
        :ownership-type "DIRECT")
     
     ; Calculate UBO (James qualifies via chain)
     (ubo.calculate :cbu-id @fund)

  6. validate → valid
  7. Plan shows 5 operations in correct order

Agent: "Here's the plan:
        1. Create Holdco Ltd (BVI corporation)
        2. Create James Wilson (British, DOB 1970-05-20)
        3. Record James owns 100% of Holdco
        4. Record Holdco owns 60% of Apex Growth Fund
        5. Calculate UBO (James will qualify as UBO with 60% indirect ownership)
        
        Execute?"

User: "Yes"

Agent: [execute all - DAG ensures correct order]
       
       "Complete! Ownership structure recorded:
        • James Wilson identified as UBO (60% indirect via Holdco Ltd)
        • UBO verification status: PENDING
        
        Would you like to proceed with UBO verification, or add more owners?"
```

---

## Part 5: Implementation Plan

### Phase 1: MCP Server Foundation (Week 1)

| Task | Effort | Description |
|------|--------|-------------|
| MCP server skeleton | 2hr | Rust MCP server with tool registration |
| `dsl_validate` tool | 2hr | Wrap existing validator |
| `dsl_execute` tool | 2hr | Wrap existing executor |
| `entity_search` tool | 2hr | Wrap EntityGateway |
| `session_context` tool | 2hr | Wrap ReplSession |
| Integration tests | 2hr | Tool → DSL platform flow |

**Deliverable**: Agent can validate and execute DSL via MCP tools.

### Phase 2: Workflow Templates (Week 2)

| Task | Effort | Description |
|------|--------|-------------|
| Template YAML schema | 1hr | Define workflow template format |
| OnboardIndividual template | 2hr | Full individual onboarding flow |
| OnboardCorporate template | 2hr | Corporate with roles and UBO |
| OnboardFund template | 2hr | Fund structure with relationships |
| `workflow_template` tool | 2hr | Retrieve and parameterize templates |
| `suggest_verb` tool | 2hr | Intent → verb mapping |

**Deliverable**: Agent can get structured workflows for common intents.

### Phase 3: Error Recovery (Week 3)

| Task | Effort | Description |
|------|--------|-------------|
| Recovery options generator | 3hr | Analyze errors → recovery paths |
| Auto-fix engine | 2hr | Apply safe automatic corrections |
| Disambiguation protocol | 2hr | Structure ambiguous reference handling |
| Missing info protocol | 2hr | Structure info gathering |
| Agent prompt templates | 2hr | Effective prompts for each situation |

**Deliverable**: Agent can recover from errors without failing.

### Phase 4: Integration & Polish (Week 4)

| Task | Effort | Description |
|------|--------|-------------|
| End-to-end testing | 4hr | Full conversation flows |
| Performance optimization | 2hr | Batch operations, caching |
| Documentation | 2hr | Agent integration guide |
| Example conversations | 2hr | Reference implementations |

**Total Estimated Effort**: ~40 hours (4 weeks part-time)

---

## Part 6: Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Intent classification accuracy | >95% | Correct workflow selected |
| Entity resolution accuracy | >98% | Correct entity found/created |
| First-attempt success rate | >80% | DSL executes without retry |
| Error recovery rate | >90% | Recoverable errors resolved |
| Average turns to completion | <4 | User messages per workflow |
| Latency (validate + plan) | <500ms | Tool call to response |

---

## Files to Create

```
rust/src/mcp/
├── mod.rs                     # MCP server setup
├── server.rs                  # Tool registration and dispatch
├── tools/
│   ├── mod.rs
│   ├── dsl_validate.rs        # Validation tool
│   ├── dsl_execute.rs         # Execution tool
│   ├── entity_search.rs       # Entity search tool
│   ├── suggest_verb.rs        # Verb suggestion tool
│   ├── workflow_template.rs   # Workflow templates
│   └── session_context.rs     # Session management
├── templates/
│   ├── mod.rs
│   ├── onboard_individual.yaml
│   ├── onboard_corporate.yaml
│   ├── onboard_fund.yaml
│   └── add_ubo.yaml
├── recovery/
│   ├── mod.rs
│   ├── auto_fix.rs            # Automatic corrections
│   ├── disambiguation.rs      # Ambiguous reference handling
│   └── info_gathering.rs      # Missing info collection
└── prompts/
    ├── mod.rs
    └── agent_templates.rs     # Prompt templates for agent
```

---

## Next Steps

1. **Decide MCP vs HTTP API** - MCP gives Claude native tool access; HTTP gives broader client support
2. **Define priority workflows** - Which 3-5 workflows are most important?
3. **Prototype single flow** - End-to-end "onboard fund" via MCP
4. **Iterate on prompts** - Agent behavior tuning

Ready to start with the MCP server skeleton?
