# Consolidated TODO: DSL Platform Backlog

**Generated by**: Opus 4.5 Architecture Review  
**Date**: 2025-12-14  
**Scope**: All outstanding work for DSL validation, execution, and tooling

---

## Status Legend

- ‚úÖ DONE
- üîÑ IN PROGRESS
- ‚è≥ NOT STARTED
- üö´ BLOCKED (by dependency)

---

## Executive Summary

| Category | Items | Done | Remaining |
|----------|-------|------|-----------|
| Performance | 1 | 1 | 0 |
| Bug Fixes | 4 | 4 | 0 |
| Schema Cleanup | 1 | 1 | 0 |
| Missing Verbs | 3 | 3 | 0 |
| Core Infrastructure | 4 | 4 | 0 |
| DAG Execution | 5 | 4 | 1 |
| Tooling (LSP/REPL) | 3 | 0 | 3 |
| **Total** | **21** | **17** | **4** |

---

# PART 1: IMMEDIATE FIXES (Do First)

These are bugs and inconsistencies that will cause runtime failures.

## 1.1 ‚úÖ Batch EntityRef Resolution [DONE]

**Status**: DONE - Implemented 2025-12-14

**What was done**:
- `batch_resolve_all_refs()` now called in `validate()` after parsing
- Cache threaded through `validate_verb_call` ‚Üí `validate_argument_value`
- Cache lookup before falling back to individual gRPC calls
- ~6x speedup (30 refs ‚Üí 5 gRPC calls instead of 30)

---

## 1.2 ‚úÖ Fix `ubo.verify-ubo` Wrong Table Reference [DONE]

**File**: `rust/config/verbs/ubo.yaml`

**Problem**: Lookup references non-existent table `ubo_determinations`

**Fix**:
```yaml
# Change lookup.table from:
table: ubo_determinations  # WRONG

# To:
table: ubo_registry        # CORRECT
```

---

## 1.3 ‚úÖ Fix `isda.create` Missing Counterparty Lookup [DONE]

**File**: `rust/config/verbs/custody/isda.yaml`

**Problem**: `counterparty` arg has no lookup - users can't resolve entity name ‚Üí UUID

**Fix** - Add lookup block:
```yaml
- name: counterparty
  type: uuid
  required: true
  maps_to: counterparty_entity_id
  lookup:                          # ADD THIS BLOCK
    table: entities
    entity_type: entity
    schema: ob-poc
    search_key: name
    primary_key: entity_id
```

---

## 1.4 ‚úÖ Fix KYC Case Status Enum Mismatch [DONE]

**File**: `rust/config/verbs/kyc/kyc-case.yaml`

**Problem**: Schema allows `REFER_TO_REGULATOR`, `DO_NOT_ONBOARD` but verb doesn't

**Fix** - Update `update-status` and `close` verbs to add:
```yaml
valid_values:
  # ... existing values ...
  - REFER_TO_REGULATOR    # ADD
  - DO_NOT_ONBOARD        # ADD
```

---

## 1.5 ‚úÖ Fix UBO Verification Status Enum Mismatch [DONE]

**File**: `rust/config/verbs/ubo.yaml`

**Problem**: Schema has `SUSPECTED`, `PROVEN`, `REMOVED` but verb doesn't allow them

**Fix** - Update `verify-ubo` verb:
```yaml
valid_values:
  - SUSPECTED      # ADD
  - PENDING
  - PROVEN         # ADD
  - VERIFIED
  - FAILED
  - DISPUTED
  - REMOVED        # ADD
```

---

# PART 2: SCHEMA & VERB CLEANUP

## 2.1 ‚úÖ Consolidate Duplicate CBU Category Constraint [DONE]

**Problem**: `cbus` table has TWO CHECK constraints with different values

**Fix** - Create migration:
```sql
-- consolidate_cbu_category_constraint.sql
ALTER TABLE "ob-poc".cbus DROP CONSTRAINT IF EXISTS cbus_category_check;
ALTER TABLE "ob-poc".cbus DROP CONSTRAINT IF EXISTS chk_cbu_category;

ALTER TABLE "ob-poc".cbus ADD CONSTRAINT chk_cbu_category CHECK (
  cbu_category IS NULL OR cbu_category IN (
    'FUND_MANDATE', 'CORPORATE_GROUP', 'INSTITUTIONAL_ACCOUNT',
    'RETAIL_CLIENT', 'FAMILY_TRUST', 'INTERNAL_TEST', 'CORRESPONDENT_BANK'
  )
);
```

**Also update** `cbu.yaml` `set-category` verb to match.

---

## 2.2 ‚úÖ Add Missing `cbu.attach-evidence` Verb [DONE]

**File**: `rust/config/verbs/cbu.yaml`

**Problem**: `cbu_evidence` table exists but no verb to use it

**Add**:
```yaml
attach-evidence:
  description: Attach evidence to CBU
  behavior: crud
  crud:
    operation: insert
    table: cbu_evidence
    schema: ob-poc
    returning: evidence_id
  args:
    - name: cbu-id
      type: uuid
      required: true
      maps_to: cbu_id
      lookup:
        table: cbus
        entity_type: cbu
        schema: ob-poc
        search_key: name
        primary_key: cbu_id
    - name: document-id
      type: uuid
      required: false
      maps_to: document_id
    - name: evidence-type
      type: string
      required: true
      maps_to: evidence_type
      valid_values: [DOCUMENT, ATTESTATION, SCREENING, REGISTRY_CHECK, MANUAL_VERIFICATION]
    - name: description
      type: string
      required: false
      maps_to: description
```

---

## 2.3 ‚úÖ Add Missing `ubo.supersede` and `ubo.remove` Verbs [DONE]

**File**: `rust/config/verbs/ubo.yaml`

**Problem**: Schema has `superseded_by`, `superseded_at` columns but no verbs

**Add** `supersede` and `remove` verbs (see TODO_ARCHITECTURE_FIXES.md for full YAML).

---

## 2.4 ‚úÖ Add Missing `kyc-case.reopen` Verb [DONE]

**File**: `rust/config/verbs/kyc/kyc-case.yaml`

**Problem**: No way to reopen closed case for remediation

**Add** `reopen` verb with status reset to INTAKE.

---

# PART 3: CORE INFRASTRUCTURE

These modules provide foundation for DAG execution and better tooling.

## 3.1 ‚úÖ Create `diagnostics.rs` - Unified Diagnostic Types [DONE]

**File**: `rust/src/dsl_v2/diagnostics.rs`

**Purpose**: Single diagnostic type used across parse, validation, planning, execution

```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Severity { Error, Warning, Hint, Info }

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum DiagnosticCode {
    // Parse
    SyntaxError, UnexpectedToken,
    // Validation
    UnknownVerb, UnknownArg, MissingRequiredArg, UndefinedSymbol, DuplicateBinding,
    // Planning
    CyclicDependency, MissingProducer,
    // Hints
    ImplicitCreateSuggested, ReorderingSuggested,
}

pub struct Diagnostic {
    pub severity: Severity,
    pub code: DiagnosticCode,
    pub message: String,
    pub span: Option<SourceSpan>,
    pub suggested_fix: Option<SuggestedFix>,
}
```

**Integration**: Replace existing ad-hoc diagnostic types in semantic_validator, lsp_validator.

---

## 3.2 ‚úÖ Create `execution_result.rs` - Clean Result Types [DONE]

**File**: `rust/src/dsl_v2/execution_result.rs`

**Purpose**: Replace `last_created_pk()` coupling with explicit result types

```rust
#[derive(Clone, Debug)]
pub enum StepResult {
    Created { pk: Uuid, entity_type: String },
    Updated { pk: Uuid, entity_type: String },
    Deleted { pk: Uuid, entity_type: String },
    Read { pk: Uuid, data: serde_json::Value },
    NoOp,
    Custom { op_id: String, data: Value, produced_pk: Option<Uuid> },
}

impl StepResult {
    pub fn produced_pk(&self) -> Option<Uuid> { ... }
}

pub struct ExecutionResults {
    pub step_results: Vec<(usize, StepResult)>,
    pub bindings_created: HashMap<String, Uuid>,
    pub errors: Vec<(usize, String)>,
}
```

---

## 3.3 ‚úÖ Create `planning_facade.rs` - Central Planning Entrypoint [DONE]

**File**: `rust/src/dsl_v2/planning_facade.rs`

**Purpose**: Single function that parses, validates, plans, returns diagnostics + plan

```rust
pub enum ImplicitCreateMode { Disabled, Enabled, Silent }

pub struct PlanningInput<'a> {
    pub source: &'a str,
    pub registry: Arc<UnifiedVerbRegistry>,
    pub executed_bindings: Option<&'a BindingContext>,  // For REPL
    pub strict_semantics: bool,
    pub implicit_create_mode: ImplicitCreateMode,
}

pub struct PlanningOutput {
    pub program: Program,
    pub diagnostics: Vec<Diagnostic>,
    pub plan: Option<ExecutionPlan>,
    pub was_reordered: bool,
    pub synthetic_steps: Vec<SyntheticStep>,
}

pub fn analyse_and_plan(input: PlanningInput) -> PlanningOutput {
    // 1. Parse
    // 2. Batch resolve refs
    // 3. Validate (collect diagnostics, don't fail early)
    // 4. Build plan (even with errors, for LSP)
    // 5. Return everything
}
```

**Key**: Always attempts planning even with validation errors - LSP needs full picture.

---

## 3.4 ‚úÖ Create `repl_session.rs` - REPL State with Undo [DONE]

**File**: `rust/src/dsl_v2/repl_session.rs`

**Purpose**: Track previously executed bindings for incremental REPL execution

```rust
pub struct ExecutedBlock {
    pub program: Program,
    pub bindings_created: HashMap<String, Uuid>,
    pub binding_types: HashMap<String, String>,
}

pub struct ReplSession {
    blocks: Vec<ExecutedBlock>,  // Stack for undo
    all_bindings: HashMap<String, Uuid>,
    all_types: HashMap<String, String>,
}

impl ReplSession {
    pub fn append_executed(&mut self, program: Program, bindings: HashMap<String, Uuid>, types: HashMap<String, String>);
    pub fn undo(&mut self) -> Option<ExecutedBlock>;
    pub fn has_binding(&self, name: &str) -> bool;
    pub fn binding_context(&self) -> BindingContext;
    pub fn reset(&mut self);
}
```

---

# PART 4: DAG EXECUTION LAYER

This is the core architectural change that enables correct ordering, dry-run, cycle detection.

## 4.1 ‚úÖ Create `ops.rs` - Op Enum Definition [DONE]

**File**: `rust/src/dsl_v2/ops.rs`

**Purpose**: Core operation types that verbs compile to

```rust
/// Unique key for an entity within a DSL program
#[derive(Clone, Debug, Hash, PartialEq, Eq)]
pub struct EntityKey {
    pub entity_type: String,
    pub binding: Option<String>,  // @fund, @person
    pub natural_key: Option<String>,  // For lookup by name
}

/// Reference to another Op in the graph
#[derive(Clone, Debug, Hash, PartialEq, Eq)]
pub enum OpRef {
    Entity(EntityKey),
    Document(String),
    Op(usize),  // Index into ops vec
}

#[derive(Clone, Debug)]
pub enum Op {
    // Entity operations
    EnsureEntity {
        entity_type: String,
        key: EntityKey,
        attrs: HashMap<String, Value>,
        source_stmt: usize,
    },
    SetFK {
        source: EntityKey,
        field: String,
        target: EntityKey,
        source_stmt: usize,
    },
    
    // Role operations
    LinkRole {
        cbu: EntityKey,
        entity: EntityKey,
        role: String,
        source_stmt: usize,
    },
    UnlinkRole { ... },
    
    // Ownership operations
    AddOwnership {
        owner: EntityKey,
        owned: EntityKey,
        percentage: Decimal,
        ownership_type: String,
        source_stmt: usize,
    },
    
    // UBO operations
    RegisterUBO {
        cbu: EntityKey,
        subject: EntityKey,
        ubo_person: EntityKey,
        qualifying_reason: String,
        source_stmt: usize,
    },
    
    // Document operations
    UpsertDoc {
        doc_type: String,
        key: String,
        content: Value,
        source_stmt: usize,
    },
    Materialize {
        source: String,
        sections: Vec<String>,
        force: bool,
        source_stmt: usize,
    },
    
    // Evidence & screening
    AttachEvidence { ... },
    RunScreening { ... },
    
    // Case management
    CreateCase { ... },
    UpdateCaseStatus { ... },
    
    // Validation marker (not executed, just checks ref exists)
    RequireRef {
        ref_type: RefType,
        value: String,
        source_stmt: usize,
    },
}

impl Op {
    /// What this op depends on (must execute first)
    pub fn dependencies(&self) -> Vec<OpRef> { ... }
    
    /// What this op produces (other ops may depend on)
    pub fn produces(&self) -> Option<OpRef> { ... }
    
    /// Human-readable description for dry-run output
    pub fn describe(&self) -> String { ... }
    
    /// Source statement index for error mapping
    pub fn source_stmt(&self) -> usize { ... }
}
```

**Dependency Rules**:
- `EnsureEntity` ‚Üí no deps (creates entity)
- `SetFK(A.fk = B)` ‚Üí depends on `EnsureEntity(A)`, `EnsureEntity(B)`
- `LinkRole(cbu, entity, role)` ‚Üí depends on both entities
- `AddOwnership(owner, owned)` ‚Üí depends on both entities
- `Materialize(profile)` ‚Üí depends on `UpsertDoc(profile)` + referenced entities

---

## 4.2 ‚úÖ Create `compiler.rs` - Verb ‚Üí Op Compiler [DONE]

**File**: `rust/src/dsl_v2/compiler.rs`

**Purpose**: Transform validated AST to Ops

```rust
pub struct CompiledProgram {
    pub ops: Vec<Op>,
    pub symbol_table: HashMap<String, EntityKey>,
    pub errors: Vec<CompileError>,
}

pub enum CompileError {
    UnknownVerb { domain: String, verb: String },
    MissingBinding { stmt: usize, arg: String },
    UnsupportedVerbBehavior { verb: String },
}

pub fn compile(program: &Program, registry: &UnifiedVerbRegistry) -> CompiledProgram {
    let mut ops = Vec::new();
    let mut symbol_table = HashMap::new();
    let mut errors = Vec::new();
    
    for (idx, stmt) in program.statements.iter().enumerate() {
        match stmt {
            Statement::VerbCall(vc) => {
                match compile_verb_call(vc, idx, &symbol_table, registry) {
                    Ok(new_ops) => {
                        // Track binding if present
                        if let Some(binding) = &vc.binding {
                            let key = EntityKey::from_verb_call(vc);
                            symbol_table.insert(binding.clone(), key);
                        }
                        ops.extend(new_ops);
                    }
                    Err(e) => errors.push(e),
                }
            }
            Statement::Comment(_) => {}
        }
    }
    
    CompiledProgram { ops, symbol_table, errors }
}

fn compile_verb_call(
    vc: &VerbCall,
    stmt_idx: usize,
    symbols: &HashMap<String, EntityKey>,
    registry: &UnifiedVerbRegistry,
) -> Result<Vec<Op>, CompileError> {
    // Map verb to ops based on domain.verb pattern
    // Most verbs produce single Op, some (composites) produce multiple
}
```

**Verb ‚Üí Op Mappings**:

| Verb Pattern | Op(s) Generated |
|--------------|-----------------|
| `cbu.create` | `EnsureEntity { entity_type: "cbu" }` |
| `entity.create-*` | `EnsureEntity { entity_type: "..." }` |
| `cbu.assign-role` | `LinkRole { cbu, entity, role }` |
| `cbu.remove-role` | `UnlinkRole { cbu, entity, role }` |
| `ubo.add-ownership` | `AddOwnership { owner, owned, pct, type }` |
| `ubo.calculate` | `RegisterUBO { ... }` (custom op) |
| `trading-profile.import` | `UpsertDoc { doc_type: "trading_profile" }` |
| `trading-profile.materialize` | `Materialize { source, sections }` |
| `kyc-case.open` | `CreateCase { cbu, case_type }` |
| `kyc-case.update-status` | `UpdateCaseStatus { case, status }` |

---

## 4.3 ‚úÖ Create `dag.rs` - DAG Builder + Toposort [DONE]

**File**: `rust/src/dsl_v2/dag.rs`

**Purpose**: Build dependency graph, topologically sort, detect cycles

```rust
pub struct ExecutionPlan {
    pub phases: Vec<ExecutionPhase>,
    pub total_ops: usize,
}

pub struct ExecutionPhase {
    pub name: String,  // "Create Entities", "Set Relationships", etc.
    pub ops: Vec<Op>,
}

pub enum DagError {
    CyclicDependency {
        cycle: Vec<String>,  // Human-readable cycle description
    },
    MissingDependency {
        op: String,
        missing: String,
    },
}

pub fn build_execution_plan(ops: Vec<Op>) -> Result<ExecutionPlan, DagError> {
    // 1. Build adjacency list from Op dependencies
    // 2. Kahn's algorithm for toposort
    // 3. Detect cycles with clear error messages
    // 4. Group ops into execution phases
}

/// Kahn's algorithm implementation
fn toposort(ops: &[Op]) -> Result<Vec<usize>, DagError> {
    let n = ops.len();
    let mut in_degree = vec![0; n];
    let mut adj: Vec<Vec<usize>> = vec![vec![]; n];
    
    // Build graph...
    // Process nodes with in_degree 0...
    // Detect cycles if not all nodes processed...
}

/// Group sorted ops into logical phases for readability
fn group_into_phases(sorted_ops: Vec<Op>) -> Vec<ExecutionPhase> {
    // Phase 1: Entity creation (EnsureEntity)
    // Phase 2: Relationships (SetFK, LinkRole, AddOwnership)
    // Phase 3: Documents (UpsertDoc)
    // Phase 4: Materialization (Materialize)
    // Phase 5: Cases & Screening
}

/// Generate human-readable execution plan
pub fn describe_plan(plan: &ExecutionPlan) -> String {
    let mut out = String::new();
    for phase in &plan.phases {
        out.push_str(&format!("\n=== {} ===\n", phase.name));
        for (i, op) in phase.ops.iter().enumerate() {
            out.push_str(&format!("  {}. {}\n", i + 1, op.describe()));
        }
    }
    out
}
```

---

## 4.4 ‚è≥ Update `executor.rs` - DAG-Aware Execution [REMAINING]

**File**: `rust/src/dsl_v2/executor.rs` (modify existing)

**Purpose**: Execute ops in topological order, support dry-run

```rust
impl DslExecutor {
    /// Execute with DAG ordering (new method)
    pub async fn execute_with_dag(
        &self,
        source: &str,
        context: &ValidationContext,
        dry_run: bool,
    ) -> Result<ExecutionResults, ExecutionError> {
        // 1. Parse
        let program = parse_program(source)?;
        
        // 2. Validate (with batch resolution)
        let validated = self.validator.validate(&program).await?;
        
        // 3. Compile to Ops
        let compiled = compile(&validated.program, &self.registry);
        if !compiled.errors.is_empty() {
            return Err(ExecutionError::CompileErrors(compiled.errors));
        }
        
        // 4. Build DAG and sort
        let plan = build_execution_plan(compiled.ops)?;
        
        // 5. Dry run: just return plan description
        if dry_run {
            return Ok(ExecutionResults {
                plan_description: Some(describe_plan(&plan)),
                ..Default::default()
            });
        }
        
        // 6. Execute in order
        let mut results = ExecutionResults::new();
        for phase in plan.phases {
            for op in phase.ops {
                let result = self.execute_op(&op, &mut results).await?;
                results.record_step(op.source_stmt(), result, None);
            }
        }
        
        Ok(results)
    }
    
    /// Execute a single Op
    async fn execute_op(&self, op: &Op, results: &ExecutionResults) -> Result<StepResult, ExecutionError> {
        match op {
            Op::EnsureEntity { entity_type, key, attrs, .. } => {
                // Map to existing CRUD executor
                self.crud_executor.insert(entity_type, attrs).await
            }
            Op::SetFK { source, field, target, .. } => {
                // Update FK column
                let target_pk = results.get_pk(&target)?;
                self.crud_executor.update_fk(source, field, target_pk).await
            }
            Op::LinkRole { cbu, entity, role, .. } => {
                // Insert into junction table
            }
            // ... other op types
        }
    }
}
```

---

## 4.5 ‚úÖ DAG Tests [DONE]

**File**: `rust/src/dsl_v2/dag_tests.rs`

```rust
#[test]
fn test_reordering_executes_correctly() {
    // Verbs in wrong source order should execute correctly
    let source = r#"
        (cbu.assign-role :cbu-id @fund :entity-id @john :role "DIRECTOR")
        (cbu.create :name "Apex Fund" :jurisdiction "LU" :as @fund)
        (entity.create-proper-person :first-name "John" :last-name "Smith" :as @john)
    "#;
    
    let plan = compile_and_plan(source).unwrap();
    
    // Expected order: create john, create fund, assign role
    assert_eq!(plan.phases[0].ops[0].describe(), "Create entity: proper_person");
    assert_eq!(plan.phases[0].ops[1].describe(), "Create entity: cbu");
    assert_eq!(plan.phases[1].ops[0].describe(), "Link role: DIRECTOR");
}

#[test]
fn test_cycle_detection() {
    // Circular dependency should be caught
    let source = r#"
        (entity.set-parent :entity-id @a :parent-id @b)
        (entity.set-parent :entity-id @b :parent-id @a)
    "#;
    
    let result = compile_and_plan(source);
    assert!(matches!(result, Err(DagError::CyclicDependency { .. })));
}

#[test]
fn test_missing_dependency() {
    // Reference to undefined entity should error
    let source = r#"
        (cbu.assign-role :cbu-id @undefined :entity-id @john :role "DIRECTOR")
    "#;
    
    let result = compile_and_plan(source);
    assert!(matches!(result, Err(DagError::MissingDependency { .. })));
}

#[tokio::test]
async fn test_dry_run_shows_plan() {
    let source = r#"
        (cbu.create :name "Test" :jurisdiction "US" :as @cbu)
        (entity.create-proper-person :first-name "Jane" :as @jane)
        (cbu.assign-role :cbu-id @cbu :entity-id @jane :role "DIRECTOR")
    "#;
    
    let result = executor.execute_with_dag(source, &context, true).await.unwrap();
    
    assert!(result.plan_description.is_some());
    assert!(result.plan_description.unwrap().contains("Create entity: cbu"));
}
```

---

# PART 5: TOOLING (LSP/REPL)

## 5.1 ‚è≥ Wire Planning Facade into LSP Handler [REMAINING]

**File**: `rust/src/dsl_v2/lsp_handler.rs` (or similar)

```rust
pub async fn handle_did_change(&self, params: DidChangeTextDocumentParams) {
    let source = &params.content_changes[0].text;
    
    let input = PlanningInput {
        source,
        registry: self.registry.clone(),
        executed_bindings: self.session.as_ref().map(|s| s.binding_context()),
        strict_semantics: false,  // LSP is lenient
        implicit_create_mode: ImplicitCreateMode::Enabled,
    };
    
    let output = analyse_and_plan(input);
    
    // Publish diagnostics
    let lsp_diags = output.diagnostics.iter()
        .map(to_lsp_diagnostic)
        .collect();
    self.client.publish_diagnostics(uri, lsp_diags, None).await;
    
    // Offer code actions
    if output.was_reordered {
        self.offer_reorder_action(&output);
    }
    for step in &output.synthetic_steps {
        self.offer_implicit_create_action(step);
    }
}
```

---

## 5.2 ‚è≥ Add Code Actions for Implicit Creates [REMAINING]

When validation detects a reference to undefined binding, offer to insert create statement:

```rust
fn offer_implicit_create_action(&self, step: &SyntheticStep) {
    CodeAction {
        title: format!("Create '{}' ({}) before use", step.binding, step.entity_type),
        kind: Some(CodeActionKind::QUICKFIX),
        edit: Some(WorkspaceEdit {
            changes: Some([(
                uri.clone(),
                vec![TextEdit {
                    range: Range { start: Position { line: step.insert_before_stmt, .. }, .. },
                    new_text: format!("{}\n", step.suggested_dsl),
                }]
            )].into_iter().collect()),
            ..Default::default()
        }),
        ..Default::default()
    }
}
```

---

## 5.3 ‚è≥ Add Reorder Code Action [REMAINING]

When DAG shows statements need reordering, offer to fix:

```rust
fn offer_reorder_action(&self, output: &PlanningOutput) {
    CodeAction {
        title: "Reorder statements for correct execution".to_string(),
        kind: Some(CodeActionKind::REFACTOR),
        // Generate reordered source from plan
        edit: Some(reorder_source(output)),
        ..Default::default()
    }
}
```

---

# PART 6: MODULE STRUCTURE

After all implementation, `dsl_v2` directory should look like:

```
rust/src/dsl_v2/
‚îú‚îÄ‚îÄ mod.rs                    # Re-exports
‚îú‚îÄ‚îÄ ast.rs                    # AST types
‚îú‚îÄ‚îÄ parser.rs                 # Parser
‚îú‚îÄ‚îÄ diagnostics.rs            # NEW: Unified diagnostic types
‚îú‚îÄ‚îÄ execution_result.rs       # NEW: StepResult, ExecutionResults
‚îú‚îÄ‚îÄ planning_facade.rs        # NEW: analyse_and_plan entrypoint
‚îú‚îÄ‚îÄ ops.rs                    # NEW: Op enum
‚îú‚îÄ‚îÄ compiler.rs               # NEW: Verb ‚Üí Op compiler
‚îú‚îÄ‚îÄ dag.rs                    # NEW: DAG builder, toposort
‚îú‚îÄ‚îÄ execution_plan.rs         # ExecutionPlan, PlanningContext
‚îú‚îÄ‚îÄ verb_registry.rs          # UnifiedVerbRegistry
‚îú‚îÄ‚îÄ binding_context.rs        # BindingContext
‚îú‚îÄ‚îÄ repl_session.rs           # NEW: ReplSession with undo
‚îú‚îÄ‚îÄ topo_sort.rs              # Existing (may merge with dag.rs)
‚îú‚îÄ‚îÄ executor.rs               # DslExecutor (updated for DAG)
‚îú‚îÄ‚îÄ generic_executor.rs       # GenericCrudExecutor
‚îú‚îÄ‚îÄ gateway_resolver.rs       # EntityGateway client
‚îú‚îÄ‚îÄ semantic_validator.rs     # Validation (uses batch resolution)
‚îú‚îÄ‚îÄ custom_ops/
‚îÇ   ‚îú‚îÄ‚îÄ mod.rs                # CustomOperation trait, registry
‚îÇ   ‚îî‚îÄ‚îÄ ...                   # Individual implementations
‚îú‚îÄ‚îÄ lsp_validator.rs          # LSP handler (uses facade)
‚îî‚îÄ‚îÄ synthetic_steps.rs        # NEW: build_synthetic_create helper
```

---

# IMPLEMENTATION ORDER

Recommended sequence to minimize conflicts and maximize testability:

| Order | Item | Dependency | Effort |
|-------|------|------------|--------|
| 1 | Bug fixes (1.2-1.5) | None | 30min |
| 2 | Schema cleanup (2.1) | None | 15min |
| 3 | Missing verbs (2.2-2.4) | None | 1hr |
| 4 | `diagnostics.rs` (3.1) | None | 1hr |
| 5 | `execution_result.rs` (3.2) | 3.1 | 1hr |
| 6 | `ops.rs` (4.1) | None | 2hr |
| 7 | `compiler.rs` (4.2) | 4.1 | 3hr |
| 8 | `dag.rs` (4.3) | 4.1 | 2hr |
| 9 | DAG tests (4.5) | 4.2, 4.3 | 1hr |
| 10 | Executor update (4.4) | 4.1-4.3, 3.2 | 2hr |
| 11 | `planning_facade.rs` (3.3) | 3.1, 3.2, 4.3 | 2hr |
| 12 | `repl_session.rs` (3.4) | 3.3 | 1hr |
| 13 | LSP integration (5.1-5.3) | 3.3, 3.4 | 2hr |

**Total estimated effort**: ~18-20 hours

---

# VERIFICATION CHECKLIST

## After Bug Fixes (Part 1)
- [ ] `ubo.verify-ubo` lookup resolves correctly
- [ ] `isda.create` allows entity name for counterparty
- [ ] `kyc-case.update-status` accepts all schema statuses
- [ ] `ubo.verify-ubo` accepts all verification statuses

## After Schema/Verb Cleanup (Part 2)
- [ ] Database has single consolidated `chk_cbu_category` constraint
- [ ] `cbu.attach-evidence` verb works
- [ ] `ubo.supersede` and `ubo.remove` verbs work
- [ ] `kyc-case.reopen` verb works

## After DAG Implementation (Part 4)
- [ ] Out-of-order DSL executes correctly
- [ ] Cycles detected with clear error messages
- [ ] Dry-run shows execution plan
- [ ] Performance: <50ms for 50-statement program

## After Tooling (Part 5)
- [ ] LSP shows diagnostics in real-time
- [ ] Code action offered for implicit creates
- [ ] Code action offered for reordering
- [ ] REPL undo works correctly

---

# COMMANDS

```bash
# Validate all verb YAML files
cargo xtask validate-verbs

# Run DSL tests
cargo test -p ob-poc --lib dsl_v2

# Run integration tests
cargo test -p ob-poc --test dsl_integration

# Check for enum mismatches
cargo xtask schema-verb-audit
```
