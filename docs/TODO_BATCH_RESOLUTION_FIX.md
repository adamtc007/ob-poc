# TODO: Wire Batch EntityRef Resolution into Semantic Validator

**Generated by**: Opus 4.5 Architecture Review  
**Date**: 2025-12-14  
**Priority**: HIGH - ~6x performance improvement for validation  
**Estimated Effort**: 1-2 hours

---

## Problem

`batch_resolve_all_refs()` is implemented in `semantic_validator.rs` (lines 75-135) but **never called**.

Current flow:
```
validate()
  → parse
  → for each statement:
      → validate_verb_call_with_resolution()
          → validate_argument_value()
              → self.resolver.resolve(ref_type, s).await  ← INDIVIDUAL CALL
```

Each EntityRef triggers a separate gRPC call to EntityGateway.

**Impact**: 30 EntityRefs = 30 gRPC calls = ~150ms at 5ms/call

---

## Solution

Wire the existing `batch_resolve_all_refs()` method into the validation flow.

### Step 1: Modify `validate()` to call batch resolution upfront

**File**: `rust/src/dsl_v2/semantic_validator.rs`

**Location**: After parsing (~line 206), before AST walk

```rust
pub async fn validate(&mut self, request: &ValidationRequest) -> ValidationResult {
    // Clear resolver cache for fresh validation
    self.resolver.clear_cache();

    // Step 1: Parse
    let program = match parse_program(&request.source) {
        Ok(p) => p,
        Err(e) => {
            return ValidationResult::Err(vec![Diagnostic { ... }]);
        }
    };

    // ========== ADD THIS BLOCK ==========
    // Step 1.5: Batch resolve all EntityRefs upfront
    // This reduces gRPC calls from O(n) to O(types) - typically 30 calls → 5 calls
    let ref_cache = self.batch_resolve_all_refs(&program).await;
    tracing::debug!(
        "Batch resolved {} refs across {} types",
        ref_cache.len(),
        ref_cache.keys().map(|(rt, _)| rt).collect::<std::collections::HashSet<_>>().len()
    );
    // =====================================

    // Step 2: Walk AST and validate...
    let mut diagnostics = DiagnosticBuilder::new();
    // ... rest of method
```

### Step 2: Pass cache through call chain

Update method signatures to accept the cache:

```rust
// validate_verb_call - add ref_cache parameter
async fn validate_verb_call(
    &mut self,
    verb_call: &VerbCall,
    source: &str,
    context: &ValidationContext,
    symbols: &mut HashMap<String, SymbolInfo>,
    diagnostics: &mut DiagnosticBuilder,
    ref_cache: &HashMap<(RefType, String), ResolveResult>,  // ADD THIS
) -> Option<ValidatedStatement>

// validate_verb_call_with_resolution - add ref_cache parameter  
async fn validate_verb_call_with_resolution(
    &mut self,
    verb_call: &VerbCall,
    source: &str,
    context: &ValidationContext,
    symbols: &mut HashMap<String, SymbolInfo>,
    diagnostics: &mut DiagnosticBuilder,
    stmt_idx: usize,
    resolved_keys: &mut HashMap<(usize, String), String>,
    ref_cache: &HashMap<(RefType, String), ResolveResult>,  // ADD THIS
) -> Option<ValidatedStatement>

// validate_argument_value - add ref_cache parameter
async fn validate_argument_value(
    &mut self,
    verb: &str,
    key: &str,
    node: &AstNode,
    node_span: &Span,
    source: &str,
    symbols: &mut HashMap<String, SymbolInfo>,
    diagnostics: &mut DiagnosticBuilder,
    ref_cache: &HashMap<(RefType, String), ResolveResult>,  // ADD THIS
) -> Option<crate::dsl_v2::validation::ResolvedArg>
```

### Step 3: Update call sites in `validate()`

```rust
// Around line 245-258, update the loop:
for (stmt_idx, statement) in program.statements.iter().enumerate() {
    match statement {
        Statement::VerbCall(verb_call) => {
            let validated = self
                .validate_verb_call_with_resolution(
                    verb_call,
                    &request.source,
                    &request.context,
                    &mut symbols,
                    &mut diagnostics,
                    stmt_idx,
                    &mut resolved_keys,
                    &ref_cache,  // ADD THIS
                )
                .await;
            // ...
        }
        // ...
    }
}
```

### Step 4: Use cache in `validate_argument_value`

**Location**: `validate_argument_value()` around line 760

Replace the current resolution logic:

```rust
// CURRENT (line 758-795):
Literal::String(s) => {
    let key_with_colon = format!(":{}", key);
    if let Some(ref_type) = arg_to_ref_type(verb, &key_with_colon) {
        // Validate against DB
        match self.resolver.resolve(ref_type, s).await {
            // ... handle results
        }
    }
}

// REPLACE WITH:
Literal::String(s) => {
    let key_with_colon = format!(":{}", key);
    if let Some(ref_type) = arg_to_ref_type(verb, &key_with_colon) {
        // Check batch cache first
        if let Some(cached_result) = ref_cache.get(&(ref_type, s.clone())) {
            return match cached_result {
                ResolveResult::Found { id, display } => Some(ResolvedArg::Ref {
                    ref_type,
                    id: *id,
                    display: display.clone(),
                }),
                ResolveResult::FoundByCode { code: _, uuid, display } => Some(ResolvedArg::Ref {
                    ref_type,
                    id: uuid.unwrap_or_default(),
                    display: display.clone(),
                }),
                ResolveResult::NotFound { suggestions } => {
                    let diag = self.resolver.diagnostic_for_failure(
                        ref_type,
                        s,
                        src_span,
                        cached_result,
                    );
                    diagnostics.error(diag.code, diag.span, &diag.message);
                    None
                }
            };
        }
        
        // Fall back to individual lookup (cache miss - shouldn't happen normally)
        tracing::warn!("Cache miss for {:?}:{} - falling back to individual lookup", ref_type, s);
        match self.resolver.resolve(ref_type, s).await {
            // ... existing handling
        }
    }
}
```

### Step 5: Also handle EntityRef nodes

Similar change needed for `AstNode::EntityRef` branch (~line 870):

```rust
AstNode::EntityRef { entity_type, value, resolved_key, span: entity_span, .. } => {
    let src_span = span_to_source_span(entity_span, source);
    if let Some(pk) = resolved_key {
        // Already resolved - existing logic
    } else {
        // Needs resolution - check cache first
        let key_with_colon = format!(":{}", key);
        if let Some(ref_type) = arg_to_ref_type(verb, &key_with_colon) {
            // Check batch cache first
            if let Some(cached_result) = ref_cache.get(&(ref_type, value.clone())) {
                return match cached_result {
                    ResolveResult::Found { id, display } => Some(ResolvedArg::Ref {
                        ref_type,
                        id: *id,
                        display: display.clone(),
                    }),
                    // ... same pattern as above
                };
            }
            
            // Fall back to individual lookup
            match self.resolver.resolve(ref_type, value).await {
                // ... existing handling
            }
        }
    }
}
```

---

## Testing

### Unit Test

Add to `semantic_validator.rs` tests:

```rust
#[tokio::test]
async fn test_batch_resolution_reduces_calls() {
    // This test requires a mock gateway that counts calls
    // For now, verify behavior via tracing output
    
    let source = r#"
        (cbu.create :name "Test Fund" :jurisdiction "GBR" :as @fund)
        (entity.create-proper-person :first-name "John" :last-name "Smith" :nationality "GBR" :as @person)
        (cbu.assign-role :cbu-id @fund :entity-id @person :role "DIRECTOR")
    "#;
    
    // This should produce:
    // - Batch resolve call for JURISDICTION type with ["GBR"] (1 call, 2 refs)
    // - Batch resolve call for ROLE type with ["DIRECTOR"] (1 call)
    // Total: 2 gRPC calls instead of 3
}
```

### Integration Test

Run the existing validation tests and verify:
1. All tests still pass
2. Tracing shows "Batch resolved X refs across Y types"
3. Performance improvement is measurable

---

## Performance Verification

Add timing instrumentation:

```rust
// In validate(), around the batch resolve call:
let batch_start = std::time::Instant::now();
let ref_cache = self.batch_resolve_all_refs(&program).await;
let batch_elapsed = batch_start.elapsed();

tracing::info!(
    refs = ref_cache.len(),
    types = ref_cache.keys().map(|(rt, _)| rt).collect::<HashSet<_>>().len(),
    elapsed_ms = batch_elapsed.as_millis(),
    "Batch resolution complete"
);
```

**Expected results**:
- Before: 30 refs → ~150ms (30 × 5ms)
- After: 30 refs → ~25ms (5 types × 5ms)
- **~6x speedup**

---

## Files to Modify

| File | Changes |
|------|---------|
| `rust/src/dsl_v2/semantic_validator.rs` | Wire batch_resolve_all_refs into validate(), update method signatures, use cache in validate_argument_value |

---

## Checklist

- [ ] Add `batch_resolve_all_refs()` call in `validate()` after parsing
- [ ] Update `validate_verb_call` signature to accept `ref_cache`
- [ ] Update `validate_verb_call_with_resolution` signature to accept `ref_cache`
- [ ] Update `validate_argument_value` signature to accept `ref_cache`
- [ ] Update all call sites to pass `ref_cache`
- [ ] Add cache lookup in `Literal::String` branch of `validate_argument_value`
- [ ] Add cache lookup in `AstNode::EntityRef` branch of `validate_argument_value`
- [ ] Add performance logging
- [ ] Run existing tests - all should pass
- [ ] Verify tracing shows batch resolution working

---

## Notes

- The batch resolution happens ONCE per `validate()` call, before any AST walking
- Each RefType gets ONE gRPC call regardless of how many values
- Cache misses fall back to individual resolution (shouldn't happen in normal use)
- The existing `batch_resolve_all_refs()` implementation is correct - it just needs to be called
