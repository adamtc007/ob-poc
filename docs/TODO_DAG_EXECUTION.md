# TODO: DAG Execution Layer + Batch Resolution

**Generated by**: Opus 4.5 Architecture Review  
**Date**: 2025-12-14  
**Prerequisite**: Complete TODO_ARCHITECTURE_FIXES.md first  
**Goal**: Deterministic execution order, cycle detection, 10x faster validation

---

## Overview

This TODO implements the Terraform-style execution model:

```
Source → Parse → AST → Enrich → Compile → Ops → DAG → Toposort → Execute
                                   ↑            ↑
                              NEW: Op enum   NEW: Batch resolve
```

**Key wins:**
1. **Correctness** - Execute in dependency order regardless of source order
2. **Cycle detection** - Fail at compile time with clear error
3. **Dry-run** - Show "what would happen" without executing
4. **Performance** - Batch DB lookups (30 calls → 5 calls)

---

## Phase 1: Batch EntityRef Resolution (Quick Win)

### 1.1 The Problem

Current code in `semantic_validator.rs` does sequential lookups:

```rust
for arg in &verb_call.arguments {
    // Each arg = 1 gRPC call
    match self.resolver.resolve(ref_type, s).await { ... }
}
```

30 EntityRefs = 30 gRPC calls = ~150ms at 5ms/call

### 1.2 The Fix

The proto already supports batching - `SearchRequest.values` is a `Vec<String>`.

**File**: `rust/src/dsl_v2/gateway_resolver.rs`

Add batch resolve method:

```rust
impl GatewayRefResolver {
    /// Batch resolve multiple values of the same type in one gRPC call
    pub async fn batch_resolve(
        &mut self,
        ref_type: RefType,
        values: &[String],
    ) -> Result<HashMap<String, ResolveResult>, String> {
        if values.is_empty() {
            return Ok(HashMap::new());
        }

        let nickname = ref_type_to_nickname(ref_type);

        let request = SearchRequest {
            nickname: nickname.to_string(),
            values: values.to_vec(),
            search_key: None,
            mode: SearchMode::Exact as i32,
            limit: None,  // Return all matches
        };

        let response = self
            .client
            .search(request)
            .await
            .map_err(|e| format!("EntityGateway batch search failed: {}", e))?;

        // Build result map: input value → ResolveResult
        let mut results = HashMap::new();
        let matches = response.into_inner().matches;

        // Index matches by their search value for quick lookup
        let match_index: HashMap<String, _> = matches
            .into_iter()
            .map(|m| (m.search_value.to_uppercase(), m))
            .collect();

        for value in values {
            let value_upper = value.to_uppercase();
            if let Some(m) = match_index.get(&value_upper) {
                if let Ok(uuid) = Uuid::parse_str(&m.token) {
                    results.insert(
                        value.clone(),
                        ResolveResult::Found {
                            id: uuid,
                            display: m.display.clone(),
                        },
                    );
                } else {
                    results.insert(
                        value.clone(),
                        ResolveResult::FoundByCode {
                            code: m.token.clone(),
                            uuid: None,
                            display: m.display.clone(),
                        },
                    );
                }
            } else {
                results.insert(
                    value.clone(),
                    ResolveResult::NotFound { suggestions: vec![] },
                );
            }
        }

        Ok(results)
    }
}
```

### 1.3 Collect and Batch in Validator

**File**: `rust/src/dsl_v2/semantic_validator.rs`

Add pre-resolution pass:

```rust
impl SemanticValidator {
    /// Collect all EntityRefs from AST, batch resolve by type
    async fn batch_resolve_all_refs(
        &mut self,
        program: &Program,
    ) -> HashMap<(RefType, String), ResolveResult> {
        // Pass 1: Collect refs by type
        let mut refs_by_type: HashMap<RefType, HashSet<String>> = HashMap::new();

        for stmt in &program.statements {
            if let Statement::VerbCall(vc) = stmt {
                let full_verb = format!("{}.{}", vc.domain, vc.verb);
                for arg in &vc.arguments {
                    let key_with_colon = format!(":{}", arg.key);
                    if let Some(ref_type) = arg_to_ref_type(&full_verb, &key_with_colon) {
                        // Extract string value from various node types
                        if let Some(value) = extract_string_value(&arg.value) {
                            refs_by_type
                                .entry(ref_type)
                                .or_default()
                                .insert(value);
                        }
                    }
                }
            }
        }

        // Pass 2: Batch resolve each type
        let mut all_results = HashMap::new();

        let gateway = self.resolver.as_gateway_resolver()
            .expect("batch resolve requires gateway resolver");

        for (ref_type, values) in refs_by_type {
            let values_vec: Vec<String> = values.into_iter().collect();
            
            match gateway.batch_resolve(ref_type, &values_vec).await {
                Ok(results) => {
                    for (value, result) in results {
                        all_results.insert((ref_type, value), result);
                    }
                }
                Err(e) => {
                    tracing::warn!("Batch resolve failed for {:?}: {}", ref_type, e);
                    // Fall back to individual resolution during AST walk
                }
            }
        }

        all_results
    }
}

/// Extract string value from AstNode for batch collection
fn extract_string_value(node: &AstNode) -> Option<String> {
    match node {
        AstNode::Literal(Literal::String(s)) => Some(s.clone()),
        AstNode::EntityRef { value, .. } => Some(value.clone()),
        _ => None,
    }
}
```

### 1.4 Use Cached Results During AST Walk

Modify `validate()` to use pre-resolved cache:

```rust
pub async fn validate(&mut self, request: &ValidationRequest) -> ValidationResult {
    // ... parse ...

    // NEW: Batch resolve all refs upfront
    let resolved_cache = self.batch_resolve_all_refs(&program).await;

    // ... walk AST ...
    // In validate_argument_value, check cache first:
    if let Some(cached) = resolved_cache.get(&(ref_type, value.clone())) {
        return match cached {
            ResolveResult::Found { id, display } => Some(ResolvedArg::Ref { ... }),
            // ...
        };
    }
    // Fall back to individual lookup only if not in cache
}
```

### 1.5 Expected Performance

| Metric | Before | After |
|--------|-------:|------:|
| gRPC calls (30 refs, 5 types) | 30 | 5 |
| Latency at 5ms/call | 150ms | 25ms |
| Speedup | - | **6x** |

---

## Phase 2: Op Enum Definition

### 2.1 Core Op Types

**File**: `rust/src/dsl_v2/ops.rs` (NEW)

```rust
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

/// Unique identifier for an entity in the execution plan
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct EntityKey {
    pub entity_type: String,  // "cbu", "proper_person", "limited_company"
    pub key: String,          // Natural key or symbol name
}

impl EntityKey {
    pub fn new(entity_type: impl Into<String>, key: impl Into<String>) -> Self {
        Self {
            entity_type: entity_type.into(),
            key: key.into(),
        }
    }
    
    pub fn from_symbol(symbol: &str) -> Self {
        Self {
            entity_type: "symbol".to_string(),
            key: symbol.to_string(),
        }
    }
}

/// Document key for trading profiles and other documents
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct DocKey {
    pub doc_type: String,
    pub key: String,
}

/// Primitive operations that verbs compile to
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Op {
    // =========================================================================
    // Entity Operations
    // =========================================================================
    
    /// Create or update an entity
    EnsureEntity {
        entity_type: String,
        key: EntityKey,
        attrs: HashMap<String, serde_json::Value>,
        /// Source statement index for error reporting
        source_stmt: usize,
    },

    // =========================================================================
    // Relationship Operations
    // =========================================================================
    
    /// Set a foreign key on an entity
    SetFK {
        source: EntityKey,
        field: String,
        target: EntityKey,
        source_stmt: usize,
    },

    /// Link role to entity within CBU
    LinkRole {
        cbu: EntityKey,
        entity: EntityKey,
        role: String,
        source_stmt: usize,
    },

    /// Remove role from entity within CBU
    UnlinkRole {
        cbu: EntityKey,
        entity: EntityKey,
        role: String,
        source_stmt: usize,
    },

    /// Add ownership relationship
    AddOwnership {
        owner: EntityKey,
        owned: EntityKey,
        percentage: Decimal,
        ownership_type: String,
        source_stmt: usize,
    },

    /// Register UBO determination
    RegisterUBO {
        cbu: EntityKey,
        subject: EntityKey,
        ubo_person: EntityKey,
        qualifying_reason: String,
        source_stmt: usize,
    },

    // =========================================================================
    // Document Operations
    // =========================================================================

    /// Upload/upsert a document
    UpsertDoc {
        doc_type: String,
        key: DocKey,
        content: serde_json::Value,
        source_stmt: usize,
    },

    /// Attach evidence to CBU
    AttachEvidence {
        cbu: EntityKey,
        evidence_type: String,
        document: Option<DocKey>,
        attestation_ref: Option<String>,
        source_stmt: usize,
    },

    // =========================================================================
    // KYC Operations
    // =========================================================================

    /// Create KYC case
    CreateCase {
        cbu: EntityKey,
        case_type: String,
        source_stmt: usize,
    },

    /// Update case status
    UpdateCaseStatus {
        case: EntityKey,
        status: String,
        source_stmt: usize,
    },

    /// Run screening
    RunScreening {
        entity: EntityKey,
        screening_type: String,  // PEP, SANCTIONS, ADVERSE_MEDIA
        source_stmt: usize,
    },

    // =========================================================================
    // Materialization Operations (Phase 3)
    // =========================================================================

    /// Materialize trading profile to operational tables
    Materialize {
        source: DocKey,
        sections: Vec<String>,  // ["universe", "ssis", "booking_rules", "isda"]
        force: bool,
        source_stmt: usize,
    },

    // =========================================================================
    // Reference Lookups (no-op but declares dependency)
    // =========================================================================

    /// Placeholder for reference data lookup (MIC, currency, etc.)
    /// Doesn't execute anything but declares that this ref must exist
    RequireRef {
        ref_type: String,
        value: String,
        source_stmt: usize,
    },
}

impl Op {
    /// Get the source statement index for error reporting
    pub fn source_stmt(&self) -> usize {
        match self {
            Op::EnsureEntity { source_stmt, .. } => *source_stmt,
            Op::SetFK { source_stmt, .. } => *source_stmt,
            Op::LinkRole { source_stmt, .. } => *source_stmt,
            Op::UnlinkRole { source_stmt, .. } => *source_stmt,
            Op::AddOwnership { source_stmt, .. } => *source_stmt,
            Op::RegisterUBO { source_stmt, .. } => *source_stmt,
            Op::UpsertDoc { source_stmt, .. } => *source_stmt,
            Op::AttachEvidence { source_stmt, .. } => *source_stmt,
            Op::CreateCase { source_stmt, .. } => *source_stmt,
            Op::UpdateCaseStatus { source_stmt, .. } => *source_stmt,
            Op::RunScreening { source_stmt, .. } => *source_stmt,
            Op::Materialize { source_stmt, .. } => *source_stmt,
            Op::RequireRef { source_stmt, .. } => *source_stmt,
        }
    }

    /// Get a human-readable description for plan output
    pub fn describe(&self) -> String {
        match self {
            Op::EnsureEntity { entity_type, key, .. } => {
                format!("Ensure {} '{}'", entity_type, key.key)
            }
            Op::SetFK { source, field, target, .. } => {
                format!("Set {}.{} → {}", source.key, field, target.key)
            }
            Op::LinkRole { cbu, entity, role, .. } => {
                format!("Link {} to {} as {}", entity.key, cbu.key, role)
            }
            Op::AddOwnership { owner, owned, percentage, .. } => {
                format!("{} owns {}% of {}", owner.key, percentage, owned.key)
            }
            Op::Materialize { source, sections, .. } => {
                format!("Materialize {} → {:?}", source.key, sections)
            }
            // ... other variants
            _ => format!("{:?}", self),
        }
    }
}
```

### 2.2 Dependency Rules

```rust
/// Reference to another Op in the plan
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum OpRef {
    EnsureEntity(EntityKey),
    UpsertDoc(DocKey),
    CreateCase(EntityKey),
}

impl Op {
    /// Get dependencies for this operation
    pub fn dependencies(&self) -> Vec<OpRef> {
        match self {
            // Entity ensure has no deps (or lookup deps for FKs)
            Op::EnsureEntity { .. } => vec![],

            // SetFK depends on both source and target existing
            Op::SetFK { source, target, .. } => vec![
                OpRef::EnsureEntity(source.clone()),
                OpRef::EnsureEntity(target.clone()),
            ],

            // LinkRole depends on CBU and entity
            Op::LinkRole { cbu, entity, .. } => vec![
                OpRef::EnsureEntity(cbu.clone()),
                OpRef::EnsureEntity(entity.clone()),
            ],

            // AddOwnership depends on both entities
            Op::AddOwnership { owner, owned, .. } => vec![
                OpRef::EnsureEntity(owner.clone()),
                OpRef::EnsureEntity(owned.clone()),
            ],

            // RegisterUBO depends on CBU, subject, and UBO person
            Op::RegisterUBO { cbu, subject, ubo_person, .. } => vec![
                OpRef::EnsureEntity(cbu.clone()),
                OpRef::EnsureEntity(subject.clone()),
                OpRef::EnsureEntity(ubo_person.clone()),
            ],

            // UpsertDoc has no deps (content is self-contained)
            Op::UpsertDoc { .. } => vec![],

            // AttachEvidence depends on CBU and optionally document
            Op::AttachEvidence { cbu, document, .. } => {
                let mut deps = vec![OpRef::EnsureEntity(cbu.clone())];
                if let Some(doc) = document {
                    deps.push(OpRef::UpsertDoc(doc.clone()));
                }
                deps
            }

            // CreateCase depends on CBU
            Op::CreateCase { cbu, .. } => vec![
                OpRef::EnsureEntity(cbu.clone()),
            ],

            // UpdateCaseStatus depends on case existing
            Op::UpdateCaseStatus { case, .. } => vec![
                OpRef::CreateCase(case.clone()),
            ],

            // RunScreening depends on entity
            Op::RunScreening { entity, .. } => vec![
                OpRef::EnsureEntity(entity.clone()),
            ],

            // Materialize depends on doc and all referenced entities
            Op::Materialize { source, .. } => vec![
                OpRef::UpsertDoc(source.clone()),
                // TODO: Also add deps for entities referenced in the doc
            ],

            // RequireRef has no runtime deps (validated at compile time)
            Op::RequireRef { .. } => vec![],

            _ => vec![],
        }
    }

    /// Get what this op produces (for dependency matching)
    pub fn produces(&self) -> Option<OpRef> {
        match self {
            Op::EnsureEntity { key, .. } => Some(OpRef::EnsureEntity(key.clone())),
            Op::UpsertDoc { key, .. } => Some(OpRef::UpsertDoc(key.clone())),
            Op::CreateCase { cbu, .. } => Some(OpRef::CreateCase(cbu.clone())),
            _ => None,
        }
    }
}
```

---

## Phase 3: Verb → Op Compiler

### 3.1 Compiler Module

**File**: `rust/src/dsl_v2/compiler.rs` (NEW)

```rust
use crate::dsl_v2::ast::{AstNode, Program, Statement, VerbCall};
use crate::dsl_v2::ops::{DocKey, EntityKey, Op};
use std::collections::HashMap;

/// Compilation result
pub struct CompiledProgram {
    pub ops: Vec<Op>,
    /// Symbol table: binding name → EntityKey
    pub symbols: HashMap<String, EntityKey>,
    /// Errors encountered during compilation
    pub errors: Vec<CompileError>,
}

#[derive(Debug)]
pub struct CompileError {
    pub stmt_idx: usize,
    pub message: String,
}

/// Compile AST to Ops
pub fn compile(program: &Program) -> CompiledProgram {
    let mut ops = Vec::new();
    let mut symbols = HashMap::new();
    let mut errors = Vec::new();

    for (stmt_idx, stmt) in program.statements.iter().enumerate() {
        if let Statement::VerbCall(vc) = stmt {
            match compile_verb_call(vc, stmt_idx, &symbols) {
                Ok((new_ops, binding)) => {
                    ops.extend(new_ops);
                    if let Some((name, key)) = binding {
                        symbols.insert(name, key);
                    }
                }
                Err(e) => {
                    errors.push(CompileError {
                        stmt_idx,
                        message: e,
                    });
                }
            }
        }
    }

    CompiledProgram { ops, symbols, errors }
}

/// Compile a single verb call to ops
fn compile_verb_call(
    vc: &VerbCall,
    stmt_idx: usize,
    symbols: &HashMap<String, EntityKey>,
) -> Result<(Vec<Op>, Option<(String, EntityKey)>), String> {
    let full_verb = format!("{}.{}", vc.domain, vc.verb);
    
    match full_verb.as_str() {
        // =====================================================================
        // CBU verbs
        // =====================================================================
        "cbu.ensure" | "cbu.create" => {
            let name = get_string_arg(vc, "name")?;
            let key = EntityKey::new("cbu", &name);
            
            let mut attrs = HashMap::new();
            attrs.insert("name".to_string(), serde_json::json!(name));
            if let Ok(j) = get_string_arg(vc, "jurisdiction") {
                attrs.insert("jurisdiction".to_string(), serde_json::json!(j));
            }
            
            let op = Op::EnsureEntity {
                entity_type: "cbu".to_string(),
                key: key.clone(),
                attrs,
                source_stmt: stmt_idx,
            };
            
            let binding = vc.binding.as_ref().map(|b| (b.clone(), key));
            Ok((vec![op], binding))
        }

        "cbu.assign-role" => {
            let cbu = resolve_entity_arg(vc, "cbu-id", symbols)?;
            let entity = resolve_entity_arg(vc, "entity-id", symbols)?;
            let role = get_string_arg(vc, "role")?;
            
            let op = Op::LinkRole {
                cbu,
                entity,
                role,
                source_stmt: stmt_idx,
            };
            
            Ok((vec![op], None))
        }

        // =====================================================================
        // Entity verbs
        // =====================================================================
        "entity.create-proper-person" | "entity.ensure-proper-person" => {
            let first = get_string_arg(vc, "first-name")?;
            let last = get_string_arg(vc, "last-name")?;
            let name = format!("{} {}", first, last);
            let key = EntityKey::new("proper_person", &name);
            
            let mut attrs = HashMap::new();
            attrs.insert("first_name".to_string(), serde_json::json!(first));
            attrs.insert("last_name".to_string(), serde_json::json!(last));
            
            let op = Op::EnsureEntity {
                entity_type: "proper_person".to_string(),
                key: key.clone(),
                attrs,
                source_stmt: stmt_idx,
            };
            
            let binding = vc.binding.as_ref().map(|b| (b.clone(), key));
            Ok((vec![op], binding))
        }

        "entity.create-limited-company" | "entity.ensure-limited-company" => {
            let name = get_string_arg(vc, "name")?;
            let key = EntityKey::new("limited_company", &name);
            
            let mut attrs = HashMap::new();
            attrs.insert("company_name".to_string(), serde_json::json!(name));
            
            let op = Op::EnsureEntity {
                entity_type: "limited_company".to_string(),
                key: key.clone(),
                attrs,
                source_stmt: stmt_idx,
            };
            
            let binding = vc.binding.as_ref().map(|b| (b.clone(), key));
            Ok((vec![op], binding))
        }

        // =====================================================================
        // UBO verbs
        // =====================================================================
        "ubo.add-ownership" => {
            let owner = resolve_entity_arg(vc, "owner-entity-id", symbols)?;
            let owned = resolve_entity_arg(vc, "owned-entity-id", symbols)?;
            let pct = get_decimal_arg(vc, "percentage")?;
            let ownership_type = get_string_arg(vc, "ownership-type")?;
            
            let op = Op::AddOwnership {
                owner,
                owned,
                percentage: pct,
                ownership_type,
                source_stmt: stmt_idx,
            };
            
            Ok((vec![op], None))
        }

        "ubo.register-ubo" => {
            let cbu = resolve_entity_arg(vc, "cbu-id", symbols)?;
            let subject = resolve_entity_arg(vc, "subject-entity-id", symbols)?;
            let ubo_person = resolve_entity_arg(vc, "ubo-person-id", symbols)?;
            let reason = get_string_arg(vc, "qualifying-reason")?;
            
            let op = Op::RegisterUBO {
                cbu,
                subject,
                ubo_person,
                qualifying_reason: reason,
                source_stmt: stmt_idx,
            };
            
            Ok((vec![op], None))
        }

        // =====================================================================
        // Trading Profile verbs
        // =====================================================================
        "trading-profile.import" => {
            let cbu = resolve_entity_arg(vc, "cbu-id", symbols)?;
            // Content comes from file or inline
            let key = DocKey {
                doc_type: "trading_profile".to_string(),
                key: cbu.key.clone(),
            };
            
            let op = Op::UpsertDoc {
                doc_type: "trading_profile".to_string(),
                key: key.clone(),
                content: serde_json::json!({}),  // Actual content loaded at execution
                source_stmt: stmt_idx,
            };
            
            // Binding uses the doc key
            let binding = vc.binding.as_ref().map(|b| {
                (b.clone(), EntityKey::new("trading_profile", &key.key))
            });
            
            Ok((vec![op], binding))
        }

        "trading-profile.materialize" => {
            let profile_key = resolve_entity_arg(vc, "profile-id", symbols)?;
            let sections = get_string_list_arg(vc, "sections")
                .unwrap_or_else(|_| vec!["all".to_string()]);
            let force = get_bool_arg(vc, "force").unwrap_or(false);
            
            let op = Op::Materialize {
                source: DocKey {
                    doc_type: "trading_profile".to_string(),
                    key: profile_key.key,
                },
                sections,
                force,
                source_stmt: stmt_idx,
            };
            
            Ok((vec![op], None))
        }

        // =====================================================================
        // KYC verbs
        // =====================================================================
        "kyc-case.create" => {
            let cbu = resolve_entity_arg(vc, "cbu-id", symbols)?;
            let case_type = get_string_arg(vc, "case-type")
                .unwrap_or_else(|_| "NEW_CLIENT".to_string());
            
            let op = Op::CreateCase {
                cbu: cbu.clone(),
                case_type,
                source_stmt: stmt_idx,
            };
            
            let binding = vc.binding.as_ref().map(|b| (b.clone(), cbu));
            Ok((vec![op], binding))
        }

        // =====================================================================
        // Screening verbs
        // =====================================================================
        "screening.pep" | "screening.sanctions" | "screening.adverse-media" => {
            let entity = resolve_entity_arg(vc, "entity-id", symbols)?;
            let screening_type = vc.verb.to_uppercase().replace("-", "_");
            
            let op = Op::RunScreening {
                entity,
                screening_type,
                source_stmt: stmt_idx,
            };
            
            Ok((vec![op], None))
        }

        // =====================================================================
        // Unknown verb - pass through
        // =====================================================================
        _ => {
            Err(format!("Unknown verb for compilation: {}", full_verb))
        }
    }
}

// =============================================================================
// Helper functions
// =============================================================================

fn get_string_arg(vc: &VerbCall, key: &str) -> Result<String, String> {
    vc.get_value(key)
        .and_then(|v| v.as_string())
        .map(|s| s.to_string())
        .ok_or_else(|| format!("missing required arg '{}'", key))
}

fn get_decimal_arg(vc: &VerbCall, key: &str) -> Result<rust_decimal::Decimal, String> {
    vc.get_value(key)
        .and_then(|v| v.as_decimal())
        .ok_or_else(|| format!("missing required decimal arg '{}'", key))
}

fn get_bool_arg(vc: &VerbCall, key: &str) -> Result<bool, String> {
    vc.get_value(key)
        .and_then(|v| v.as_boolean())
        .ok_or_else(|| format!("missing required bool arg '{}'", key))
}

fn get_string_list_arg(vc: &VerbCall, key: &str) -> Result<Vec<String>, String> {
    vc.get_value(key)
        .and_then(|v| v.as_list())
        .map(|items| {
            items.iter()
                .filter_map(|i| i.as_string().map(|s| s.to_string()))
                .collect()
        })
        .ok_or_else(|| format!("missing required list arg '{}'", key))
}

fn resolve_entity_arg(
    vc: &VerbCall,
    key: &str,
    symbols: &HashMap<String, EntityKey>,
) -> Result<EntityKey, String> {
    let node = vc.get_value(key)
        .ok_or_else(|| format!("missing required arg '{}'", key))?;
    
    match node {
        // Symbol reference → look up in symbol table
        AstNode::SymbolRef { name, .. } => {
            symbols.get(name)
                .cloned()
                .ok_or_else(|| format!("undefined symbol '@{}'", name))
        }
        // String literal → create entity key from value
        AstNode::Literal(crate::dsl_v2::ast::Literal::String(s)) => {
            Ok(EntityKey::new("entity", s))
        }
        // EntityRef → use resolved key or value
        AstNode::EntityRef { entity_type, value, resolved_key, .. } => {
            let key_value = resolved_key.as_ref().unwrap_or(value);
            Ok(EntityKey::new(entity_type, key_value))
        }
        _ => Err(format!("invalid value type for '{}'", key)),
    }
}
```

---

## Phase 4: DAG Builder + Toposort

### 4.1 DAG Module

**File**: `rust/src/dsl_v2/dag.rs` (NEW)

```rust
use crate::dsl_v2::ops::{Op, OpRef};
use std::collections::{HashMap, HashSet, VecDeque};

/// Execution plan with topologically sorted ops
pub struct ExecutionPlan {
    /// Ops in execution order
    pub ops: Vec<Op>,
    /// Execution phases (for optional phased execution)
    pub phases: Vec<ExecutionPhase>,
}

#[derive(Debug, Clone)]
pub struct ExecutionPhase {
    pub name: String,
    pub op_indices: Vec<usize>,
}

/// Cycle detection result
#[derive(Debug)]
pub struct CycleError {
    /// Ops involved in the cycle
    pub cycle: Vec<usize>,
    /// Human-readable explanation
    pub explanation: String,
}

/// Build execution plan from ops
pub fn build_execution_plan(ops: Vec<Op>) -> Result<ExecutionPlan, CycleError> {
    // Build adjacency list: op index → indices it depends on
    let mut deps: HashMap<usize, Vec<usize>> = HashMap::new();
    let mut produces: HashMap<OpRef, usize> = HashMap::new();

    // First pass: record what each op produces
    for (idx, op) in ops.iter().enumerate() {
        if let Some(prod) = op.produces() {
            produces.insert(prod, idx);
        }
    }

    // Second pass: build dependency edges
    for (idx, op) in ops.iter().enumerate() {
        let mut op_deps = Vec::new();
        for dep_ref in op.dependencies() {
            if let Some(&dep_idx) = produces.get(&dep_ref) {
                op_deps.push(dep_idx);
            }
            // If dependency not found, it might be pre-existing in DB
            // (this is OK - we don't error, just no edge)
        }
        deps.insert(idx, op_deps);
    }

    // Kahn's algorithm for topological sort with cycle detection
    let n = ops.len();
    let mut in_degree = vec![0usize; n];
    let mut adj: Vec<Vec<usize>> = vec![Vec::new(); n];

    for (idx, dep_list) in &deps {
        for &dep_idx in dep_list {
            adj[dep_idx].push(*idx);
            in_degree[*idx] += 1;
        }
    }

    let mut queue: VecDeque<usize> = VecDeque::new();
    for (idx, &degree) in in_degree.iter().enumerate() {
        if degree == 0 {
            queue.push_back(idx);
        }
    }

    let mut sorted = Vec::new();
    while let Some(idx) = queue.pop_front() {
        sorted.push(idx);
        for &next in &adj[idx] {
            in_degree[next] -= 1;
            if in_degree[next] == 0 {
                queue.push_back(next);
            }
        }
    }

    // Check for cycle
    if sorted.len() != n {
        // Find cycle for error message
        let remaining: Vec<usize> = (0..n)
            .filter(|i| !sorted.contains(i))
            .collect();
        
        return Err(CycleError {
            cycle: remaining.clone(),
            explanation: format!(
                "Circular dependency detected involving {} operations. \
                 Check for entities that reference each other.",
                remaining.len()
            ),
        });
    }

    // Reorder ops by sorted indices
    let sorted_ops: Vec<Op> = sorted.iter().map(|&i| ops[i].clone()).collect();

    // Optional: Group into phases
    let phases = group_into_phases(&sorted_ops);

    Ok(ExecutionPlan {
        ops: sorted_ops,
        phases,
    })
}

/// Group ops into execution phases
fn group_into_phases(ops: &[Op]) -> Vec<ExecutionPhase> {
    let mut phases = vec![
        ExecutionPhase { name: "Entities".to_string(), op_indices: vec![] },
        ExecutionPhase { name: "Relationships".to_string(), op_indices: vec![] },
        ExecutionPhase { name: "Documents".to_string(), op_indices: vec![] },
        ExecutionPhase { name: "Materialization".to_string(), op_indices: vec![] },
    ];

    for (idx, op) in ops.iter().enumerate() {
        match op {
            Op::EnsureEntity { .. } => phases[0].op_indices.push(idx),
            Op::SetFK { .. } | Op::LinkRole { .. } | Op::AddOwnership { .. } | Op::RegisterUBO { .. } => {
                phases[1].op_indices.push(idx)
            }
            Op::UpsertDoc { .. } | Op::AttachEvidence { .. } => phases[2].op_indices.push(idx),
            Op::Materialize { .. } => phases[3].op_indices.push(idx),
            _ => phases[1].op_indices.push(idx),  // Default to relationships phase
        }
    }

    // Remove empty phases
    phases.into_iter().filter(|p| !p.op_indices.is_empty()).collect()
}

/// Generate plan description for dry-run output
pub fn describe_plan(plan: &ExecutionPlan) -> String {
    let mut output = String::new();
    output.push_str("Execution Plan:\n");
    output.push_str("===============\n\n");

    for phase in &plan.phases {
        output.push_str(&format!("Phase: {}\n", phase.name));
        output.push_str(&"-".repeat(40));
        output.push('\n');
        
        for &idx in &phase.op_indices {
            output.push_str(&format!("  {}. {}\n", idx + 1, plan.ops[idx].describe()));
        }
        output.push('\n');
    }

    output
}
```

---

## Phase 5: Integration + Executor Update

### 5.1 Update Generic Executor

**File**: `rust/src/dsl_v2/generic_executor.rs`

Add plan-based execution mode:

```rust
use crate::dsl_v2::compiler::compile;
use crate::dsl_v2::dag::{build_execution_plan, describe_plan, ExecutionPlan};
use crate::dsl_v2::ops::Op;

impl GenericExecutor {
    /// Execute with DAG-based ordering
    pub async fn execute_with_dag(
        &self,
        program: &Program,
        dry_run: bool,
    ) -> Result<ExecutionResult, ExecutionError> {
        // Step 1: Compile to ops
        let compiled = compile(program);
        if !compiled.errors.is_empty() {
            return Err(ExecutionError::CompileErrors(compiled.errors));
        }

        // Step 2: Build execution plan (toposort)
        let plan = build_execution_plan(compiled.ops)
            .map_err(|e| ExecutionError::CycleDetected(e))?;

        // Step 3: Dry run - just show plan
        if dry_run {
            return Ok(ExecutionResult::Plan(describe_plan(&plan)));
        }

        // Step 4: Execute ops in order
        let mut results = Vec::new();
        for op in &plan.ops {
            let result = self.execute_op(op).await?;
            results.push(result);
        }

        Ok(ExecutionResult::Executed(results))
    }

    /// Execute a single Op
    async fn execute_op(&self, op: &Op) -> Result<OpResult, ExecutionError> {
        match op {
            Op::EnsureEntity { entity_type, key, attrs, .. } => {
                // Delegate to existing entity creation logic
                // ...
            }
            Op::LinkRole { cbu, entity, role, .. } => {
                // Delegate to role assignment
                // ...
            }
            // ... other op types
            _ => {
                tracing::warn!("Unhandled op type: {:?}", op);
                Ok(OpResult::Skipped)
            }
        }
    }
}
```

---

## Phase 6: Testing

### 6.1 Test Fixtures

**File**: `rust/src/dsl_v2/tests/dag_tests.rs`

```rust
#[tokio::test]
async fn test_reordering() {
    // Source in wrong order
    let source = r#"
        (cbu.assign-role :cbu-id @fund :entity-id @john :role "DIRECTOR")
        (cbu.ensure :name "Apex Fund" :jurisdiction "LU" :as @fund)
        (entity.create-proper-person :first-name "John" :last-name "Smith" :as @john)
    "#;

    let program = parse_program(source).unwrap();
    let compiled = compile(&program);
    let plan = build_execution_plan(compiled.ops).unwrap();

    // Verify order: entities first, then role link
    assert!(matches!(plan.ops[0], Op::EnsureEntity { .. }));
    assert!(matches!(plan.ops[1], Op::EnsureEntity { .. }));
    assert!(matches!(plan.ops[2], Op::LinkRole { .. }));
}

#[tokio::test]
async fn test_cycle_detection() {
    // This should fail: A owns B, B owns A
    let source = r#"
        (ubo.add-ownership :owner-entity-id @a :owned-entity-id @b :percentage 50 :ownership-type "DIRECT")
        (ubo.add-ownership :owner-entity-id @b :owned-entity-id @a :percentage 50 :ownership-type "DIRECT")
        (entity.create-limited-company :name "Company A" :as @a)
        (entity.create-limited-company :name "Company B" :as @b)
    "#;

    let program = parse_program(source).unwrap();
    let compiled = compile(&program);
    
    // This should detect cycle (ownership refs are circular)
    // Note: Actually this might not cycle because add-ownership doesn't produce...
    // Real cycle test would need SetFK on entities referencing each other
}

#[tokio::test]
async fn test_batch_resolution() {
    // 10 entity refs should result in ≤5 gRPC calls (one per RefType)
    // ... test with mock gateway
}
```

---

## Verification Checklist

### Phase 1 (Batch Resolution)
- [ ] `batch_resolve` method added to `GatewayRefResolver`
- [ ] `batch_resolve_all_refs` added to `SemanticValidator`
- [ ] Cache is used during AST walk
- [ ] Performance test shows <10 gRPC calls for 50 refs

### Phase 2 (Op Enum)
- [ ] `ops.rs` created with all Op variants
- [ ] Dependencies and produces implemented for each Op
- [ ] Tests for dependency rules

### Phase 3 (Compiler)
- [ ] `compiler.rs` handles all main verbs
- [ ] Symbol table correctly tracks bindings
- [ ] Unknown verbs produce clear errors

### Phase 4 (DAG)
- [ ] `dag.rs` implements Kahn's algorithm
- [ ] Cycle detection produces clear error
- [ ] Phases correctly group ops

### Phase 5 (Integration)
- [ ] `execute_with_dag` method works
- [ ] Dry-run produces readable plan
- [ ] Existing tests still pass

---

## Performance Targets

| Metric | Current | Target |
|--------|--------:|-------:|
| EntityRef resolution (30 refs) | ~150ms | <30ms |
| Full validation + compile | ~200ms | <50ms |
| gRPC calls per validation | ~30 | <8 |

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `rust/src/dsl_v2/ops.rs` | CREATE |
| `rust/src/dsl_v2/compiler.rs` | CREATE |
| `rust/src/dsl_v2/dag.rs` | CREATE |
| `rust/src/dsl_v2/gateway_resolver.rs` | MODIFY (add batch_resolve) |
| `rust/src/dsl_v2/semantic_validator.rs` | MODIFY (add batch pre-resolution) |
| `rust/src/dsl_v2/generic_executor.rs` | MODIFY (add execute_with_dag) |
| `rust/src/dsl_v2/mod.rs` | MODIFY (export new modules) |
