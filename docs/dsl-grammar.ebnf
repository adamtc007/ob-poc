(* ============================================================================
   OB-POC DSL - Extended Backus-Naur Form (EBNF) Grammar
   ============================================================================

   This grammar defines the S-expression based DSL for KYC/AML onboarding,
   custody configuration, UBO discovery, and entity management.

   Design Principles:
   - S-expression syntax for homoiconicity
   - Clojure-style keyword arguments (:key value)
   - Symbol references (@name) for cross-statement binding
   - YAML-driven verb definitions (no hardcoded verbs in parser)

   Reference implementation: rust/crates/dsl-core/src/parser.rs
   Verb definitions: rust/config/verbs/*.yaml

   Last updated: 2025-01-09 (aligned with NOM parser implementation)
   ============================================================================ *)


(* ============================================================================
   TOP-LEVEL STRUCTURE
   ============================================================================ *)

program = { statement } ;

statement = comment | verb-call ;


(* ============================================================================
   COMMENTS
   ============================================================================ *)

comment = ";;" , { character - newline } , [ newline ] ;


(* ============================================================================
   VERB CALLS
   ============================================================================

   The core construct of the DSL. A verb call invokes a domain-specific
   operation with keyword arguments.

   Examples:
     (cbu.ensure :name "Apex Fund" :jurisdiction "LU" :as @fund)
     (entity.create-proper-person :first-name "John" :last-name "Smith")
     (cbu.assign-role :cbu-id @fund :entity-id @person :role "DIRECTOR")
   ============================================================================ *)

verb-call = "(" , domain-verb , { argument } , [ as-binding ] , ")" ;

domain-verb = domain , "." , verb-name ;

domain = kebab-identifier ;

verb-name = kebab-identifier ;

(* Arguments are keyword-value pairs *)
argument = keyword , whitespace+ , value ;

(* Keyword is a colon followed by an identifier *)
keyword = ":" , kebab-identifier ;

(* Optional binding directive - captures result for later reference *)
as-binding = ":as" , whitespace+ , symbol-ref ;


(* ============================================================================
   VALUES
   ============================================================================

   Values can be literals, symbol references, lists, maps, or nested verb calls.

   Types:
   - String literals: "hello world"
   - Integer literals: 42, -17
   - Decimal literals: 3.14, -0.5
   - Boolean literals: true, false
   - Null literal: nil
   - UUID literals: "550e8400-e29b-41d4-a716-446655440000" (auto-detected)
   - Symbol references: @fund, @person, @my-binding
   - Lists: ["a" "b" "c"], [1 2 3]
   - Maps: {:key "value" :count 42}
   - Nested verb calls: (inner.verb :arg value)
   ============================================================================ *)

value = boolean-literal
      | null-literal
      | symbol-ref
      | string-literal
      | number-literal
      | nested-verb-call
      | list-literal
      | map-literal ;

(* Boolean literals *)
boolean-literal = "true" | "false" ;

(* Null literal *)
null-literal = "nil" ;

(* Symbol reference - refers to a previously bound result *)
symbol-ref = "@" , identifier ;

(* String literal with escape sequences *)
string-literal = '"' , { string-char | escape-sequence } , '"' ;

string-char = ? any character except '"' and '\' ? ;

escape-sequence = "\" , ( "n" | "r" | "t" | "\" | '"' ) ;

(* Number literals - integers and decimals *)
number-literal = [ "-" ] , digit+ , [ "." , digit+ ] ;

(* Nested verb call - verb calls can appear as values *)
nested-verb-call = verb-call ;

(* List literal - ordered collection *)
list-literal = "[" , [ value , { [ "," ] , value } ] , "]" ;

(* Map literal - key-value collection with keyword keys *)
map-literal = "{" , { keyword , whitespace+ , value } , "}" ;


(* ============================================================================
   IDENTIFIERS
   ============================================================================

   Identifiers support kebab-case naming convention (hyphens between words).

   Valid examples:
   - cbu, entity, kyc-case
   - create-proper-person, assign-role
   - my-binding, fund-a
   ============================================================================ *)

(* Kebab-case identifier - allows hyphens between words *)
kebab-identifier = ( letter | "_" ) , { letter | digit | "_" | "-" } ;

(* Standard identifier - no hyphens, used for symbol names *)
identifier = ( letter | "_" ) , { letter | digit | "_" | "-" } ;


(* ============================================================================
   PRIMITIVES
   ============================================================================ *)

letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j"
       | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t"
       | "u" | "v" | "w" | "x" | "y" | "z"
       | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
       | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
       | "U" | "V" | "W" | "X" | "Y" | "Z" ;

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

newline = ? line feed character (U+000A) ? ;

whitespace = ? space, tab, newline, or carriage return ? ;

character = ? any Unicode character ? ;


(* ============================================================================
   EXAMPLES
   ============================================================================

   Basic entity creation:

     (entity.create-proper-person
       :first-name "John"
       :last-name "Smith"
       :date-of-birth "1980-01-15"
       :nationality "US"
       :as @john)

   CBU with role assignment:

     (cbu.ensure :name "Apex Fund" :jurisdiction "LU" :client-type "FUND" :as @fund)
     (cbu.assign-role :cbu-id @fund :entity-id @john :role "DIRECTOR")

   Nested verb call in list:

     (kyc-case.create
       :cbu-id @fund
       :case-type "NEW_CLIENT"
       :entities [@john @company]
       :as @case)

   Map value with nested data:

     (test.verb :config {:name "Test" :value 42 :enabled true})

   ============================================================================ *)


(* ============================================================================
   NOTES ON IMPLEMENTATION
   ============================================================================

   1. VERB REGISTRATION
      Verbs are defined in YAML files under rust/config/verbs/*.yaml
      The parser does NOT validate verb names - that happens in the
      semantic validation phase using the RuntimeVerbRegistry.

   2. ENTITY RESOLUTION
      String arguments that reference entities are enriched post-parse
      based on YAML verb definitions. The enrichment pass converts
      Literal::String to EntityRef where lookup config exists.

   3. UUID DETECTION
      Strings that match UUID format are automatically parsed as
      Literal::Uuid rather than Literal::String.

   4. WHITESPACE
      Whitespace between tokens is flexible - spaces, tabs, and newlines
      are all treated equivalently. Multi-line statements are supported.

   5. ERROR RECOVERY
      The parser uses nom's cut combinator for better error messages.
      Invalid syntax produces descriptive error messages with context.

   ============================================================================ *)
