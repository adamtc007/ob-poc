// Web server for test harness UI.
package main

import (
	"bytes"
	"context"
	"embed"
	"encoding/json"
	"flag"
	"html/template"
	"io"
	"log"
	"net/http"

	"github.com/adamtc007/ob-poc/go/internal/harness"
	"github.com/adamtc007/ob-poc/go/internal/rustclient"
)

//go:embed templates/*.html
var templates embed.FS

//go:embed static/*
var static embed.FS

var (
	rustURL  string
	agentURL string
	client   *rustclient.Client
	tmpl     *template.Template
)

func main() {
	addr := flag.String("addr", ":8181", "Listen address")
	flag.StringVar(&rustURL, "rust-url", "http://localhost:3001", "Rust DSL API URL")
	flag.StringVar(&agentURL, "agent-url", "http://localhost:3000", "Rust Agent API URL")
	flag.Parse()

	if rustURL != "" {
		client = rustclient.NewClient(rustURL)
	}

	var err error
	tmpl, err = template.ParseFS(templates, "templates/*.html")
	if err != nil {
		log.Fatalf("parsing templates: %v", err)
	}

	http.HandleFunc("/", handleIndex)
	http.HandleFunc("/health", handleHealth)
	http.HandleFunc("/api/run", handleRunSuite)
	http.HandleFunc("/api/validate", handleValidate)
	http.HandleFunc("/api/config", handleConfig)
	// Agent proxy endpoints
	http.HandleFunc("/api/agent/session", handleAgentSession)
	http.HandleFunc("/api/agent/chat", handleAgentChat)
	http.HandleFunc("/api/agent/generate", handleAgentGenerate)
	http.HandleFunc("/api/agent/execute", handleAgentExecute)
	// KYC case query endpoint (proxies to dsl_api)
	http.HandleFunc("/api/kyc/case/", handleKycCase)
	// Direct DSL execution (no session needed)
	http.HandleFunc("/api/dsl/execute", handleDirectExecute)
	http.HandleFunc("/api/dsl/analyze-errors", handleAnalyzeErrors)
	http.Handle("/static/", http.FileServer(http.FS(static)))

	log.Printf("Starting server on %s", *addr)
	log.Printf("  DSL API: %s", rustURL)
	log.Printf("  Agent API: %s", agentURL)
	log.Fatal(http.ListenAndServe(*addr, nil))
}

func handleIndex(w http.ResponseWriter, r *http.Request) {
	var health *rustclient.HealthResponse
	var verbs *rustclient.VerbsResponse

	if client != nil {
		ctx := r.Context()
		health, _ = client.Health(ctx)
		verbs, _ = client.ListVerbs(ctx)
	}

	// Check agent health for connected status
	agentHealthy := false
	if resp, err := http.Get(agentURL + "/api/agent/health"); err == nil {
		resp.Body.Close()
		agentHealthy = resp.StatusCode == 200
	}

	data := map[string]any{
		"Health":    health,
		"Verbs":     verbs,
		"RustURL":   rustURL,
		"AgentURL":  agentURL,
		"Connected": agentHealthy,
	}
	if err := tmpl.ExecuteTemplate(w, "index.html", data); err != nil {
		http.Error(w, err.Error(), 500)
	}
}

func handleConfig(w http.ResponseWriter, r *http.Request) {
	if r.Method == "POST" {
		var req struct {
			RustURL  string `json:"rust_url"`
			AgentURL string `json:"agent_url"`
		}
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			jsonError(w, err.Error(), 400)
			return
		}
		if req.RustURL != "" {
			rustURL = req.RustURL
			client = rustclient.NewClient(rustURL)
		}
		if req.AgentURL != "" {
			agentURL = req.AgentURL
		}
		jsonResponse(w, map[string]string{"status": "ok", "rust_url": rustURL, "agent_url": agentURL})
		return
	}
	jsonResponse(w, map[string]any{"rust_url": rustURL, "agent_url": agentURL, "connected": client != nil})
}

func handleHealth(w http.ResponseWriter, r *http.Request) {
	if client == nil {
		jsonError(w, "Rust API not configured", 503)
		return
	}
	ctx := r.Context()
	health, err := client.Health(ctx)
	if err != nil {
		jsonError(w, err.Error(), 503)
		return
	}
	jsonResponse(w, health)
}

func handleValidate(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "POST required", 405)
		return
	}
	if client == nil {
		jsonError(w, "Rust API not configured", 503)
		return
	}
	var req struct {
		DSL string `json:"dsl"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		jsonError(w, err.Error(), 400)
		return
	}

	result, err := client.ValidateDSL(r.Context(), req.DSL)
	if err != nil {
		jsonError(w, err.Error(), 500)
		return
	}
	jsonResponse(w, result)
}

func handleRunSuite(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "POST required", 405)
		return
	}
	if rustURL == "" {
		jsonError(w, "Rust API not configured", 503)
		return
	}

	var req struct {
		Cases []harness.Case `json:"cases"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		jsonError(w, err.Error(), 400)
		return
	}

	suite := harness.Suite{
		Name:  "Ad-hoc Suite",
		Cases: req.Cases,
	}

	runner := harness.NewRunner(rustURL)
	result, err := runner.Run(context.Background(), suite)
	if err != nil {
		jsonError(w, err.Error(), 500)
		return
	}
	jsonResponse(w, result)
}

// Agent proxy: create session
func handleAgentSession(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "POST required", 405)
		return
	}

	resp, err := http.Post(agentURL+"/api/session", "application/json", bytes.NewReader([]byte("{}")))
	if err != nil {
		jsonError(w, "Agent connection failed: "+err.Error(), 503)
		return
	}
	defer resp.Body.Close()

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(resp.StatusCode)
	io.Copy(w, resp.Body)
}

// Agent proxy: chat
func handleAgentChat(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "POST required", 405)
		return
	}

	var req struct {
		SessionID string `json:"session_id"`
		Message   string `json:"message"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		jsonError(w, err.Error(), 400)
		return
	}

	body, _ := json.Marshal(map[string]string{"message": req.Message})
	resp, err := http.Post(agentURL+"/api/session/"+req.SessionID+"/chat", "application/json", bytes.NewReader(body))
	if err != nil {
		jsonError(w, "Agent connection failed: "+err.Error(), 503)
		return
	}
	defer resp.Body.Close()

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(resp.StatusCode)
	io.Copy(w, resp.Body)
}

func jsonResponse(w http.ResponseWriter, v any) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(v)
}

func jsonError(w http.ResponseWriter, msg string, code int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	json.NewEncoder(w).Encode(map[string]string{"error": msg})
}

// Agent proxy: generate DSL from natural language
func handleAgentGenerate(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "POST required", 405)
		return
	}

	var req struct {
		Instruction string `json:"instruction"`
		Domain      string `json:"domain,omitempty"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		jsonError(w, err.Error(), 400)
		return
	}

	body, _ := json.Marshal(req)
	resp, err := http.Post(agentURL+"/api/agent/generate", "application/json", bytes.NewReader(body))
	if err != nil {
		jsonError(w, "Agent connection failed: "+err.Error(), 503)
		return
	}
	defer resp.Body.Close()

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(resp.StatusCode)
	io.Copy(w, resp.Body)
}

// Agent proxy: execute DSL
func handleAgentExecute(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "POST required", 405)
		return
	}

	var req struct {
		SessionID string `json:"session_id"`
		DSL       string `json:"dsl"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		jsonError(w, err.Error(), 400)
		return
	}

	body, _ := json.Marshal(map[string]string{"dsl": req.DSL})
	resp, err := http.Post(agentURL+"/api/session/"+req.SessionID+"/execute", "application/json", bytes.NewReader(body))
	if err != nil {
		jsonError(w, "Agent connection failed: "+err.Error(), 503)
		return
	}
	defer resp.Body.Close()

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(resp.StatusCode)
	io.Copy(w, resp.Body)
}


// Direct DSL execution via dsl_api (simpler, no session required)
func handleDirectExecute(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "POST required", 405)
		return
	}

	var req struct {
		DSL string `json:"dsl"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		jsonError(w, err.Error(), 400)
		return
	}

	body, _ := json.Marshal(req)
	resp, err := http.Post(rustURL+"/execute", "application/json", bytes.NewReader(body))
	if err != nil {
		jsonError(w, "DSL API connection failed: "+err.Error(), 503)
		return
	}
	defer resp.Body.Close()

	// Decode and re-encode to ensure valid JSON
	var result map[string]any
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		jsonError(w, "Invalid JSON from DSL API: "+err.Error(), 502)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(result)
}

// KYC case query: proxy to dsl_api
func handleKycCase(w http.ResponseWriter, r *http.Request) {
	if r.Method != "GET" {
		http.Error(w, "GET required", 405)
		return
	}

	// Extract case ID from path: /api/kyc/case/{id}
	caseID := r.URL.Path[len("/api/kyc/case/"):]
	if caseID == "" {
		jsonError(w, "Case ID required", 400)
		return
	}

	// Proxy to dsl_api
	resp, err := http.Get(rustURL + "/query/kyc/cases/" + caseID)
	if err != nil {
		jsonError(w, "DSL API connection failed: "+err.Error(), 503)
		return
	}
	defer resp.Body.Close()

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(resp.StatusCode)
	io.Copy(w, resp.Body)
}

// Analyze DSL errors: proxy to dsl_api
func handleAnalyzeErrors(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "POST required", 405)
		return
	}

	var req struct {
		DSL    string   `json:"dsl"`
		Errors []string `json:"errors"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		jsonError(w, err.Error(), 400)
		return
	}

	body, _ := json.Marshal(req)
	resp, err := http.Post(rustURL+"/analyze-errors", "application/json", bytes.NewReader(body))
	if err != nil {
		jsonError(w, "DSL API connection failed: "+err.Error(), 503)
		return
	}
	defer resp.Body.Close()

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(resp.StatusCode)
	io.Copy(w, resp.Body)
}
