diff --git a/rust/src/api/agent_routes.rs b/rust/src/api/agent_routes.rs
index 66494e43..d0f0fb39 100644
--- a/rust/src/api/agent_routes.rs
+++ b/rust/src/api/agent_routes.rs
@@ -27,7 +27,8 @@ use crate::api::session::{
 // API types - SINGLE SOURCE OF TRUTH for HTTP boundary
 use crate::database::derive_semantic_state;
 use crate::database::generation_log_repository::{
-    CompileResult, GenerationAttempt, GenerationLogRepository, LintResult, ParseResult,
+    CompileResult, ExecutionStatus, GenerationAttempt, GenerationLogRepository, LintResult,
+    ParseResult,
 };
 use crate::dsl_v2::{
     compile, parse_program, verb_registry::registry, DslExecutor, ExecutionContext,
@@ -773,6 +774,8 @@ pub struct AgentState {
     pub dsl_repo: Arc<crate::database::DslRepository>,
     /// Centralized agent service for chat/disambiguation
     pub agent_service: Arc<crate::api::agent_service::AgentService>,
+    /// Feedback service for learning loop
+    pub feedback_service: Arc<ob_semantic_matcher::FeedbackService>,
 }
 
 impl AgentState {
@@ -789,6 +792,7 @@ impl AgentState {
         let agent_service = Arc::new(crate::api::agent_service::AgentService::with_pool(
             pool.clone(),
         ));
+        let feedback_service = Arc::new(ob_semantic_matcher::FeedbackService::new(pool.clone()));
         // Create SessionManager wrapping the same session store
         let session_manager = crate::api::session_manager::SessionManager::new(sessions.clone());
         Self {
@@ -800,6 +804,7 @@ impl AgentState {
             session_repo,
             dsl_repo,
             agent_service,
+            feedback_service,
         }
     }
 }
@@ -2204,6 +2209,59 @@ async fn chat_session(
         }
     };
 
+    // =========================================================================
+    // CAPTURE FEEDBACK FOR LEARNING LOOP
+    // Record the verb match so we can correlate with execution outcome later
+    // =========================================================================
+    if !response.intents.is_empty() {
+        let first_intent = &response.intents[0];
+        // Build a MatchResult from the intent for feedback capture
+        let match_result = ob_semantic_matcher::MatchResult {
+            verb_name: first_intent.verb.clone(),
+            pattern_phrase: req.message.clone(), // The user's input
+            similarity: 1.0,                     // LLM selected this verb
+            match_method: ob_semantic_matcher::MatchMethod::Semantic, // LLM uses semantic understanding
+            category: "chat".to_string(),
+            is_agent_bound: true,
+        };
+
+        match state
+            .feedback_service
+            .capture_match(
+                session_id,
+                &req.message,
+                ob_semantic_matcher::feedback::InputSource::Chat,
+                Some(&match_result),
+                &[], // No alternatives from LLM path
+                session.context.domain_hint.as_deref(),
+                session.context.stage_focus.as_deref(),
+            )
+            .await
+        {
+            Ok(interaction_id) => {
+                // Store interaction_id in session for linking to dsl_generation_log
+                // intent_feedback uses BIGSERIAL id, need to look it up by interaction_id
+                if let Ok(Some(feedback_id)) = sqlx::query_scalar::<_, i64>(
+                    r#"SELECT id FROM "ob-poc".intent_feedback WHERE interaction_id = $1"#,
+                )
+                .bind(interaction_id)
+                .fetch_optional(&state.pool)
+                .await
+                {
+                    session.context.pending_feedback_id = Some(feedback_id);
+                    tracing::debug!(
+                        "Captured feedback: interaction_id={}, feedback_id={}",
+                        interaction_id,
+                        feedback_id
+                    );
+                }
+            }
+            Err(e) => {
+                tracing::warn!("Failed to capture feedback: {}", e);
+            }
+        }
+    }
+
     // Persist session changes back
     {
         let mut sessions = state.sessions.write().await;
@@ -2322,7 +2380,15 @@ async fn execute_session_dsl(
 
     // =========================================================================
     // START GENERATION LOG
+    // Get intent_feedback_id from session context if available (set by chat handler)
     // =========================================================================
+    let intent_feedback_id = {
+        let sessions = state.sessions.read().await;
+        sessions
+            .get(&session_id)
+            .and_then(|s| s.context.pending_feedback_id)
+    };
+
     let log_id = state
         .generation_log
         .start_log(
@@ -2331,6 +2397,7 @@ async fn execute_session_dsl(
             Some(session_id),
             context.last_cbu_id,
             None,
+            intent_feedback_id,
         )
         .await
         .ok();
@@ -2856,6 +2923,11 @@ async fn execute_session_dsl(
                 };
                 let _ = state.generation_log.add_attempt(lid, &attempt).await;
                 let _ = state.generation_log.mark_success(lid, &dsl, None).await;
+                // Record execution outcome for learning loop
+                let _ = state
+                    .generation_log
+                    .record_execution_outcome(lid, ExecutionStatus::Executed, None, None)
+                    .await;
             }
         }
         Err(e) => {
@@ -2892,6 +2964,11 @@ async fn execute_session_dsl(
                 };
                 let _ = state.generation_log.add_attempt(lid, &attempt).await;
                 let _ = state.generation_log.mark_failed(lid).await;
+                // Record execution outcome for learning loop
+                let _ = state
+                    .generation_log
+                    .record_execution_outcome(lid, ExecutionStatus::Failed, Some(&error_msg), None)
+                    .await;
             }
 
             results.push(ExecutionResult {
diff --git a/rust/src/api/session.rs b/rust/src/api/session.rs
index 51d06a3b..d7dfe779 100644
--- a/rust/src/api/session.rs
+++ b/rust/src/api/session.rs
@@ -2035,6 +2035,15 @@ pub struct SessionContext {
     /// Used for fractal navigation persistence.
     #[serde(default, skip_serializing_if = "std::collections::HashSet::is_empty")]
     pub expanded_nodes: std::collections::HashSet<Uuid>,
+
+    // =========================================================================
+    // Learning Loop Fields
+    // =========================================================================
+    /// Pending feedback interaction ID from chat handler
+    /// Links dsl_generation_log to intent_feedback when DSL is executed
+    /// Set by chat_session, consumed by execute_session_dsl
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub pending_feedback_id: Option<i64>,
 }
 
 /// Primary domain keys tracked across the session
diff --git a/rust/src/database/generation_log_repository.rs b/rust/src/database/generation_log_repository.rs
index d94bd22f..1e253dd5 100644
--- a/rust/src/database/generation_log_repository.rs
+++ b/rust/src/database/generation_log_repository.rs
@@ -6,6 +6,18 @@
 //! - Few-shot RAG retrieval of successful examples
 //! - Error recovery pattern learning
 //! - Prompt effectiveness analysis
+//!
+//! # Learning Loop Integration
+//!
+//! The `intent_feedback_id` FK links to `intent_feedback` table for learning:
+//! ```text
+//! intent_feedback (phrase → verb match)
+//!        ↓ FK
+//! dsl_generation_log (LLM → DSL + execution outcome)
+//!
+//! Learning query: JOIN both to find false positives
+//! (high confidence match → DSL generated → execution failed)
+//! ```
 
 use chrono::{DateTime, Utc};
 use serde::{Deserialize, Serialize};
@@ -52,6 +64,17 @@ pub struct CompileResult {
     pub step_count: i32,
 }
 
+/// Execution status for DSL (matches DB enum)
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, sqlx::Type)]
+#[sqlx(type_name = "execution_status", rename_all = "lowercase")]
+pub enum ExecutionStatus {
+    Pending,
+    Executed,
+    Failed,
+    Cancelled,
+    Skipped,
+}
+
 /// Training pair: user intent → valid DSL
 #[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
 pub struct TrainingPair {
@@ -97,6 +120,12 @@ pub struct GenerationLogRow {
     pub total_output_tokens: Option<i32>,
     pub created_at: Option<DateTime<Utc>>,
     pub completed_at: Option<DateTime<Utc>>,
+    // Learning loop fields (migration 039)
+    pub intent_feedback_id: Option<i64>,
+    pub execution_status: Option<ExecutionStatus>,
+    pub execution_error: Option<String>,
+    pub executed_at: Option<DateTime<Utc>>,
+    pub affected_entity_ids: Option<Vec<Uuid>>,
 }
 
 /// Repository for generation log operations
@@ -117,6 +146,9 @@ impl GenerationLogRepository {
 
     /// Start a new generation log entry
     /// Returns log_id for adding iterations
+    ///
+    /// # Arguments
+    /// * `intent_feedback_id` - Links to intent_feedback for learning loop (optional)
     pub async fn start_log(
         &self,
         user_intent: &str,
@@ -124,14 +156,15 @@ impl GenerationLogRepository {
         session_id: Option<Uuid>,
         cbu_id: Option<Uuid>,
         model_used: Option<&str>,
+        intent_feedback_id: Option<i64>,
     ) -> Result<Uuid, sqlx::Error> {
         let log_id = Uuid::new_v4();
 
         sqlx::query(
             r#"
             INSERT INTO "ob-poc".dsl_generation_log
-            (log_id, user_intent, domain_name, session_id, cbu_id, model_used, created_at)
-            VALUES ($1, $2, $3, $4, $5, $6, NOW())
+            (log_id, user_intent, domain_name, session_id, cbu_id, model_used, intent_feedback_id, created_at)
+            VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
             "#,
         )
         .bind(log_id)
@@ -140,6 +173,7 @@ impl GenerationLogRepository {
         .bind(session_id)
         .bind(cbu_id)
         .bind(model_used)
+        .bind(intent_feedback_id)
         .execute(&self.pool)
         .await?;
 
@@ -221,6 +255,58 @@ impl GenerationLogRepository {
         Ok(())
     }
 
+    /// Record execution outcome for learning loop
+    ///
+    /// Called after DSL execution completes (success or failure)
+    pub async fn record_execution_outcome(
+        &self,
+        log_id: Uuid,
+        status: ExecutionStatus,
+        error: Option<&str>,
+        affected_entities: Option<&[Uuid]>,
+    ) -> Result<(), sqlx::Error> {
+        sqlx::query(
+            r#"
+            UPDATE "ob-poc".dsl_generation_log
+            SET
+                execution_status = $2,
+                execution_error = $3,
+                affected_entity_ids = $4,
+                executed_at = NOW()
+            WHERE log_id = $1
+            "#,
+        )
+        .bind(log_id)
+        .bind(status)
+        .bind(error)
+        .bind(affected_entities)
+        .execute(&self.pool)
+        .await?;
+
+        Ok(())
+    }
+
+    /// Link an existing log entry to intent_feedback (if not set at creation)
+    pub async fn link_to_feedback(
+        &self,
+        log_id: Uuid,
+        intent_feedback_id: i64,
+    ) -> Result<(), sqlx::Error> {
+        sqlx::query(
+            r#"
+            UPDATE "ob-poc".dsl_generation_log
+            SET intent_feedback_id = $2
+            WHERE log_id = $1 AND intent_feedback_id IS NULL
+            "#,
+        )
+        .bind(log_id)
+        .bind(intent_feedback_id)
+        .execute(&self.pool)
+        .await?;
+
+        Ok(())
+    }
+
     /// Get a generation log by ID
     pub async fn get_by_id(&self, log_id: Uuid) -> Result<Option<GenerationLogRow>, sqlx::Error> {
         sqlx::query_as::<_, GenerationLogRow>(
@@ -228,7 +314,8 @@ impl GenerationLogRepository {
             SELECT log_id, instance_id, user_intent, final_valid_dsl, iterations,
                    domain_name, session_id, cbu_id, model_used, total_attempts,
                    success, total_latency_ms, total_input_tokens, total_output_tokens,
-                   created_at, completed_at
+                   created_at, completed_at,
+                   intent_feedback_id, execution_status, execution_error, executed_at, affected_entity_ids
             FROM "ob-poc".dsl_generation_log
             WHERE log_id = $1
             "#,
@@ -245,7 +332,8 @@ impl GenerationLogRepository {
             SELECT log_id, instance_id, user_intent, final_valid_dsl, iterations,
                    domain_name, session_id, cbu_id, model_used, total_attempts,
                    success, total_latency_ms, total_input_tokens, total_output_tokens,
-                   created_at, completed_at
+                   created_at, completed_at,
+                   intent_feedback_id, execution_status, execution_error, executed_at, affected_entity_ids
             FROM "ob-poc".dsl_generation_log
             ORDER BY created_at DESC
             LIMIT $1
@@ -373,7 +461,8 @@ impl GenerationLogRepository {
             SELECT log_id, instance_id, user_intent, final_valid_dsl, iterations,
                    domain_name, session_id, cbu_id, model_used, total_attempts,
                    success, total_latency_ms, total_input_tokens, total_output_tokens,
-                   created_at, completed_at
+                   created_at, completed_at,
+                   intent_feedback_id, execution_status, execution_error, executed_at, affected_entity_ids
             FROM "ob-poc".dsl_generation_log
             WHERE session_id = $1
             ORDER BY created_at ASC
diff --git a/rust/src/mcp/handlers/core.rs b/rust/src/mcp/handlers/core.rs
index 53225f18..511851a0 100644
--- a/rust/src/mcp/handlers/core.rs
+++ b/rust/src/mcp/handlers/core.rs
@@ -513,7 +513,7 @@ impl ToolHandlers {
         // Extract user_intent if provided, otherwise use a default
         let user_intent = args["intent"].as_str().unwrap_or("MCP tool execution");
 
-        // Start generation log
+        // Start generation log (no intent_feedback_id for direct MCP calls)
         let log_id = self
             .generation_log
             .start_log(
@@ -522,6 +522,7 @@ impl ToolHandlers {
                 None, // session_id
                 None, // cbu_id
                 None, // model
+                None, // intent_feedback_id - MCP direct execution
             )
             .await
             .ok();
