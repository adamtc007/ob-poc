// @generated
// This file is @generated by prost-build.
/// EBNF Grammar representation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EbnfGrammar {
    #[prost(map="string, message", tag="1")]
    pub rules: ::std::collections::HashMap<::prost::alloc::string::String, EbnfRule>,
    #[prost(string, optional, tag="2")]
    pub start_rule: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="4")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map="string, string", tag="5")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Individual EBNF rule
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EbnfRule {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub expression: ::core::option::Option<EbnfExpression>,
    #[prost(string, optional, tag="3")]
    pub comment: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="4")]
    pub location: ::core::option::Option<super::dsl::SourceLocation>,
}
/// EBNF expression types - recursive structure
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EbnfExpression {
    #[prost(oneof="ebnf_expression::ExpressionType", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
    pub expression_type: ::core::option::Option<ebnf_expression::ExpressionType>,
}
/// Nested message and enum types in `EBNFExpression`.
pub mod ebnf_expression {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExpressionType {
        #[prost(message, tag="1")]
        Terminal(super::TerminalExpression),
        #[prost(message, tag="2")]
        NonTerminal(super::NonTerminalExpression),
        #[prost(message, tag="3")]
        CharacterClass(super::CharacterClassExpression),
        #[prost(message, tag="4")]
        CharacterRange(super::CharacterRangeExpression),
        #[prost(message, tag="5")]
        Sequence(super::SequenceExpression),
        #[prost(message, tag="6")]
        Choice(super::ChoiceExpression),
        #[prost(message, tag="7")]
        Optional(::prost::alloc::boxed::Box<super::OptionalExpression>),
        #[prost(message, tag="8")]
        ZeroOrMore(::prost::alloc::boxed::Box<super::ZeroOrMoreExpression>),
        #[prost(message, tag="9")]
        OneOrMore(::prost::alloc::boxed::Box<super::OneOrMoreExpression>),
        #[prost(message, tag="10")]
        Group(::prost::alloc::boxed::Box<super::GroupExpression>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalExpression {
    #[prost(string, tag="1")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NonTerminalExpression {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CharacterClassExpression {
    #[prost(string, tag="1")]
    pub pattern: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CharacterRangeExpression {
    #[prost(string, tag="1")]
    pub start_char: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub end_char: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequenceExpression {
    #[prost(message, repeated, tag="1")]
    pub expressions: ::prost::alloc::vec::Vec<EbnfExpression>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChoiceExpression {
    #[prost(message, repeated, tag="1")]
    pub alternatives: ::prost::alloc::vec::Vec<EbnfExpression>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptionalExpression {
    #[prost(message, optional, boxed, tag="1")]
    pub expression: ::core::option::Option<::prost::alloc::boxed::Box<EbnfExpression>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZeroOrMoreExpression {
    #[prost(message, optional, boxed, tag="1")]
    pub expression: ::core::option::Option<::prost::alloc::boxed::Box<EbnfExpression>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OneOrMoreExpression {
    #[prost(message, optional, boxed, tag="1")]
    pub expression: ::core::option::Option<::prost::alloc::boxed::Box<EbnfExpression>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupExpression {
    #[prost(message, optional, boxed, tag="1")]
    pub expression: ::core::option::Option<::prost::alloc::boxed::Box<EbnfExpression>>,
}
/// Parse Grammar Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseGrammarRequest {
    #[prost(string, tag="1")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, optional, tag="2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub options: ::core::option::Option<ParseOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ParseOptions {
    #[prost(bool, tag="1")]
    pub strict_mode: bool,
    #[prost(bool, tag="2")]
    pub enable_comments: bool,
    #[prost(uint32, tag="3")]
    pub max_recursion_depth: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseGrammarResponse {
    #[prost(message, repeated, tag="3")]
    pub warnings: ::prost::alloc::vec::Vec<super::dsl::ValidationWarning>,
    #[prost(message, optional, tag="4")]
    pub stats: ::core::option::Option<ParseStats>,
    #[prost(oneof="parse_grammar_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<parse_grammar_response::Result>,
}
/// Nested message and enum types in `ParseGrammarResponse`.
pub mod parse_grammar_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Grammar(super::EbnfGrammar),
        #[prost(message, tag="2")]
        Error(super::ParseError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseError {
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub location: ::core::option::Option<super::dsl::SourceLocation>,
    #[prost(string, tag="3")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="4")]
    pub suggestions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ParseStats {
    #[prost(uint32, tag="1")]
    pub rules_parsed: u32,
    #[prost(uint32, tag="2")]
    pub expressions_parsed: u32,
    #[prost(message, optional, tag="3")]
    pub parse_duration: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint32, tag="4")]
    pub lines_processed: u32,
}
/// Validate Grammar Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateGrammarRequest {
    #[prost(message, optional, tag="3")]
    pub options: ::core::option::Option<ValidationOptions>,
    #[prost(oneof="validate_grammar_request::GrammarSource", tags="1, 2")]
    pub grammar_source: ::core::option::Option<validate_grammar_request::GrammarSource>,
}
/// Nested message and enum types in `ValidateGrammarRequest`.
pub mod validate_grammar_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum GrammarSource {
        #[prost(string, tag="1")]
        GrammarName(::prost::alloc::string::String),
        #[prost(message, tag="2")]
        Grammar(super::EbnfGrammar),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValidationOptions {
    #[prost(bool, tag="1")]
    pub check_undefined_references: bool,
    #[prost(bool, tag="2")]
    pub check_unreachable_rules: bool,
    #[prost(bool, tag="3")]
    pub check_left_recursion: bool,
    #[prost(bool, tag="4")]
    pub check_ambiguity: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateGrammarResponse {
    #[prost(bool, tag="1")]
    pub is_valid: bool,
    #[prost(message, repeated, tag="2")]
    pub errors: ::prost::alloc::vec::Vec<super::dsl::ValidationError>,
    #[prost(message, repeated, tag="3")]
    pub warnings: ::prost::alloc::vec::Vec<super::dsl::ValidationWarning>,
    #[prost(message, optional, tag="4")]
    pub stats: ::core::option::Option<ValidationStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValidationStats {
    #[prost(uint32, tag="1")]
    pub rules_checked: u32,
    #[prost(uint32, tag="2")]
    pub references_resolved: u32,
    #[prost(uint32, tag="3")]
    pub circular_dependencies_found: u32,
}
/// Load Grammar Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadGrammarRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub source: ::prost::alloc::string::String,
    #[prost(bool, tag="3")]
    pub set_as_active: bool,
    #[prost(message, optional, tag="4")]
    pub options: ::core::option::Option<LoadOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LoadOptions {
    #[prost(bool, tag="1")]
    pub overwrite_existing: bool,
    #[prost(bool, tag="2")]
    pub validate_before_load: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadGrammarResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, optional, tag="2")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub previous_version_backup: ::core::option::Option<::prost::alloc::string::String>,
}
/// Get Grammar Info Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGrammarInfoRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGrammarInfoResponse {
    #[prost(oneof="get_grammar_info_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<get_grammar_info_response::Result>,
}
/// Nested message and enum types in `GetGrammarInfoResponse`.
pub mod get_grammar_info_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Info(super::GrammarInfo),
        #[prost(string, tag="2")]
        ErrorMessage(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrammarInfo {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag="2")]
    pub rule_count: u32,
    #[prost(string, optional, tag="3")]
    pub start_rule: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="5")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag="6")]
    pub is_active: bool,
    #[prost(map="string, string", tag="7")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// List Grammars Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGrammarsRequest {
    #[prost(string, optional, tag="1")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, tag="2")]
    pub page_size: u32,
    #[prost(string, tag="3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGrammarsResponse {
    #[prost(message, repeated, tag="1")]
    pub grammars: ::prost::alloc::vec::Vec<GrammarInfo>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(uint32, tag="3")]
    pub total_count: u32,
}
/// Set Active Grammar Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetActiveGrammarRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetActiveGrammarResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, optional, tag="2")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub previous_active: ::core::option::Option<::prost::alloc::string::String>,
}
/// Grammar Summary Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGrammarSummaryRequest {
    /// If empty, use active grammar
    #[prost(string, optional, tag="1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGrammarSummaryResponse {
    #[prost(oneof="get_grammar_summary_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<get_grammar_summary_response::Result>,
}
/// Nested message and enum types in `GetGrammarSummaryResponse`.
pub mod get_grammar_summary_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Summary(super::GrammarSummary),
        #[prost(string, tag="2")]
        ErrorMessage(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrammarSummary {
    #[prost(uint32, tag="1")]
    pub rule_count: u32,
    #[prost(uint32, tag="2")]
    pub terminal_count: u32,
    #[prost(uint32, tag="3")]
    pub optional_count: u32,
    #[prost(uint32, tag="4")]
    pub repetition_count: u32,
    #[prost(uint32, tag="5")]
    pub max_depth: u32,
    #[prost(string, repeated, tag="6")]
    pub entry_points: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="7")]
    pub dependencies: ::prost::alloc::vec::Vec<DependencyInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DependencyInfo {
    #[prost(string, tag="1")]
    pub rule_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="2")]
    pub depends_on: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="3")]
    pub depended_by: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag="4")]
    pub depth_level: u32,
}
/// Export Grammar Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportGrammarRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration="ExportFormat", tag="2")]
    pub format: i32,
    #[prost(message, optional, tag="3")]
    pub options: ::core::option::Option<ExportOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportOptions {
    #[prost(bool, tag="1")]
    pub include_comments: bool,
    #[prost(bool, tag="2")]
    pub format_output: bool,
    #[prost(string, optional, tag="3")]
    pub custom_template: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportGrammarResponse {
    #[prost(enumeration="ExportFormat", tag="3")]
    pub format: i32,
    #[prost(oneof="export_grammar_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<export_grammar_response::Result>,
}
/// Nested message and enum types in `ExportGrammarResponse`.
pub mod export_grammar_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(string, tag="1")]
        ExportedContent(::prost::alloc::string::String),
        #[prost(string, tag="2")]
        ErrorMessage(::prost::alloc::string::String),
    }
}
/// Analyze Grammar Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeGrammarRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration="AnalysisType", repeated, tag="2")]
    pub analysis_types: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeGrammarResponse {
    #[prost(message, repeated, tag="1")]
    pub results: ::prost::alloc::vec::Vec<AnalysisResult>,
    #[prost(message, optional, tag="2")]
    pub stats: ::core::option::Option<AnalysisStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisResult {
    #[prost(enumeration="AnalysisType", tag="1")]
    pub r#type: i32,
    #[prost(string, tag="2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="4")]
    pub severity: i32,
    #[prost(message, repeated, tag="5")]
    pub issues: ::prost::alloc::vec::Vec<AnalysisIssue>,
    #[prost(map="string, string", tag="6")]
    pub metadata: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisIssue {
    #[prost(string, tag="1")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub location: ::core::option::Option<super::dsl::SourceLocation>,
    #[prost(string, repeated, tag="3")]
    pub affected_rules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="4")]
    pub suggestions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnalysisStats {
    #[prost(uint32, tag="1")]
    pub total_issues: u32,
    #[prost(uint32, tag="2")]
    pub errors: u32,
    #[prost(uint32, tag="3")]
    pub warnings: u32,
    #[prost(uint32, tag="4")]
    pub info: u32,
    #[prost(message, optional, tag="5")]
    pub analysis_duration: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExportFormat {
    Unspecified = 0,
    Ebnf = 1,
    Bnf = 2,
    Antlr = 3,
    Peg = 4,
    Json = 5,
    Yaml = 6,
}
impl ExportFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExportFormat::Unspecified => "EXPORT_FORMAT_UNSPECIFIED",
            ExportFormat::Ebnf => "EXPORT_FORMAT_EBNF",
            ExportFormat::Bnf => "EXPORT_FORMAT_BNF",
            ExportFormat::Antlr => "EXPORT_FORMAT_ANTLR",
            ExportFormat::Peg => "EXPORT_FORMAT_PEG",
            ExportFormat::Json => "EXPORT_FORMAT_JSON",
            ExportFormat::Yaml => "EXPORT_FORMAT_YAML",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXPORT_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "EXPORT_FORMAT_EBNF" => Some(Self::Ebnf),
            "EXPORT_FORMAT_BNF" => Some(Self::Bnf),
            "EXPORT_FORMAT_ANTLR" => Some(Self::Antlr),
            "EXPORT_FORMAT_PEG" => Some(Self::Peg),
            "EXPORT_FORMAT_JSON" => Some(Self::Json),
            "EXPORT_FORMAT_YAML" => Some(Self::Yaml),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AnalysisType {
    Unspecified = 0,
    Complexity = 1,
    Ambiguity = 2,
    LeftRecursion = 3,
    UnreachableRules = 4,
    UndefinedReferences = 5,
    Performance = 6,
}
impl AnalysisType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AnalysisType::Unspecified => "ANALYSIS_TYPE_UNSPECIFIED",
            AnalysisType::Complexity => "ANALYSIS_TYPE_COMPLEXITY",
            AnalysisType::Ambiguity => "ANALYSIS_TYPE_AMBIGUITY",
            AnalysisType::LeftRecursion => "ANALYSIS_TYPE_LEFT_RECURSION",
            AnalysisType::UnreachableRules => "ANALYSIS_TYPE_UNREACHABLE_RULES",
            AnalysisType::UndefinedReferences => "ANALYSIS_TYPE_UNDEFINED_REFERENCES",
            AnalysisType::Performance => "ANALYSIS_TYPE_PERFORMANCE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANALYSIS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ANALYSIS_TYPE_COMPLEXITY" => Some(Self::Complexity),
            "ANALYSIS_TYPE_AMBIGUITY" => Some(Self::Ambiguity),
            "ANALYSIS_TYPE_LEFT_RECURSION" => Some(Self::LeftRecursion),
            "ANALYSIS_TYPE_UNREACHABLE_RULES" => Some(Self::UnreachableRules),
            "ANALYSIS_TYPE_UNDEFINED_REFERENCES" => Some(Self::UndefinedReferences),
            "ANALYSIS_TYPE_PERFORMANCE" => Some(Self::Performance),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
