// @generated
// This file is @generated by prost-build.
/// Parse DSL Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseDslRequest {
    #[prost(string, tag="1")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, optional, tag="2")]
    pub source_file: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub config: ::core::option::Option<ParseConfig>,
    #[prost(string, optional, tag="4")]
    pub grammar_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ParseConfig {
    #[prost(bool, tag="1")]
    pub strict_validation: bool,
    #[prost(uint32, tag="2")]
    pub max_depth: u32,
    #[prost(bool, tag="3")]
    pub debug_mode: bool,
    #[prost(bool, tag="4")]
    pub include_source_locations: bool,
    #[prost(bool, tag="5")]
    pub preserve_comments: bool,
    #[prost(uint32, tag="6")]
    pub timeout_seconds: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseDslResponse {
    #[prost(message, optional, tag="3")]
    pub metrics: ::core::option::Option<ParseMetrics>,
    #[prost(message, repeated, tag="4")]
    pub warnings: ::prost::alloc::vec::Vec<super::dsl::ValidationWarning>,
    #[prost(oneof="parse_dsl_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<parse_dsl_response::Result>,
}
/// Nested message and enum types in `ParseDSLResponse`.
pub mod parse_dsl_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Program(super::super::dsl::Program),
        #[prost(message, tag="2")]
        Failure(super::ParseFailure),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseFailure {
    #[prost(string, tag="1")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="2")]
    pub severity: i32,
    #[prost(message, optional, tag="3")]
    pub location: ::core::option::Option<super::dsl::SourceLocation>,
    #[prost(string, tag="4")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="5")]
    pub suggestions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag="6")]
    pub partial_parse_info: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ParseMetrics {
    #[prost(message, optional, tag="1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="3")]
    pub duration_microseconds: u64,
    #[prost(uint32, tag="4")]
    pub lines_parsed: u32,
    #[prost(uint32, tag="5")]
    pub tokens_parsed: u32,
    #[prost(uint32, tag="6")]
    pub workflows_parsed: u32,
    #[prost(uint32, tag="7")]
    pub statements_parsed: u32,
    #[prost(uint64, tag="8")]
    pub memory_used_bytes: u64,
}
/// Streaming parse for large files
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseDslStreamRequest {
    #[prost(oneof="parse_dsl_stream_request::RequestType", tags="1, 2, 3")]
    pub request_type: ::core::option::Option<parse_dsl_stream_request::RequestType>,
}
/// Nested message and enum types in `ParseDSLStreamRequest`.
pub mod parse_dsl_stream_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RequestType {
        #[prost(message, tag="1")]
        Header(super::StreamHeader),
        #[prost(message, tag="2")]
        Chunk(super::StreamChunk),
        #[prost(message, tag="3")]
        Footer(super::StreamFooter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamHeader {
    #[prost(string, optional, tag="1")]
    pub source_file: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<ParseConfig>,
    #[prost(string, optional, tag="3")]
    pub grammar_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, tag="4")]
    pub total_size_bytes: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamChunk {
    #[prost(string, tag="1")]
    pub content: ::prost::alloc::string::String,
    #[prost(uint32, tag="2")]
    pub chunk_index: u32,
    #[prost(bool, tag="3")]
    pub is_final: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamFooter {
    #[prost(string, tag="1")]
    pub checksum: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseDslStreamResponse {
    #[prost(oneof="parse_dsl_stream_response::ResponseType", tags="1, 2, 3")]
    pub response_type: ::core::option::Option<parse_dsl_stream_response::ResponseType>,
}
/// Nested message and enum types in `ParseDSLStreamResponse`.
pub mod parse_dsl_stream_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResponseType {
        #[prost(message, tag="1")]
        Progress(super::StreamProgress),
        #[prost(message, tag="2")]
        Result(super::StreamResult),
        #[prost(message, tag="3")]
        Error(super::StreamError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StreamProgress {
    #[prost(uint32, tag="1")]
    pub chunks_processed: u32,
    #[prost(uint64, tag="2")]
    pub bytes_processed: u64,
    #[prost(uint32, tag="3")]
    pub workflows_found: u32,
    #[prost(float, tag="4")]
    pub completion_percentage: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamResult {
    #[prost(message, optional, tag="1")]
    pub program: ::core::option::Option<super::dsl::Program>,
    #[prost(message, optional, tag="2")]
    pub metrics: ::core::option::Option<ParseMetrics>,
    #[prost(message, repeated, tag="3")]
    pub warnings: ::prost::alloc::vec::Vec<super::dsl::ValidationWarning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamError {
    #[prost(string, tag="1")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub location: ::core::option::Option<super::dsl::SourceLocation>,
    #[prost(bool, tag="3")]
    pub is_recoverable: bool,
}
/// Parse and Validate Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseAndValidateRequest {
    #[prost(string, tag="1")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, optional, tag="2")]
    pub source_file: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub parse_config: ::core::option::Option<ParseConfig>,
    #[prost(message, optional, tag="4")]
    pub validation_config: ::core::option::Option<ValidationConfig>,
    #[prost(string, optional, tag="5")]
    pub grammar_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationConfig {
    #[prost(bool, tag="1")]
    pub check_undefined_entities: bool,
    #[prost(bool, tag="2")]
    pub check_circular_references: bool,
    #[prost(bool, tag="3")]
    pub check_type_consistency: bool,
    #[prost(bool, tag="4")]
    pub check_vocabulary_compliance: bool,
    #[prost(bool, tag="5")]
    pub check_business_rules: bool,
    #[prost(string, repeated, tag="6")]
    pub custom_validators: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseAndValidateResponse {
    #[prost(message, optional, tag="4")]
    pub parse_metrics: ::core::option::Option<ParseMetrics>,
    #[prost(message, optional, tag="5")]
    pub validation_metrics: ::core::option::Option<ValidationMetrics>,
    #[prost(oneof="parse_and_validate_response::Result", tags="1, 2, 3")]
    pub result: ::core::option::Option<parse_and_validate_response::Result>,
}
/// Nested message and enum types in `ParseAndValidateResponse`.
pub mod parse_and_validate_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        ValidatedProgram(super::ValidatedProgram),
        #[prost(message, tag="2")]
        ParseFailure(super::ParseFailure),
        #[prost(message, tag="3")]
        ValidationFailure(super::ValidationFailure),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatedProgram {
    #[prost(message, optional, tag="1")]
    pub program: ::core::option::Option<super::dsl::Program>,
    #[prost(message, optional, tag="2")]
    pub validation_report: ::core::option::Option<ValidationReport>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationFailure {
    #[prost(message, repeated, tag="1")]
    pub errors: ::prost::alloc::vec::Vec<super::dsl::ValidationError>,
    #[prost(message, repeated, tag="2")]
    pub warnings: ::prost::alloc::vec::Vec<super::dsl::ValidationWarning>,
    #[prost(message, optional, tag="3")]
    pub partial_program: ::core::option::Option<super::dsl::Program>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationReport {
    #[prost(bool, tag="1")]
    pub is_valid: bool,
    #[prost(uint32, tag="2")]
    pub total_checks: u32,
    #[prost(uint32, tag="3")]
    pub passed_checks: u32,
    #[prost(uint32, tag="4")]
    pub failed_checks: u32,
    #[prost(message, repeated, tag="5")]
    pub checks: ::prost::alloc::vec::Vec<ValidationCheck>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationCheck {
    #[prost(string, tag="1")]
    pub check_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag="3")]
    pub passed: bool,
    #[prost(string, optional, tag="4")]
    pub failure_reason: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="5")]
    pub severity: i32,
    #[prost(message, repeated, tag="6")]
    pub affected_locations: ::prost::alloc::vec::Vec<super::dsl::SourceLocation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValidationMetrics {
    #[prost(message, optional, tag="1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="3")]
    pub duration_microseconds: u64,
    #[prost(uint32, tag="4")]
    pub entities_validated: u32,
    #[prost(uint32, tag="5")]
    pub relationships_validated: u32,
    #[prost(uint32, tag="6")]
    pub workflows_validated: u32,
}
/// Parse Workflow Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseWorkflowRequest {
    #[prost(string, tag="1")]
    pub source: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<ParseConfig>,
    #[prost(string, optional, tag="3")]
    pub grammar_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseWorkflowResponse {
    #[prost(message, optional, tag="3")]
    pub metrics: ::core::option::Option<ParseMetrics>,
    #[prost(oneof="parse_workflow_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<parse_workflow_response::Result>,
}
/// Nested message and enum types in `ParseWorkflowResponse`.
pub mod parse_workflow_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Workflow(super::super::dsl::Workflow),
        #[prost(message, tag="2")]
        Failure(super::ParseFailure),
    }
}
/// Parse Value Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseValueRequest {
    #[prost(string, tag="1")]
    pub source: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub expected_type: ::core::option::Option<super::dsl::DslType>,
    #[prost(message, optional, tag="3")]
    pub config: ::core::option::Option<ParseConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseValueResponse {
    #[prost(message, optional, tag="3")]
    pub inferred_type: ::core::option::Option<super::dsl::DslType>,
    #[prost(message, optional, tag="4")]
    pub metrics: ::core::option::Option<ParseMetrics>,
    #[prost(oneof="parse_value_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<parse_value_response::Result>,
}
/// Nested message and enum types in `ParseValueResponse`.
pub mod parse_value_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Value(super::super::dsl::Value),
        #[prost(message, tag="2")]
        Failure(super::ParseFailure),
    }
}
/// Validate AST Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateAstRequest {
    #[prost(message, optional, tag="1")]
    pub program: ::core::option::Option<super::dsl::Program>,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<ValidationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateAstResponse {
    #[prost(message, optional, tag="1")]
    pub report: ::core::option::Option<ValidationReport>,
    #[prost(message, optional, tag="2")]
    pub metrics: ::core::option::Option<ValidationMetrics>,
}
/// Parser Configuration Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetParserConfigRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetParserConfigResponse {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<super::dsl::DslConfig>,
    #[prost(message, optional, tag="2")]
    pub capabilities: ::core::option::Option<ParserCapabilities>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParserCapabilities {
    #[prost(string, repeated, tag="1")]
    pub supported_formats: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="2")]
    pub supported_grammars: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag="3")]
    pub max_file_size_mb: u32,
    #[prost(uint32, tag="4")]
    pub max_recursion_depth: u32,
    #[prost(bool, tag="5")]
    pub supports_streaming: bool,
    #[prost(bool, tag="6")]
    pub supports_incremental_parsing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateParserConfigRequest {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<super::dsl::DslConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateParserConfigResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, optional, tag="2")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub previous_config: ::core::option::Option<super::dsl::DslConfig>,
}
/// Format DSL Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormatDslRequest {
    #[prost(string, tag="1")]
    pub source: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub options: ::core::option::Option<FormatOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormatOptions {
    #[prost(uint32, tag="1")]
    pub indent_size: u32,
    #[prost(bool, tag="2")]
    pub use_tabs: bool,
    #[prost(uint32, tag="3")]
    pub line_length: u32,
    #[prost(bool, tag="4")]
    pub preserve_comments: bool,
    #[prost(bool, tag="5")]
    pub sort_properties: bool,
    /// "compact", "standard", "verbose"
    #[prost(string, tag="6")]
    pub style: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FormatDslResponse {
    #[prost(message, optional, tag="3")]
    pub metrics: ::core::option::Option<FormatMetrics>,
    #[prost(oneof="format_dsl_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<format_dsl_response::Result>,
}
/// Nested message and enum types in `FormatDSLResponse`.
pub mod format_dsl_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(string, tag="1")]
        FormattedSource(::prost::alloc::string::String),
        #[prost(string, tag="2")]
        ErrorMessage(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FormatMetrics {
    #[prost(uint32, tag="1")]
    pub lines_formatted: u32,
    #[prost(uint32, tag="2")]
    pub changes_made: u32,
    #[prost(message, optional, tag="3")]
    pub duration: ::core::option::Option<::prost_types::Timestamp>,
}
/// Parse Tree Request/Response (for debugging)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetParseTreeRequest {
    #[prost(string, tag="1")]
    pub source: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<ParseConfig>,
    #[prost(string, optional, tag="3")]
    pub grammar_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag="4")]
    pub include_tokens: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetParseTreeResponse {
    #[prost(oneof="get_parse_tree_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<get_parse_tree_response::Result>,
}
/// Nested message and enum types in `GetParseTreeResponse`.
pub mod get_parse_tree_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Tree(super::ParseTree),
        #[prost(message, tag="2")]
        Failure(super::ParseFailure),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseTree {
    #[prost(message, optional, tag="1")]
    pub root: ::core::option::Option<ParseNode>,
    #[prost(message, repeated, tag="2")]
    pub tokens: ::prost::alloc::vec::Vec<Token>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseNode {
    #[prost(string, tag="1")]
    pub rule_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub text_content: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub location: ::core::option::Option<super::dsl::SourceLocation>,
    #[prost(message, repeated, tag="4")]
    pub children: ::prost::alloc::vec::Vec<ParseNode>,
    #[prost(map="string, string", tag="5")]
    pub attributes: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Token {
    #[prost(string, tag="1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub value: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub location: ::core::option::Option<super::dsl::SourceLocation>,
}
// @@protoc_insertion_point(module)
