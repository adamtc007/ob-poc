//! Semantic Agent Integration Test for V3.1 DSL Parser
//!
//! This test validates the integration between the Go semantic agent
//! and the Rust V3.1 parser, ensuring that AI-generated DSL content
//! parses correctly with the proper key handling.

use crate::parser::parse_program;
use crate::{Form, Key, Literal, Value, VerbForm};

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_semantic_agent_kyc_output() {
        // Simulates DSL generated by Go semantic agent based on KYCResponse
        let agent_generated_dsl = r#"
        ;; AI-generated KYC requirements from semantic agent
        (kyc.start
          :customer-id "company-zenith-001"
          :jurisdictions ["LU" "US" "KY"]
          :required-documents ["CertificateOfIncorporation" "ArticlesOfAssociation" "W8BEN-E"]
          :risk-level "MEDIUM"
          :agent-confidence 0.94)

        (document.catalog
          :document-id "doc-cert-inc-001"
          :document-type "CertificateOfIncorporation"
          :issuer "luxembourg_rcs"
          :required true)

        (document.catalog
          :document-id "doc-articles-001"
          :document-type "ArticlesOfAssociation"
          :issuer "luxembourg_rcs"
          :required true)
        "#;

        let result = parse_program(agent_generated_dsl);
        assert!(
            result.is_ok(),
            "Failed to parse semantic agent DSL: {:?}",
            result.err()
        );

        let forms = result.unwrap();

        // Filter verb forms (excluding comments)
        let verb_forms: Vec<_> = forms
            .iter()
            .filter_map(|form| match form {
                Form::Verb(verb_form) => Some(verb_form),
                Form::Comment(_) => None,
            })
            .collect();

        assert_eq!(verb_forms.len(), 3);

        // Validate kyc.start verb with arrays and agent metadata
        let kyc_start = &verb_forms[0];
        assert_eq!(kyc_start.verb, "kyc.start");

        // Test correct key parsing (no colon prefix in internal representation)
        let jurisdictions_key = Key::new("jurisdictions");
        let documents_key = Key::new("required-documents");
        let confidence_key = Key::new("agent-confidence");

        assert!(kyc_start.pairs.contains_key(&jurisdictions_key));
        assert!(kyc_start.pairs.contains_key(&documents_key));
        assert!(kyc_start.pairs.contains_key(&confidence_key));

        // Validate array parsing (when working)
        if let Some(Value::List(jurisdictions)) = kyc_start.pairs.get(&jurisdictions_key) {
            assert_eq!(jurisdictions.len(), 3);

            let expected_jurisdictions = vec![
                Value::Literal(Literal::String("LU".to_string())),
                Value::Literal(Literal::String("US".to_string())),
                Value::Literal(Literal::String("KY".to_string())),
            ];

            for expected in expected_jurisdictions {
                assert!(jurisdictions.contains(&expected));
            }
        }

        // Validate confidence score
        if let Some(Value::Literal(Literal::Number(confidence))) =
            kyc_start.pairs.get(&confidence_key)
        {
            assert_eq!(*confidence, 0.94);
        }

        // Validate document.catalog verbs
        let doc_catalog_1 = &verb_forms[1];
        let doc_catalog_2 = &verb_forms[2];

        assert_eq!(doc_catalog_1.verb, "document.catalog");
        assert_eq!(doc_catalog_2.verb, "document.catalog");

        // Test document type validation
        let doc_type_key = Key::new("document-type");

        if let Some(Value::Literal(Literal::String(doc_type))) =
            doc_catalog_1.pairs.get(&doc_type_key)
        {
            assert_eq!(doc_type, "CertificateOfIncorporation");
        }
    }

    #[test]
    fn test_key_parsing_correctness() {
        // Validates that V3.1 parser correctly handles colon stripping
        let dsl = r#"(test.verb :customer-id "test" :multi.part.key "value")"#;

        let result = parse_program(dsl);
        assert!(result.is_ok());

        let forms = result.unwrap();
        assert_eq!(forms.len(), 1);

        match &forms[0] {
            Form::Verb(VerbForm { pairs, .. }) => {
                // Keys should NOT contain colons in internal representation
                let customer_id_key = Key::new("customer-id");
                let multi_part_key = Key::new("multi.part.key");

                assert!(pairs.contains_key(&customer_id_key));
                assert!(pairs.contains_key(&multi_part_key));

                // Verify key structure
                assert_eq!(customer_id_key.parts, vec!["customer-id"]);
                assert_eq!(multi_part_key.parts, vec!["multi", "part", "key"]);

                // These should NOT work (colon in key)
                let wrong_key = Key::new(":customer-id");
                assert!(!pairs.contains_key(&wrong_key));
            }
            _ => panic!("Expected verb form"),
        }
    }

    #[test]
    fn test_go_agent_integration_pattern() {
        // Tests the pattern used by Go semantic agent for DSL generation
        let go_agent_style_dsl = r#"
        (kyc.verify
          :customer-id "company-alpha-holdings-sg"
          :method "enhanced_due_diligence"
          :verified-at "2024-11-10T10:00:00Z"
          :risk-rating "MEDIUM"
          :documents-verified ["CertificateOfIncorporation" "ArticlesOfAssociation"])

        (compliance.verify
          :entity "company-alpha-holdings-sg"
          :framework "MAS_CDD"
          :check-type "INSTITUTIONAL_CLIENT"
          :verified-at "2024-11-10T15:30:00Z"
          :compliance-outcome "COMPLIANT")
        "#;

        let result = parse_program(go_agent_style_dsl);
        assert!(result.is_ok(), "Go agent style DSL should parse correctly");

        let forms = result.unwrap();
        let verb_forms: Vec<_> = forms
            .iter()
            .filter_map(|form| match form {
                Form::Verb(verb_form) => Some(verb_form),
                Form::Comment(_) => None,
            })
            .collect();

        assert_eq!(verb_forms.len(), 2);
        assert_eq!(verb_forms[0].verb, "kyc.verify");
        assert_eq!(verb_forms[1].verb, "compliance.verify");

        // Test datetime parsing
        let verified_at_key = Key::new("verified-at");
        if let Some(Value::Literal(Literal::String(datetime))) =
            verb_forms[0].pairs.get(&verified_at_key)
        {
            assert_eq!(datetime, "2024-11-10T10:00:00Z");
        }
    }

    #[test]
    fn test_multi_domain_workflow_from_agent() {
        // Complete workflow that could be generated by semantic agent
        let agent_workflow = r#"
        ;; Multi-domain workflow generated by semantic agent
        (document.catalog
          :document-id "doc-isda-master-001"
          :document-type "ISDA_MASTER_AGREEMENT"
          :issuer "isda_inc"
          :confidence-score 0.98)

        (isda.establish_master
          :agreement-id "ISDA-ALPHA-PRIME-001"
          :party-a "company-alpha-holdings-sg"
          :party-b "prime-bank-london"
          :version "2002"
          :governing-law "EN"
          :document-id "doc-isda-master-001")

        (entity
          :id "company-alpha-holdings-sg"
          :label "Company"
          :props {
            :legal-name "Alpha Holdings Pte Ltd"
            :jurisdiction "SG"
          }
          :verified true)
        "#;

        let result = parse_program(agent_workflow);
        assert!(result.is_ok(), "Multi-domain workflow should parse");

        let forms = result.unwrap();
        let verb_forms: Vec<_> = forms
            .iter()
            .filter_map(|form| match form {
                Form::Verb(verb_form) => Some(verb_form),
                Form::Comment(_) => None,
            })
            .collect();

        assert_eq!(verb_forms.len(), 3);

        // Verify cross-domain references work
        let isda_verb = &verb_forms[1];
        let document_id_key = Key::new("document-id");

        if let Some(Value::Literal(Literal::String(doc_id))) = isda_verb.pairs.get(&document_id_key)
        {
            assert_eq!(doc_id, "doc-isda-master-001");
        }

        // Verify map parsing in entity
        let entity_verb = &verb_forms[2];
        let props_key = Key::new("props");

        assert!(entity_verb.pairs.contains_key(&props_key));
        if let Some(Value::Map(props)) = entity_verb.pairs.get(&props_key) {
            let legal_name_key = Key::new("legal-name");
            assert!(props.contains_key(&legal_name_key));
        }
    }

    #[test]
    fn test_agent_confidence_and_metadata() {
        // Tests AI agent metadata integration
        let dsl_with_metadata = r#"
        (kyc.assess_risk
          :entity-id "company-test-001"
          :risk-factors ["OFFSHORE_STRUCTURE" "COMPLEX_OWNERSHIP"]
          :risk-score 0.75
          :confidence-level 0.91
          :agent-version "gemini-2.5-flash"
          :assessment-date "2024-11-10T16:45:00Z")
        "#;

        let result = parse_program(dsl_with_metadata);
        assert!(result.is_ok());

        let forms = result.unwrap();
        assert_eq!(forms.len(), 1);

        match &forms[0] {
            Form::Verb(VerbForm { verb, pairs }) => {
                assert_eq!(verb, "kyc.assess_risk");

                // Test number parsing for scores
                let risk_score_key = Key::new("risk-score");
                let confidence_key = Key::new("confidence-level");

                if let Some(Value::Literal(Literal::Number(risk_score))) =
                    pairs.get(&risk_score_key)
                {
                    assert_eq!(*risk_score, 0.75);
                }

                if let Some(Value::Literal(Literal::Number(confidence))) =
                    pairs.get(&confidence_key)
                {
                    assert_eq!(*confidence, 0.91);
                }

                // Test agent metadata
                let agent_version_key = Key::new("agent-version");
                if let Some(Value::Literal(Literal::String(version))) =
                    pairs.get(&agent_version_key)
                {
                    assert_eq!(version, "gemini-2.5-flash");
                }
            }
            _ => panic!("Expected verb form"),
        }
    }

    #[test]
    fn test_error_handling_malformed_agent_output() {
        // Test that parser properly rejects malformed AI output
        let malformed_dsl = r#"(kyc.verify customer-id "test")"#; // Missing colon

        let result = parse_program(malformed_dsl);
        assert!(result.is_err(), "Should reject malformed syntax");
    }

    #[test]
    fn test_v31_compliance_with_semantic_agent() {
        // Comprehensive test of V3.1 compliance patterns
        let v31_patterns = vec![
            // Basic verb with string
            r#"(document.catalog :id "test")"#,
            // Verb with number
            r#"(kyc.assess_risk :score 0.85)"#,
            // Verb with boolean
            r#"(entity :verified true)"#,
            // Verb with identifier
            r#"(kyc.verify :entity company-001)"#,
            // Multiple parameters
            r#"(isda.execute_trade :id "trade-001" :amount 1000000.0 :active true)"#,
        ];

        for (i, pattern) in v31_patterns.iter().enumerate() {
            let result = parse_program(pattern);
            assert!(
                result.is_ok(),
                "V3.1 pattern {} should parse: {} - Error: {:?}",
                i,
                pattern,
                result.err()
            );

            let forms = result.unwrap();
            assert_eq!(forms.len(), 1, "Expected one form for pattern {}", i);

            match &forms[0] {
                Form::Verb(_) => {} // Success
                _ => panic!("Expected verb form for pattern {}", i),
            }
        }
    }
}
