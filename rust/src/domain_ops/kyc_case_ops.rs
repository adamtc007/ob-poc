//! KYC Case Operations
//!
//! Plugin operations for KYC case lifecycle management with deal-awareness.
//! Includes case creation with deal validation, and state queries with
//! domain-embedded requests (child nodes of workstreams, not separate lists).

use anyhow::{anyhow, Result};
use async_trait::async_trait;
use ob_poc_macros::register_custom_op;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use uuid::Uuid;

#[cfg(feature = "database")]
use sqlx::PgPool;

use crate::dsl_v2::ast::VerbCall;
use crate::dsl_v2::executor::{ExecutionContext, ExecutionResult};

use super::helpers::{extract_string, extract_string_opt, extract_uuid, extract_uuid_opt};
use super::CustomOperation;

// ============================================================================
// Result Types
// ============================================================================

/// Typed result for KYC case creation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KycCaseCreateResult {
    pub case_id: Uuid,
    pub case_ref: String,
    pub deal_id: Option<Uuid>,
    pub client_group_id: Option<Uuid>,
    pub status: String,
}

/// Typed result for KYC case closure.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KycCaseCloseResult {
    pub case_id: Uuid,
    pub status: String,
    pub closed_at: String,
    pub deal_gate_updated: bool,
}

// ============================================================================
// KycCaseCreateOp - Deal-aware case creation
// ============================================================================

/// Creates a new KYC case with optional deal linkage.
///
/// When `deal-id` is provided:
/// - Validates the deal exists and is in CONTRACTED, ONBOARDING, or ACTIVE status
/// - Infers `client_group_id` from the deal's `primary_client_group_id` if not provided
///
/// The `case_ref` is auto-generated by a database trigger in `KYC-YYYY-SEQ` format.
#[register_custom_op]
pub struct KycCaseCreateOp;

/// Deal statuses that are considered "agreed or beyond" for KYC case creation.
const AGREED_PLUS_STATUSES: &[&str] = &["CONTRACTED", "ONBOARDING", "ACTIVE"];

#[async_trait]
impl CustomOperation for KycCaseCreateOp {
    fn domain(&self) -> &'static str {
        "kyc-case"
    }

    fn verb(&self) -> &'static str {
        "create"
    }

    fn rationale(&self) -> &'static str {
        "Deal-aware case creation: validates deal status, infers client_group_id from deal, generates case_ref via DB trigger"
    }

    #[cfg(feature = "database")]
    async fn execute(
        &self,
        verb_call: &VerbCall,
        ctx: &mut ExecutionContext,
        pool: &PgPool,
    ) -> Result<ExecutionResult> {
        let cbu_id = extract_uuid(verb_call, ctx, "cbu-id")?;
        let deal_id = extract_uuid_opt(verb_call, ctx, "deal-id");
        let mut client_group_id = extract_uuid_opt(verb_call, ctx, "client-group-id");
        let case_type =
            extract_string_opt(verb_call, "case-type").unwrap_or_else(|| "NEW_CLIENT".to_string());
        let sla_deadline: Option<String> = extract_string_opt(verb_call, "sla-deadline");
        let assigned_analyst_id = extract_uuid_opt(verb_call, ctx, "assigned-analyst-id");
        let notes = extract_string_opt(verb_call, "notes");

        // If deal_id is provided, validate the deal and optionally infer client_group_id
        if let Some(did) = deal_id {
            let row: Option<(String, Uuid)> = sqlx::query_as(
                r#"SELECT deal_status, primary_client_group_id
                   FROM "ob-poc".deals
                   WHERE deal_id = $1"#,
            )
            .bind(did)
            .fetch_optional(pool)
            .await?;

            let (deal_status, deal_client_group_id) =
                row.ok_or_else(|| anyhow!("Deal not found: {}", did))?;

            if !AGREED_PLUS_STATUSES.contains(&deal_status.as_str()) {
                return Err(anyhow!(
                    "Deal {} is in status '{}', but KYC case creation requires one of: {}",
                    did,
                    deal_status,
                    AGREED_PLUS_STATUSES.join(", ")
                ));
            }

            // Infer client_group_id from deal if not explicitly provided
            if client_group_id.is_none() {
                client_group_id = Some(deal_client_group_id);
            }
        }

        // Generate case_id in application code (Uuid::new_v4 per project convention)
        let case_id = Uuid::new_v4();

        // Insert the case â€” case_ref is auto-generated by the DB trigger (kyc.generate_case_ref)
        let case_ref: String = sqlx::query_scalar(
            r#"INSERT INTO kyc.cases (
                   case_id, cbu_id, case_type, sla_deadline,
                   assigned_analyst_id, notes, deal_id, client_group_id
               )
               VALUES ($1, $2, $3, $4::timestamptz, $5, $6, $7, $8)
               RETURNING case_ref"#,
        )
        .bind(case_id)
        .bind(cbu_id)
        .bind(&case_type)
        .bind(&sla_deadline)
        .bind(assigned_analyst_id)
        .bind(&notes)
        .bind(deal_id)
        .bind(client_group_id)
        .fetch_one(pool)
        .await?;

        let result = KycCaseCreateResult {
            case_id,
            case_ref,
            deal_id,
            client_group_id,
            status: "INTAKE".to_string(),
        };

        Ok(ExecutionResult::Record(serde_json::to_value(result)?))
    }

    #[cfg(not(feature = "database"))]
    async fn execute(
        &self,
        _verb_call: &VerbCall,
        _ctx: &mut ExecutionContext,
    ) -> Result<ExecutionResult> {
        Err(anyhow!("Database feature required"))
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_kyc_case_create_handler_metadata() {
        let op = KycCaseCreateOp;
        assert_eq!(op.domain(), "kyc-case");
        assert_eq!(op.verb(), "create");
        assert!(
            op.rationale().contains("Deal-aware"),
            "Rationale should mention deal-awareness"
        );
    }

    #[test]
    fn test_kyc_case_create_result_serializes_correctly() {
        let result = KycCaseCreateResult {
            case_id: Uuid::new_v4(),
            case_ref: "KYC-2026-0042".to_string(),
            deal_id: Some(Uuid::new_v4()),
            client_group_id: Some(Uuid::new_v4()),
            status: "INTAKE".to_string(),
        };

        let value = serde_json::to_value(&result).expect("serialization should succeed");
        assert_eq!(value["case_ref"], "KYC-2026-0042");
        assert_eq!(value["status"], "INTAKE");
        assert!(
            value["case_id"].is_string(),
            "case_id should serialize as string"
        );
        assert!(
            value["deal_id"].is_string(),
            "deal_id should serialize as string when Some"
        );
        assert!(
            value["client_group_id"].is_string(),
            "client_group_id should serialize as string when Some"
        );
    }

    #[test]
    fn test_kyc_case_create_result_serializes_with_none_fields() {
        let result = KycCaseCreateResult {
            case_id: Uuid::new_v4(),
            case_ref: "KYC-2026-0001".to_string(),
            deal_id: None,
            client_group_id: None,
            status: "INTAKE".to_string(),
        };

        let value = serde_json::to_value(&result).expect("serialization should succeed");
        assert!(
            value["deal_id"].is_null(),
            "deal_id should be null when None"
        );
        assert!(
            value["client_group_id"].is_null(),
            "client_group_id should be null when None"
        );
        assert_eq!(value["case_ref"], "KYC-2026-0001");
        assert_eq!(value["status"], "INTAKE");

        // Round-trip: deserialize back
        let deserialized: KycCaseCreateResult =
            serde_json::from_value(value).expect("deserialization should succeed");
        assert_eq!(deserialized.case_ref, "KYC-2026-0001");
        assert!(deserialized.deal_id.is_none());
        assert!(deserialized.client_group_id.is_none());
    }

    #[test]
    fn test_kyc_case_close_op_metadata() {
        let op = KycCaseCloseOp;
        assert_eq!(op.domain(), "kyc-case");
        assert_eq!(op.verb(), "close");
        assert!(
            op.rationale().contains("KYC_GATE_COMPLETED"),
            "rationale should mention deal gate event"
        );
    }

    #[test]
    fn test_kyc_case_close_result_serialization() {
        let result = KycCaseCloseResult {
            case_id: Uuid::new_v4(),
            status: "APPROVED".to_string(),
            closed_at: "2026-02-12T10:30:00Z".to_string(),
            deal_gate_updated: true,
        };

        let json = serde_json::to_value(&result).expect("should serialize");
        assert_eq!(json["status"], "APPROVED");
        assert_eq!(json["deal_gate_updated"], true);
        assert_eq!(json["closed_at"], "2026-02-12T10:30:00Z");
        assert!(json["case_id"].is_string());
    }

    #[test]
    fn test_kyc_case_close_result_roundtrip() {
        let original = KycCaseCloseResult {
            case_id: Uuid::new_v4(),
            status: "REJECTED".to_string(),
            closed_at: "2026-02-12T14:00:00Z".to_string(),
            deal_gate_updated: false,
        };

        let json = serde_json::to_value(&original).expect("should serialize");
        let deserialized: KycCaseCloseResult =
            serde_json::from_value(json).expect("should deserialize");

        assert_eq!(deserialized.case_id, original.case_id);
        assert_eq!(deserialized.status, original.status);
        assert_eq!(deserialized.closed_at, original.closed_at);
        assert_eq!(deserialized.deal_gate_updated, original.deal_gate_updated);
    }

    #[test]
    fn test_close_statuses_includes_all_terminal_states() {
        assert!(CLOSE_STATUSES.contains(&"APPROVED"));
        assert!(CLOSE_STATUSES.contains(&"REJECTED"));
        assert!(CLOSE_STATUSES.contains(&"WITHDRAWN"));
        assert!(CLOSE_STATUSES.contains(&"EXPIRED"));
        assert!(CLOSE_STATUSES.contains(&"REFER_TO_REGULATOR"));
        assert!(CLOSE_STATUSES.contains(&"DO_NOT_ONBOARD"));
        // Non-terminal statuses must not be present
        assert!(!CLOSE_STATUSES.contains(&"INTAKE"));
        assert!(!CLOSE_STATUSES.contains(&"REVIEW"));
        assert!(!CLOSE_STATUSES.contains(&"DISCOVERY"));
    }

    #[test]
    fn test_kyc_case_state_op_metadata() {
        let op = KycCaseStateOp;
        assert_eq!(op.domain(), "kyc-case");
        assert_eq!(op.verb(), "state");
    }

    #[test]
    fn test_workstream_state_op_metadata() {
        let op = WorkstreamStateOp;
        assert_eq!(op.domain(), "entity-workstream");
        assert_eq!(op.verb(), "state");
    }
}

// ============================================================================
// KycCaseCloseOp - Close case with deal gate event emission
// ============================================================================

/// Closes a KYC case, setting `closed_at` and terminal status.
///
/// Validates the case is in REVIEW status before allowing closure.
/// When the case is APPROVED and has a linked `deal_id`, emits a
/// `KYC_GATE_COMPLETED` event into `deal_events` so the deal pipeline
/// knows the KYC gate is satisfied.
#[register_custom_op]
pub struct KycCaseCloseOp;

/// Terminal statuses allowed when closing a KYC case.
const CLOSE_STATUSES: &[&str] = &[
    "APPROVED",
    "REJECTED",
    "WITHDRAWN",
    "EXPIRED",
    "REFER_TO_REGULATOR",
    "DO_NOT_ONBOARD",
];

#[async_trait]
impl CustomOperation for KycCaseCloseOp {
    fn domain(&self) -> &'static str {
        "kyc-case"
    }

    fn verb(&self) -> &'static str {
        "close"
    }

    fn rationale(&self) -> &'static str {
        "Validates REVIEW status, sets closed_at, and emits KYC_GATE_COMPLETED deal event when APPROVED with linked deal"
    }

    #[cfg(feature = "database")]
    async fn execute(
        &self,
        verb_call: &VerbCall,
        ctx: &mut ExecutionContext,
        pool: &PgPool,
    ) -> Result<ExecutionResult> {
        let case_id = extract_uuid(verb_call, ctx, "case-id")?;
        let status = extract_string(verb_call, "status")?;
        let notes = extract_string_opt(verb_call, "notes");

        // Validate the requested status is a valid terminal status
        if !CLOSE_STATUSES.contains(&status.as_str()) {
            return Err(anyhow!(
                "Invalid close status '{}'. Must be one of: {}",
                status,
                CLOSE_STATUSES.join(", ")
            ));
        }

        // Load current case to validate state and retrieve deal_id
        let row: Option<(String, Option<Uuid>, Option<String>)> = sqlx::query_as(
            r#"SELECT status, deal_id, case_ref
               FROM kyc.cases
               WHERE case_id = $1"#,
        )
        .bind(case_id)
        .fetch_optional(pool)
        .await?;

        let (current_status, deal_id, case_ref) =
            row.ok_or_else(|| anyhow!("KYC case not found: {}", case_id))?;

        // Validate the case is in REVIEW status (closeable state)
        if current_status != "REVIEW" {
            return Err(anyhow!(
                "KYC case {} is in status '{}', but must be in REVIEW to close",
                case_id,
                current_status
            ));
        }

        // Close the case: set status and closed_at
        let closed_at: String = sqlx::query_scalar(
            r#"UPDATE kyc.cases
               SET status = $2,
                   closed_at = NOW(),
                   notes = COALESCE($3, notes),
                   updated_at = NOW()
               WHERE case_id = $1
               RETURNING to_char(closed_at, 'YYYY-MM-DD"T"HH24:MI:SS"Z"')"#,
        )
        .bind(case_id)
        .bind(&status)
        .bind(&notes)
        .fetch_one(pool)
        .await?;

        // If APPROVED and deal_id is present, emit KYC_GATE_COMPLETED event
        let mut deal_gate_updated = false;

        if status == "APPROVED" {
            if let Some(did) = deal_id {
                let event_id = Uuid::new_v4();
                let detail = serde_json::json!({
                    "case_id": case_id,
                    "case_ref": case_ref,
                    "approved_at": closed_at,
                    "gate": "KYC"
                });

                sqlx::query(
                    r#"INSERT INTO "ob-poc".deal_events
                           (event_id, deal_id, event_type, subject_type, subject_id, new_value, description)
                       VALUES ($1, $2, 'KYC_GATE_COMPLETED', 'KYC_CASE', $3, 'APPROVED', $4)"#,
                )
                .bind(event_id)
                .bind(did)
                .bind(case_id)
                .bind(detail.to_string())
                .execute(pool)
                .await?;

                deal_gate_updated = true;
            }
        }

        let result = KycCaseCloseResult {
            case_id,
            status,
            closed_at,
            deal_gate_updated,
        };

        Ok(ExecutionResult::Record(serde_json::to_value(result)?))
    }

    #[cfg(not(feature = "database"))]
    async fn execute(
        &self,
        _verb_call: &VerbCall,
        _ctx: &mut ExecutionContext,
    ) -> Result<ExecutionResult> {
        Err(anyhow!("Database feature required"))
    }
}

// ============================================================================
// KycCaseStateOp - Returns case with workstreams and embedded awaiting requests
// ============================================================================

/// Returns the full KYC case state with workstreams containing embedded
/// `awaiting` arrays. This is the domain-coherent view where requests are
/// child nodes of workstreams, not a separate list.
#[register_custom_op]
pub struct KycCaseStateOp;

#[async_trait]
impl CustomOperation for KycCaseStateOp {
    fn domain(&self) -> &'static str {
        "kyc-case"
    }

    fn verb(&self) -> &'static str {
        "state"
    }

    fn rationale(&self) -> &'static str {
        "Returns case with workstreams and embedded awaiting requests - requires complex join query"
    }

    #[cfg(feature = "database")]
    async fn execute(
        &self,
        verb_call: &VerbCall,
        ctx: &mut ExecutionContext,
        pool: &PgPool,
    ) -> Result<ExecutionResult> {
        let case_id = extract_uuid(verb_call, ctx, "case-id")?;

        // Load case with CBU info
        let case_row = sqlx::query!(
            r#"
            SELECT
                c.case_id,
                c.status,
                c.risk_rating,
                c.case_type,
                c.escalation_level,
                c.opened_at,
                c.sla_deadline,
                c.notes,
                cb.cbu_id,
                cb.name as cbu_name,
                cb.client_type
            FROM kyc.cases c
            JOIN "ob-poc".cbus cb ON c.cbu_id = cb.cbu_id
            WHERE c.case_id = $1
            "#,
            case_id
        )
        .fetch_optional(pool)
        .await?
        .ok_or_else(|| anyhow!("Case not found: {}", case_id))?;

        // Load workstreams with entity info
        let workstreams = sqlx::query!(
            r#"
            SELECT
                w.workstream_id,
                w.entity_id,
                w.status,
                w.discovery_reason,
                w.is_ubo,
                w.ownership_percentage,
                w.risk_rating as ws_risk_rating,
                w.requires_enhanced_dd,
                w.blocker_type,
                w.blocker_message,
                e.name as entity_name
            FROM kyc.entity_workstreams w
            JOIN "ob-poc".entities e ON w.entity_id = e.entity_id
            WHERE w.case_id = $1
            ORDER BY w.created_at
            "#,
            case_id
        )
        .fetch_all(pool)
        .await?;

        // For each workstream, get entity role and awaiting requests
        let mut workstream_states = Vec::new();
        let mut total_awaiting = 0;
        let mut overdue_count = 0;

        for ws in &workstreams {
            // Get entity role in CBU context
            let role: Option<String> = sqlx::query_scalar!(
                r#"
                SELECT r.name
                FROM "ob-poc".cbu_entity_roles cer
                JOIN "ob-poc".roles r ON cer.role_id = r.role_id
                WHERE cer.entity_id = $1 AND cer.cbu_id = $2
                LIMIT 1
                "#,
                ws.entity_id,
                case_row.cbu_id
            )
            .fetch_optional(pool)
            .await?;

            // Get awaiting requests for this workstream
            let awaiting_rows = sqlx::query!(
                r#"
                SELECT
                    request_id,
                    request_type,
                    request_subtype,
                    requested_from_label,
                    requested_at,
                    due_date,
                    reminder_count,
                    escalation_level,
                    status,
                    blocker_message,
                    CURRENT_DATE - due_date as days_overdue
                FROM kyc.outstanding_requests
                WHERE workstream_id = $1 AND status IN ('PENDING', 'ESCALATED')
                ORDER BY due_date ASC
                "#,
                ws.workstream_id
            )
            .fetch_all(pool)
            .await?;

            let awaiting_nodes: Vec<Value> = awaiting_rows
                .iter()
                .map(|r| {
                    let days_over = r.days_overdue.unwrap_or(0).max(0);
                    let is_overdue = days_over > 0;

                    if is_overdue {
                        overdue_count += 1;
                    }

                    let mut actions = vec!["remind", "extend"];
                    if is_overdue {
                        actions.push("escalate");
                    }
                    actions.push("waive");

                    json!({
                        "request_id": r.request_id,
                        "type": r.request_type,
                        "subtype": r.request_subtype,
                        "from": r.requested_from_label,
                        "requested_at": r.requested_at,
                        "due_date": r.due_date,
                        "days_overdue": days_over,
                        "overdue": is_overdue,
                        "reminder_count": r.reminder_count,
                        "escalated": r.escalation_level.unwrap_or(0) > 0,
                        "actions": actions
                    })
                })
                .collect();

            total_awaiting += awaiting_nodes.len();

            workstream_states.push(json!({
                "workstream_id": ws.workstream_id,
                "entity": {
                    "entity_id": ws.entity_id,
                    "name": ws.entity_name,
                    "role": role
                },
                "status": ws.status,
                "is_ubo": ws.is_ubo,
                "ownership_percentage": ws.ownership_percentage,
                "risk_rating": ws.ws_risk_rating,
                "requires_enhanced_dd": ws.requires_enhanced_dd,
                "blocker_type": ws.blocker_type,
                "blocker_message": ws.blocker_message,
                "awaiting": awaiting_nodes
            }));
        }

        // Build summary
        let complete_count = workstream_states
            .iter()
            .filter(|w| w["status"] == "COMPLETE")
            .count();
        let blocked_count = workstream_states
            .iter()
            .filter(|w| w["status"] == "BLOCKED")
            .count();
        let in_progress_count = workstream_states
            .iter()
            .filter(|w| {
                let s = w["status"].as_str().unwrap_or("");
                s != "COMPLETE" && s != "BLOCKED" && s != "PENDING"
            })
            .count();

        // Build attention items from overdue/blocked workstreams
        let empty_vec = vec![];
        let attention: Vec<Value> = workstream_states
            .iter()
            .flat_map(|ws| {
                let awaiting = ws["awaiting"].as_array().unwrap_or(&empty_vec);
                awaiting
                    .iter()
                    .filter(|r| r["overdue"].as_bool().unwrap_or(false))
                    .map(|r| {
                        let days = r["days_overdue"].as_i64().unwrap_or(0);
                        let priority = if days > 7 { "HIGH" } else { "MEDIUM" };

                        json!({
                            "workstream": ws["workstream_id"],
                            "entity": ws["entity"]["name"],
                            "issue": format!("{} overdue {} days",
                                r["subtype"].as_str().unwrap_or("Request"),
                                days),
                            "priority": priority,
                            "actions": r["actions"]
                        })
                    })
                    .collect::<Vec<_>>()
            })
            .collect();

        let result = json!({
            "case_id": case_row.case_id,
            "cbu": {
                "cbu_id": case_row.cbu_id,
                "name": case_row.cbu_name,
                "client_type": case_row.client_type
            },
            "status": case_row.status,
            "risk_rating": case_row.risk_rating,
            "case_type": case_row.case_type,
            "escalation_level": case_row.escalation_level,
            "opened_at": case_row.opened_at,
            "sla_deadline": case_row.sla_deadline,
            "workstreams": workstream_states,
            "summary": {
                "total_workstreams": workstream_states.len(),
                "complete": complete_count,
                "in_progress": in_progress_count,
                "blocked": blocked_count,
                "total_awaiting": total_awaiting,
                "overdue": overdue_count
            },
            "attention": attention
        });

        Ok(ExecutionResult::Record(result))
    }

    #[cfg(not(feature = "database"))]
    async fn execute(
        &self,
        _verb_call: &VerbCall,
        _ctx: &mut ExecutionContext,
    ) -> Result<ExecutionResult> {
        Err(anyhow!("Database feature required"))
    }
}

// ============================================================================
// WorkstreamStateOp - Returns single workstream with embedded awaiting
// ============================================================================

/// Returns a single workstream with its embedded awaiting requests.
#[register_custom_op]
pub struct WorkstreamStateOp;

#[async_trait]
impl CustomOperation for WorkstreamStateOp {
    fn domain(&self) -> &'static str {
        "entity-workstream"
    }

    fn verb(&self) -> &'static str {
        "state"
    }

    fn rationale(&self) -> &'static str {
        "Returns workstream with embedded awaiting requests, checks, and documents"
    }

    #[cfg(feature = "database")]
    async fn execute(
        &self,
        verb_call: &VerbCall,
        ctx: &mut ExecutionContext,
        pool: &PgPool,
    ) -> Result<ExecutionResult> {
        let workstream_id = extract_uuid(verb_call, ctx, "workstream-id")?;

        // Load workstream with entity info
        let ws = sqlx::query!(
            r#"
            SELECT
                w.workstream_id,
                w.case_id,
                w.entity_id,
                w.status,
                w.discovery_reason,
                w.is_ubo,
                w.ownership_percentage,
                w.risk_rating,
                w.requires_enhanced_dd,
                w.blocker_type,
                w.blocker_message,
                w.created_at,
                w.completed_at,
                e.name as entity_name,
                c.cbu_id
            FROM kyc.entity_workstreams w
            JOIN "ob-poc".entities e ON w.entity_id = e.entity_id
            JOIN kyc.cases c ON w.case_id = c.case_id
            WHERE w.workstream_id = $1
            "#,
            workstream_id
        )
        .fetch_optional(pool)
        .await?
        .ok_or_else(|| anyhow!("Workstream not found: {}", workstream_id))?;

        // Get entity role
        let role: Option<String> = sqlx::query_scalar!(
            r#"
            SELECT r.name
            FROM "ob-poc".cbu_entity_roles cer
            JOIN "ob-poc".roles r ON cer.role_id = r.role_id
            WHERE cer.entity_id = $1 AND cer.cbu_id = $2
            LIMIT 1
            "#,
            ws.entity_id,
            ws.cbu_id
        )
        .fetch_optional(pool)
        .await?;

        // Get awaiting requests
        let awaiting_rows = sqlx::query!(
            r#"
            SELECT
                request_id,
                request_type,
                request_subtype,
                requested_from_label,
                requested_at,
                due_date,
                reminder_count,
                escalation_level,
                status,
                CURRENT_DATE - due_date as days_overdue
            FROM kyc.outstanding_requests
            WHERE workstream_id = $1 AND status IN ('PENDING', 'ESCALATED')
            ORDER BY due_date ASC
            "#,
            workstream_id
        )
        .fetch_all(pool)
        .await?;

        let awaiting: Vec<Value> = awaiting_rows
            .iter()
            .map(|r| {
                let days_over = r.days_overdue.unwrap_or(0).max(0);
                let is_overdue = days_over > 0;
                let mut actions = vec!["remind", "extend"];
                if is_overdue {
                    actions.push("escalate");
                }
                actions.push("waive");

                json!({
                    "request_id": r.request_id,
                    "type": r.request_type,
                    "subtype": r.request_subtype,
                    "from": r.requested_from_label,
                    "requested_at": r.requested_at,
                    "due_date": r.due_date,
                    "days_overdue": days_over,
                    "overdue": is_overdue,
                    "reminder_count": r.reminder_count,
                    "escalated": r.escalation_level.unwrap_or(0) > 0,
                    "actions": actions
                })
            })
            .collect();

        // Get completed screenings
        let screenings = sqlx::query!(
            r#"
            SELECT screening_type, status, completed_at
            FROM kyc.screenings
            WHERE workstream_id = $1 AND status NOT IN ('PENDING', 'RUNNING')
            ORDER BY completed_at DESC
            "#,
            workstream_id
        )
        .fetch_all(pool)
        .await?;

        let checks_complete: Vec<Value> = screenings
            .iter()
            .map(|s| {
                json!({
                    "type": s.screening_type,
                    "result": s.status,
                    "date": s.completed_at
                })
            })
            .collect();

        // Get received documents
        let documents = sqlx::query!(
            r#"
            SELECT d.document_type_code, d.doc_id, d.created_at
            FROM "ob-poc".document_catalog d
            JOIN kyc.outstanding_requests r ON d.doc_id = r.fulfillment_reference_id
            WHERE r.workstream_id = $1 AND r.status = 'FULFILLED'
            ORDER BY d.created_at DESC
            "#,
            workstream_id
        )
        .fetch_all(pool)
        .await?;

        let documents_received: Vec<Value> = documents
            .iter()
            .map(|d| {
                json!({
                    "type": d.document_type_code,
                    "document_id": d.doc_id,
                    "date": d.created_at
                })
            })
            .collect();

        let result = json!({
            "workstream_id": ws.workstream_id,
            "case_id": ws.case_id,
            "entity": {
                "entity_id": ws.entity_id,
                "name": ws.entity_name,
                "role": role
            },
            "status": ws.status,
            "is_ubo": ws.is_ubo,
            "ownership_percentage": ws.ownership_percentage,
            "risk_rating": ws.risk_rating,
            "requires_enhanced_dd": ws.requires_enhanced_dd,
            "blocker_type": ws.blocker_type,
            "blocker_message": ws.blocker_message,
            "awaiting": awaiting,
            "checks_complete": checks_complete,
            "documents_received": documents_received
        });

        Ok(ExecutionResult::Record(result))
    }

    #[cfg(not(feature = "database"))]
    async fn execute(
        &self,
        _verb_call: &VerbCall,
        _ctx: &mut ExecutionContext,
    ) -> Result<ExecutionResult> {
        Err(anyhow!("Database feature required"))
    }
}
