// @generated
// This file is @generated by prost-build.
/// System information and health
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSystemInfoRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemInfoResponse {
    #[prost(message, optional, tag="1")]
    pub system_info: ::core::option::Option<super::dsl::SystemInfo>,
    #[prost(message, optional, tag="2")]
    pub service_versions: ::core::option::Option<ServiceVersions>,
    #[prost(message, optional, tag="3")]
    pub capabilities: ::core::option::Option<SystemCapabilities>,
    #[prost(message, optional, tag="4")]
    pub startup_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceVersions {
    #[prost(string, tag="1")]
    pub grammar_service_version: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub parser_service_version: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub ubo_service_version: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub vocabulary_service_version: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub engine_service_version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemCapabilities {
    #[prost(bool, tag="1")]
    pub supports_streaming: bool,
    #[prost(bool, tag="2")]
    pub supports_batch_processing: bool,
    #[prost(bool, tag="3")]
    pub supports_caching: bool,
    #[prost(bool, tag="4")]
    pub supports_hot_reload: bool,
    #[prost(uint32, tag="5")]
    pub max_concurrent_workflows: u32,
    #[prost(uint32, tag="6")]
    pub max_file_size_mb: u32,
    #[prost(string, repeated, tag="7")]
    pub supported_export_formats: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetHealthRequest {
    #[prost(bool, tag="1")]
    pub include_dependencies: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHealthResponse {
    #[prost(enumeration="HealthStatus", tag="1")]
    pub overall_status: i32,
    #[prost(message, repeated, tag="2")]
    pub service_health: ::prost::alloc::vec::Vec<ServiceHealth>,
    #[prost(message, repeated, tag="3")]
    pub health_checks: ::prost::alloc::vec::Vec<HealthCheck>,
    #[prost(message, optional, tag="4")]
    pub last_check_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceHealth {
    #[prost(string, tag="1")]
    pub service_name: ::prost::alloc::string::String,
    #[prost(enumeration="HealthStatus", tag="2")]
    pub status: i32,
    #[prost(string, optional, tag="3")]
    pub status_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="4")]
    pub last_check: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="5")]
    pub response_time_ms: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheck {
    #[prost(string, tag="1")]
    pub check_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration="HealthStatus", tag="3")]
    pub status: i32,
    #[prost(string, optional, tag="4")]
    pub details: ::core::option::Option<::prost::alloc::string::String>,
}
/// Metrics and monitoring
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsRequest {
    /// "1h", "24h", "7d", "30d"
    #[prost(string, optional, tag="1")]
    pub time_period: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="2")]
    pub metric_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetricsResponse {
    #[prost(message, optional, tag="1")]
    pub system_metrics: ::core::option::Option<SystemMetrics>,
    #[prost(message, optional, tag="2")]
    pub processing_metrics: ::core::option::Option<ProcessingMetrics>,
    #[prost(message, optional, tag="3")]
    pub performance_metrics: ::core::option::Option<PerformanceMetrics>,
    #[prost(message, optional, tag="4")]
    pub error_metrics: ::core::option::Option<ErrorMetrics>,
    #[prost(message, optional, tag="5")]
    pub collected_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SystemMetrics {
    #[prost(uint64, tag="1")]
    pub uptime_seconds: u64,
    #[prost(double, tag="2")]
    pub cpu_usage_percentage: f64,
    #[prost(uint64, tag="3")]
    pub memory_used_bytes: u64,
    #[prost(uint64, tag="4")]
    pub memory_available_bytes: u64,
    #[prost(uint32, tag="5")]
    pub active_connections: u32,
    #[prost(uint64, tag="6")]
    pub total_requests: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProcessingMetrics {
    #[prost(uint64, tag="1")]
    pub workflows_processed: u64,
    #[prost(uint64, tag="2")]
    pub successful_workflows: u64,
    #[prost(uint64, tag="3")]
    pub failed_workflows: u64,
    #[prost(double, tag="4")]
    pub average_processing_time_ms: f64,
    #[prost(double, tag="5")]
    pub p95_processing_time_ms: f64,
    #[prost(uint32, tag="6")]
    pub active_workflows: u32,
    #[prost(uint32, tag="7")]
    pub queued_workflows: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PerformanceMetrics {
    #[prost(uint32, tag="1")]
    pub cache_hit_rate_percentage: u32,
    #[prost(double, tag="2")]
    pub average_parse_time_ms: f64,
    #[prost(double, tag="3")]
    pub average_validation_time_ms: f64,
    #[prost(double, tag="4")]
    pub average_execution_time_ms: f64,
    #[prost(uint64, tag="5")]
    pub total_memory_allocations: u64,
    #[prost(double, tag="6")]
    pub garbage_collection_time_ms: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorMetrics {
    #[prost(uint64, tag="1")]
    pub total_errors: u64,
    #[prost(uint64, tag="2")]
    pub parse_errors: u64,
    #[prost(uint64, tag="3")]
    pub validation_errors: u64,
    #[prost(uint64, tag="4")]
    pub execution_errors: u64,
    #[prost(uint64, tag="5")]
    pub system_errors: u64,
    #[prost(message, repeated, tag="6")]
    pub top_errors: ::prost::alloc::vec::Vec<ErrorFrequency>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorFrequency {
    #[prost(string, tag="1")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub error_type: ::prost::alloc::string::String,
    #[prost(uint64, tag="3")]
    pub count: u64,
    #[prost(message, optional, tag="4")]
    pub last_occurrence: ::core::option::Option<::prost_types::Timestamp>,
}
/// Configuration management
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConfigurationRequest {
    #[prost(message, optional, tag="1")]
    pub configuration: ::core::option::Option<EngineConfiguration>,
    #[prost(bool, tag="2")]
    pub apply_immediately: bool,
    #[prost(bool, tag="3")]
    pub validate_before_apply: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConfigurationResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, optional, tag="2")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub previous_configuration: ::core::option::Option<EngineConfiguration>,
    #[prost(string, repeated, tag="4")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EngineConfiguration {
    #[prost(message, optional, tag="1")]
    pub dsl_config: ::core::option::Option<super::dsl::DslConfig>,
    #[prost(message, optional, tag="2")]
    pub processing_config: ::core::option::Option<ProcessingConfig>,
    #[prost(message, optional, tag="3")]
    pub cache_config: ::core::option::Option<CacheConfig>,
    #[prost(message, optional, tag="4")]
    pub security_config: ::core::option::Option<SecurityConfig>,
    #[prost(map="string, string", tag="5")]
    pub service_endpoints: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProcessingConfig {
    #[prost(uint32, tag="1")]
    pub max_concurrent_workflows: u32,
    #[prost(uint32, tag="2")]
    pub workflow_timeout_seconds: u32,
    #[prost(uint32, tag="3")]
    pub max_recursion_depth: u32,
    #[prost(bool, tag="4")]
    pub enable_async_processing: bool,
    #[prost(bool, tag="5")]
    pub enable_result_caching: bool,
    #[prost(uint32, tag="6")]
    pub batch_size: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CacheConfig {
    #[prost(bool, tag="1")]
    pub enable_caching: bool,
    #[prost(uint32, tag="2")]
    pub cache_size_mb: u32,
    #[prost(uint32, tag="3")]
    pub cache_ttl_seconds: u32,
    #[prost(string, repeated, tag="4")]
    pub cacheable_operations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityConfig {
    #[prost(bool, tag="1")]
    pub enable_authentication: bool,
    #[prost(bool, tag="2")]
    pub enable_authorization: bool,
    #[prost(string, repeated, tag="3")]
    pub allowed_operations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag="4")]
    pub rate_limit_requests_per_minute: u32,
}
/// Complete workflow processing
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessWorkflowRequest {
    #[prost(string, tag="1")]
    pub workflow_source: ::prost::alloc::string::String,
    #[prost(string, optional, tag="2")]
    pub workflow_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub options: ::core::option::Option<ProcessingOptions>,
    #[prost(map="string, message", tag="4")]
    pub context_variables: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
    #[prost(string, optional, tag="5")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessingOptions {
    #[prost(bool, tag="1")]
    pub validate_grammar: bool,
    #[prost(bool, tag="2")]
    pub validate_vocabulary: bool,
    #[prost(bool, tag="3")]
    pub execute_workflow: bool,
    #[prost(bool, tag="4")]
    pub include_detailed_results: bool,
    #[prost(bool, tag="5")]
    pub enable_tracing: bool,
    #[prost(string, optional, tag="6")]
    pub grammar_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, tag="7")]
    pub timeout_seconds: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessWorkflowResponse {
    #[prost(message, optional, tag="3")]
    pub metadata: ::core::option::Option<ProcessingMetadata>,
    #[prost(oneof="process_workflow_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<process_workflow_response::Result>,
}
/// Nested message and enum types in `ProcessWorkflowResponse`.
pub mod process_workflow_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        WorkflowResult(super::WorkflowResult),
        #[prost(message, tag="2")]
        ProcessingError(super::ProcessingError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowResult {
    #[prost(string, tag="1")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub parsed_workflow: ::core::option::Option<super::dsl::Workflow>,
    #[prost(message, repeated, tag="3")]
    pub execution_results: ::prost::alloc::vec::Vec<ExecutionResult>,
    #[prost(message, optional, tag="4")]
    pub ubo_results: ::core::option::Option<super::ubo::UboResult>,
    #[prost(message, optional, tag="5")]
    pub stats: ::core::option::Option<ProcessingStats>,
    #[prost(message, optional, tag="6")]
    pub trace: ::core::option::Option<ProcessingTrace>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionResult {
    #[prost(string, tag="1")]
    pub statement_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub statement_type: ::prost::alloc::string::String,
    #[prost(bool, tag="3")]
    pub success: bool,
    #[prost(string, optional, tag="4")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map="string, message", tag="5")]
    pub output_values: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
    #[prost(uint64, tag="6")]
    pub execution_time_microseconds: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessingError {
    #[prost(enumeration="ProcessingStage", tag="1")]
    pub failed_stage: i32,
    #[prost(string, tag="2")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="4")]
    pub severity: i32,
    #[prost(message, optional, tag="5")]
    pub location: ::core::option::Option<super::dsl::SourceLocation>,
    #[prost(string, repeated, tag="6")]
    pub suggestions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map="string, string", tag="7")]
    pub error_context: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessingMetadata {
    #[prost(string, tag="1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="3")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="4")]
    pub total_duration_microseconds: u64,
    #[prost(string, tag="5")]
    pub processing_node: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub session_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProcessingStats {
    #[prost(uint32, tag="1")]
    pub statements_processed: u32,
    #[prost(uint32, tag="2")]
    pub entities_created: u32,
    #[prost(uint32, tag="3")]
    pub relationships_created: u32,
    #[prost(uint32, tag="4")]
    pub calculations_performed: u32,
    #[prost(uint32, tag="5")]
    pub validations_run: u32,
    #[prost(uint64, tag="6")]
    pub memory_used_bytes: u64,
}
/// Streaming workflow processing
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessWorkflowStreamRequest {
    #[prost(oneof="process_workflow_stream_request::RequestType", tags="1, 2, 3")]
    pub request_type: ::core::option::Option<process_workflow_stream_request::RequestType>,
}
/// Nested message and enum types in `ProcessWorkflowStreamRequest`.
pub mod process_workflow_stream_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RequestType {
        #[prost(message, tag="1")]
        Header(super::StreamWorkflowHeader),
        #[prost(message, tag="2")]
        Chunk(super::StreamWorkflowChunk),
        #[prost(message, tag="3")]
        Footer(super::StreamWorkflowFooter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamWorkflowHeader {
    #[prost(string, optional, tag="1")]
    pub workflow_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="2")]
    pub options: ::core::option::Option<ProcessingOptions>,
    #[prost(map="string, message", tag="3")]
    pub context_variables: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
    #[prost(uint64, tag="4")]
    pub total_size_bytes: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamWorkflowChunk {
    #[prost(string, tag="1")]
    pub content: ::prost::alloc::string::String,
    #[prost(uint32, tag="2")]
    pub chunk_index: u32,
    #[prost(bool, tag="3")]
    pub is_final: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamWorkflowFooter {
    #[prost(string, tag="1")]
    pub checksum: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessWorkflowStreamResponse {
    #[prost(oneof="process_workflow_stream_response::ResponseType", tags="1, 2, 3")]
    pub response_type: ::core::option::Option<process_workflow_stream_response::ResponseType>,
}
/// Nested message and enum types in `ProcessWorkflowStreamResponse`.
pub mod process_workflow_stream_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResponseType {
        #[prost(message, tag="1")]
        Progress(super::StreamProcessingProgress),
        #[prost(message, tag="2")]
        Result(super::StreamWorkflowResult),
        #[prost(message, tag="3")]
        Error(super::StreamProcessingError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StreamProcessingProgress {
    #[prost(uint32, tag="1")]
    pub chunks_processed: u32,
    #[prost(uint64, tag="2")]
    pub bytes_processed: u64,
    #[prost(enumeration="ProcessingStage", tag="3")]
    pub current_stage: i32,
    #[prost(float, tag="4")]
    pub completion_percentage: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamWorkflowResult {
    #[prost(message, optional, tag="1")]
    pub result: ::core::option::Option<WorkflowResult>,
    #[prost(message, optional, tag="2")]
    pub metadata: ::core::option::Option<ProcessingMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamProcessingError {
    #[prost(message, optional, tag="1")]
    pub error: ::core::option::Option<ProcessingError>,
    #[prost(bool, tag="2")]
    pub is_recoverable: bool,
}
/// End-to-end operations
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseAndExecuteRequest {
    #[prost(string, tag="1")]
    pub dsl_source: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub execution_config: ::core::option::Option<ExecutionConfig>,
    #[prost(string, optional, tag="3")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionConfig {
    #[prost(bool, tag="1")]
    pub dry_run: bool,
    #[prost(bool, tag="2")]
    pub validate_only: bool,
    #[prost(bool, tag="3")]
    pub include_intermediate_results: bool,
    #[prost(map="string, message", tag="4")]
    pub execution_context: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
    #[prost(string, repeated, tag="5")]
    pub enabled_features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParseAndExecuteResponse {
    #[prost(message, optional, tag="3")]
    pub metadata: ::core::option::Option<ProcessingMetadata>,
    #[prost(oneof="parse_and_execute_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<parse_and_execute_response::Result>,
}
/// Nested message and enum types in `ParseAndExecuteResponse`.
pub mod parse_and_execute_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        ExecutionResult(super::ExecutionResult),
        #[prost(message, tag="2")]
        ProcessingError(super::ProcessingError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateAndProcessRequest {
    #[prost(string, tag="1")]
    pub dsl_source: ::prost::alloc::string::String,
    #[prost(enumeration="ValidationLevel", tag="2")]
    pub validation_level: i32,
    #[prost(message, optional, tag="3")]
    pub processing_options: ::core::option::Option<ProcessingOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateAndProcessResponse {
    #[prost(message, optional, tag="1")]
    pub validation_result: ::core::option::Option<ValidationResult>,
    #[prost(message, optional, tag="2")]
    pub processing_result: ::core::option::Option<WorkflowResult>,
    #[prost(message, optional, tag="3")]
    pub metadata: ::core::option::Option<ProcessingMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationResult {
    #[prost(bool, tag="1")]
    pub is_valid: bool,
    #[prost(enumeration="ValidationLevel", tag="2")]
    pub level_achieved: i32,
    #[prost(message, repeated, tag="3")]
    pub errors: ::prost::alloc::vec::Vec<super::dsl::ValidationError>,
    #[prost(message, repeated, tag="4")]
    pub warnings: ::prost::alloc::vec::Vec<super::dsl::ValidationWarning>,
    #[prost(message, optional, tag="5")]
    pub validation_stats: ::core::option::Option<ValidationStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValidationStats {
    #[prost(uint32, tag="1")]
    pub total_checks: u32,
    #[prost(uint32, tag="2")]
    pub passed_checks: u32,
    #[prost(uint32, tag="3")]
    pub failed_checks: u32,
    #[prost(uint32, tag="4")]
    pub skipped_checks: u32,
    #[prost(uint64, tag="5")]
    pub validation_time_microseconds: u64,
}
/// Batch processing
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessBatchRequest {
    #[prost(message, repeated, tag="1")]
    pub items: ::prost::alloc::vec::Vec<BatchItem>,
    #[prost(message, optional, tag="2")]
    pub options: ::core::option::Option<BatchProcessingOptions>,
    #[prost(string, optional, tag="3")]
    pub batch_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchItem {
    #[prost(string, tag="1")]
    pub item_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub dsl_source: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub processing_options: ::core::option::Option<ProcessingOptions>,
    #[prost(map="string, message", tag="4")]
    pub context: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchProcessingOptions {
    #[prost(bool, tag="1")]
    pub parallel_processing: bool,
    #[prost(bool, tag="2")]
    pub stop_on_error: bool,
    #[prost(uint32, tag="3")]
    pub max_concurrent_items: u32,
    #[prost(bool, tag="4")]
    pub include_partial_results: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessBatchResponse {
    #[prost(string, tag="1")]
    pub batch_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="2")]
    pub results: ::prost::alloc::vec::Vec<BatchItemResult>,
    #[prost(message, optional, tag="3")]
    pub batch_stats: ::core::option::Option<BatchProcessingStats>,
    #[prost(message, repeated, tag="4")]
    pub batch_errors: ::prost::alloc::vec::Vec<ProcessingError>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchItemResult {
    #[prost(string, tag="1")]
    pub item_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub metadata: ::core::option::Option<ProcessingMetadata>,
    #[prost(oneof="batch_item_result::Result", tags="2, 3")]
    pub result: ::core::option::Option<batch_item_result::Result>,
}
/// Nested message and enum types in `BatchItemResult`.
pub mod batch_item_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="2")]
        WorkflowResult(super::WorkflowResult),
        #[prost(message, tag="3")]
        ProcessingError(super::ProcessingError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchProcessingStats {
    #[prost(uint32, tag="1")]
    pub total_items: u32,
    #[prost(uint32, tag="2")]
    pub successful_items: u32,
    #[prost(uint32, tag="3")]
    pub failed_items: u32,
    #[prost(message, optional, tag="4")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="5")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="6")]
    pub total_processing_time_microseconds: u64,
}
/// Development and debugging
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeDslRequest {
    #[prost(string, tag="1")]
    pub dsl_source: ::prost::alloc::string::String,
    #[prost(enumeration="AnalysisType", repeated, tag="2")]
    pub analysis_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag="3")]
    pub options: ::core::option::Option<AnalysisOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnalysisOptions {
    #[prost(bool, tag="1")]
    pub include_suggestions: bool,
    #[prost(bool, tag="2")]
    pub include_metrics: bool,
    #[prost(bool, tag="3")]
    pub deep_analysis: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeDslResponse {
    #[prost(message, repeated, tag="1")]
    pub analysis_results: ::prost::alloc::vec::Vec<AnalysisResult>,
    #[prost(message, optional, tag="2")]
    pub summary: ::core::option::Option<AnalysisSummary>,
    #[prost(message, optional, tag="3")]
    pub metadata: ::core::option::Option<ProcessingMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisResult {
    #[prost(enumeration="AnalysisType", tag="1")]
    pub r#type: i32,
    #[prost(string, tag="2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="4")]
    pub severity: i32,
    #[prost(message, repeated, tag="5")]
    pub issues: ::prost::alloc::vec::Vec<AnalysisIssue>,
    #[prost(string, repeated, tag="6")]
    pub suggestions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map="string, message", tag="7")]
    pub metrics: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisIssue {
    #[prost(string, tag="1")]
    pub issue_code: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub location: ::core::option::Option<super::dsl::SourceLocation>,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="4")]
    pub severity: i32,
    #[prost(string, repeated, tag="5")]
    pub suggestions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnalysisSummary {
    #[prost(uint32, tag="1")]
    pub total_issues: u32,
    #[prost(uint32, tag="2")]
    pub errors: u32,
    #[prost(uint32, tag="3")]
    pub warnings: u32,
    #[prost(uint32, tag="4")]
    pub info_items: u32,
    #[prost(enumeration="OverallQuality", tag="5")]
    pub quality_score: i32,
}
/// Processing trace for debugging
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProcessingTraceRequest {
    #[prost(string, tag="1")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub include_detailed_steps: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProcessingTraceResponse {
    #[prost(oneof="get_processing_trace_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<get_processing_trace_response::Result>,
}
/// Nested message and enum types in `GetProcessingTraceResponse`.
pub mod get_processing_trace_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Trace(super::ProcessingTrace),
        #[prost(string, tag="2")]
        ErrorMessage(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessingTrace {
    #[prost(string, tag="1")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag="5")]
    pub steps: ::prost::alloc::vec::Vec<TraceStep>,
    #[prost(map="string, message", tag="6")]
    pub trace_data: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceStep {
    #[prost(uint32, tag="1")]
    pub step_number: u32,
    #[prost(enumeration="ProcessingStage", tag="2")]
    pub stage: i32,
    #[prost(string, tag="3")]
    pub operation: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="5")]
    pub duration_microseconds: u64,
    #[prost(bool, tag="6")]
    pub success: bool,
    #[prost(string, optional, tag="7")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map="string, message", tag="8")]
    pub step_data: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
    #[prost(string, repeated, tag="9")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Configuration validation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateConfigurationRequest {
    #[prost(message, optional, tag="1")]
    pub configuration: ::core::option::Option<EngineConfiguration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateConfigurationResponse {
    #[prost(bool, tag="1")]
    pub is_valid: bool,
    #[prost(message, repeated, tag="2")]
    pub issues: ::prost::alloc::vec::Vec<ConfigurationIssue>,
    #[prost(string, repeated, tag="3")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigurationIssue {
    #[prost(string, tag="1")]
    pub setting_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub issue_description: ::prost::alloc::string::String,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="3")]
    pub severity: i32,
    #[prost(string, optional, tag="4")]
    pub suggested_value: ::core::option::Option<::prost::alloc::string::String>,
}
/// Cache management
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearCacheRequest {
    #[prost(enumeration="CacheType", repeated, tag="1")]
    pub cache_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, tag="2")]
    pub force_clear: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearCacheResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(message, repeated, tag="2")]
    pub results: ::prost::alloc::vec::Vec<CacheClearResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CacheClearResult {
    #[prost(enumeration="CacheType", tag="1")]
    pub cache_type: i32,
    #[prost(bool, tag="2")]
    pub cleared: bool,
    #[prost(uint32, tag="3")]
    pub entries_removed: u32,
    #[prost(uint64, tag="4")]
    pub memory_freed_bytes: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCacheStatsRequest {
    #[prost(enumeration="CacheType", repeated, tag="1")]
    pub cache_types: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCacheStatsResponse {
    #[prost(message, repeated, tag="1")]
    pub cache_stats: ::prost::alloc::vec::Vec<CacheStats>,
    #[prost(message, optional, tag="2")]
    pub collected_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CacheStats {
    #[prost(enumeration="CacheType", tag="1")]
    pub cache_type: i32,
    #[prost(uint32, tag="2")]
    pub total_entries: u32,
    #[prost(uint64, tag="3")]
    pub memory_used_bytes: u64,
    #[prost(uint64, tag="4")]
    pub total_hits: u64,
    #[prost(uint64, tag="5")]
    pub total_misses: u64,
    #[prost(double, tag="6")]
    pub hit_rate_percentage: f64,
    #[prost(message, optional, tag="7")]
    pub last_access: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatus {
    Unspecified = 0,
    Healthy = 1,
    Degraded = 2,
    Unhealthy = 3,
    Critical = 4,
}
impl HealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HealthStatus::Unspecified => "HEALTH_STATUS_UNSPECIFIED",
            HealthStatus::Healthy => "HEALTH_STATUS_HEALTHY",
            HealthStatus::Degraded => "HEALTH_STATUS_DEGRADED",
            HealthStatus::Unhealthy => "HEALTH_STATUS_UNHEALTHY",
            HealthStatus::Critical => "HEALTH_STATUS_CRITICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "HEALTH_STATUS_HEALTHY" => Some(Self::Healthy),
            "HEALTH_STATUS_DEGRADED" => Some(Self::Degraded),
            "HEALTH_STATUS_UNHEALTHY" => Some(Self::Unhealthy),
            "HEALTH_STATUS_CRITICAL" => Some(Self::Critical),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessingStage {
    Unspecified = 0,
    Parsing = 1,
    GrammarValidation = 2,
    VocabularyValidation = 3,
    SemanticValidation = 4,
    Execution = 5,
    UboCalculation = 6,
    ResultFormatting = 7,
}
impl ProcessingStage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ProcessingStage::Unspecified => "PROCESSING_STAGE_UNSPECIFIED",
            ProcessingStage::Parsing => "PROCESSING_STAGE_PARSING",
            ProcessingStage::GrammarValidation => "PROCESSING_STAGE_GRAMMAR_VALIDATION",
            ProcessingStage::VocabularyValidation => "PROCESSING_STAGE_VOCABULARY_VALIDATION",
            ProcessingStage::SemanticValidation => "PROCESSING_STAGE_SEMANTIC_VALIDATION",
            ProcessingStage::Execution => "PROCESSING_STAGE_EXECUTION",
            ProcessingStage::UboCalculation => "PROCESSING_STAGE_UBO_CALCULATION",
            ProcessingStage::ResultFormatting => "PROCESSING_STAGE_RESULT_FORMATTING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROCESSING_STAGE_UNSPECIFIED" => Some(Self::Unspecified),
            "PROCESSING_STAGE_PARSING" => Some(Self::Parsing),
            "PROCESSING_STAGE_GRAMMAR_VALIDATION" => Some(Self::GrammarValidation),
            "PROCESSING_STAGE_VOCABULARY_VALIDATION" => Some(Self::VocabularyValidation),
            "PROCESSING_STAGE_SEMANTIC_VALIDATION" => Some(Self::SemanticValidation),
            "PROCESSING_STAGE_EXECUTION" => Some(Self::Execution),
            "PROCESSING_STAGE_UBO_CALCULATION" => Some(Self::UboCalculation),
            "PROCESSING_STAGE_RESULT_FORMATTING" => Some(Self::ResultFormatting),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ValidationLevel {
    Unspecified = 0,
    SyntaxOnly = 1,
    Semantic = 2,
    BusinessRules = 3,
    Comprehensive = 4,
}
impl ValidationLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ValidationLevel::Unspecified => "VALIDATION_LEVEL_UNSPECIFIED",
            ValidationLevel::SyntaxOnly => "VALIDATION_LEVEL_SYNTAX_ONLY",
            ValidationLevel::Semantic => "VALIDATION_LEVEL_SEMANTIC",
            ValidationLevel::BusinessRules => "VALIDATION_LEVEL_BUSINESS_RULES",
            ValidationLevel::Comprehensive => "VALIDATION_LEVEL_COMPREHENSIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VALIDATION_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "VALIDATION_LEVEL_SYNTAX_ONLY" => Some(Self::SyntaxOnly),
            "VALIDATION_LEVEL_SEMANTIC" => Some(Self::Semantic),
            "VALIDATION_LEVEL_BUSINESS_RULES" => Some(Self::BusinessRules),
            "VALIDATION_LEVEL_COMPREHENSIVE" => Some(Self::Comprehensive),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AnalysisType {
    Unspecified = 0,
    Syntax = 1,
    Semantics = 2,
    Performance = 3,
    Complexity = 4,
    Dependencies = 5,
    Security = 6,
}
impl AnalysisType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AnalysisType::Unspecified => "ANALYSIS_TYPE_UNSPECIFIED",
            AnalysisType::Syntax => "ANALYSIS_TYPE_SYNTAX",
            AnalysisType::Semantics => "ANALYSIS_TYPE_SEMANTICS",
            AnalysisType::Performance => "ANALYSIS_TYPE_PERFORMANCE",
            AnalysisType::Complexity => "ANALYSIS_TYPE_COMPLEXITY",
            AnalysisType::Dependencies => "ANALYSIS_TYPE_DEPENDENCIES",
            AnalysisType::Security => "ANALYSIS_TYPE_SECURITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANALYSIS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ANALYSIS_TYPE_SYNTAX" => Some(Self::Syntax),
            "ANALYSIS_TYPE_SEMANTICS" => Some(Self::Semantics),
            "ANALYSIS_TYPE_PERFORMANCE" => Some(Self::Performance),
            "ANALYSIS_TYPE_COMPLEXITY" => Some(Self::Complexity),
            "ANALYSIS_TYPE_DEPENDENCIES" => Some(Self::Dependencies),
            "ANALYSIS_TYPE_SECURITY" => Some(Self::Security),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OverallQuality {
    Unspecified = 0,
    Excellent = 1,
    Good = 2,
    Fair = 3,
    Poor = 4,
    Critical = 5,
}
impl OverallQuality {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OverallQuality::Unspecified => "OVERALL_QUALITY_UNSPECIFIED",
            OverallQuality::Excellent => "OVERALL_QUALITY_EXCELLENT",
            OverallQuality::Good => "OVERALL_QUALITY_GOOD",
            OverallQuality::Fair => "OVERALL_QUALITY_FAIR",
            OverallQuality::Poor => "OVERALL_QUALITY_POOR",
            OverallQuality::Critical => "OVERALL_QUALITY_CRITICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OVERALL_QUALITY_UNSPECIFIED" => Some(Self::Unspecified),
            "OVERALL_QUALITY_EXCELLENT" => Some(Self::Excellent),
            "OVERALL_QUALITY_GOOD" => Some(Self::Good),
            "OVERALL_QUALITY_FAIR" => Some(Self::Fair),
            "OVERALL_QUALITY_POOR" => Some(Self::Poor),
            "OVERALL_QUALITY_CRITICAL" => Some(Self::Critical),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CacheType {
    Unspecified = 0,
    ParsedGrammars = 1,
    ParsedWorkflows = 2,
    ValidationResults = 3,
    UboCalculations = 4,
    VocabularyLookups = 5,
    All = 6,
}
impl CacheType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CacheType::Unspecified => "CACHE_TYPE_UNSPECIFIED",
            CacheType::ParsedGrammars => "CACHE_TYPE_PARSED_GRAMMARS",
            CacheType::ParsedWorkflows => "CACHE_TYPE_PARSED_WORKFLOWS",
            CacheType::ValidationResults => "CACHE_TYPE_VALIDATION_RESULTS",
            CacheType::UboCalculations => "CACHE_TYPE_UBO_CALCULATIONS",
            CacheType::VocabularyLookups => "CACHE_TYPE_VOCABULARY_LOOKUPS",
            CacheType::All => "CACHE_TYPE_ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CACHE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CACHE_TYPE_PARSED_GRAMMARS" => Some(Self::ParsedGrammars),
            "CACHE_TYPE_PARSED_WORKFLOWS" => Some(Self::ParsedWorkflows),
            "CACHE_TYPE_VALIDATION_RESULTS" => Some(Self::ValidationResults),
            "CACHE_TYPE_UBO_CALCULATIONS" => Some(Self::UboCalculations),
            "CACHE_TYPE_VOCABULARY_LOOKUPS" => Some(Self::VocabularyLookups),
            "CACHE_TYPE_ALL" => Some(Self::All),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
