// @generated
// This file is @generated by prost-build.
/// Entity representation for UBO calculations
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entity {
    #[prost(string, tag="1")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(enumeration="EntityType", tag="2")]
    pub entity_type: i32,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(map="string, message", tag="4")]
    pub properties: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
    #[prost(message, repeated, tag="5")]
    pub incoming_relations: ::prost::alloc::vec::Vec<OwnershipRelation>,
    #[prost(message, repeated, tag="6")]
    pub outgoing_relations: ::prost::alloc::vec::Vec<OwnershipRelation>,
    #[prost(message, optional, tag="7")]
    pub metadata: ::core::option::Option<EntityMetadata>,
    #[prost(message, optional, tag="8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityMetadata {
    #[prost(string, tag="1")]
    pub jurisdiction: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub registration_number: ::prost::alloc::string::String,
    #[prost(string, optional, tag="3")]
    pub tax_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="4")]
    pub regulatory_identifiers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration="EntityStatus", tag="5")]
    pub status: i32,
    #[prost(map="string, string", tag="6")]
    pub custom_fields: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Ownership relationship between entities
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OwnershipRelation {
    #[prost(string, tag="1")]
    pub relation_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub from_entity_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub to_entity_id: ::prost::alloc::string::String,
    #[prost(enumeration="RelationType", tag="4")]
    pub relation_type: i32,
    #[prost(double, tag="5")]
    pub ownership_percentage: f64,
    #[prost(double, tag="6")]
    pub voting_percentage: f64,
    #[prost(enumeration="ControlType", tag="7")]
    pub control_type: i32,
    #[prost(bool, tag="8")]
    pub is_direct: bool,
    #[prost(string, repeated, tag="9")]
    pub evidence_documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="10")]
    pub effective_date: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="11")]
    pub end_date: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map="string, message", tag="12")]
    pub properties: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
}
/// UBO calculation configuration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UboCalculationConfig {
    /// Default 25%
    #[prost(double, tag="1")]
    pub ownership_threshold: f64,
    /// Default 25%
    #[prost(double, tag="2")]
    pub control_threshold: f64,
    /// Default 10
    #[prost(uint32, tag="3")]
    pub max_calculation_depth: u32,
    #[prost(enumeration="UboAlgorithm", tag="4")]
    pub algorithm: i32,
    #[prost(bool, tag="5")]
    pub include_indirect_ownership: bool,
    #[prost(bool, tag="6")]
    pub include_voting_rights: bool,
    #[prost(bool, tag="7")]
    pub stop_at_listed_companies: bool,
    #[prost(string, repeated, tag="8")]
    pub excluded_jurisdictions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map="string, double", tag="9")]
    pub custom_thresholds: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
}
/// Calculate UBO Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateUboRequest {
    #[prost(string, tag="1")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<UboCalculationConfig>,
    #[prost(string, optional, tag="3")]
    pub calculation_context: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag="4")]
    pub include_calculation_path: bool,
    /// For network context
    #[prost(string, repeated, tag="5")]
    pub additional_entity_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateUboResponse {
    #[prost(message, optional, tag="3")]
    pub metrics: ::core::option::Option<UboCalculationMetrics>,
    #[prost(oneof="calculate_ubo_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<calculate_ubo_response::Result>,
}
/// Nested message and enum types in `CalculateUboResponse`.
pub mod calculate_ubo_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        UboResult(super::UboResult),
        #[prost(message, tag="2")]
        Error(super::UboCalculationError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UboResult {
    #[prost(string, tag="1")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="2")]
    pub ubo_persons: ::prost::alloc::vec::Vec<UboPerson>,
    #[prost(message, optional, tag="3")]
    pub ownership_structure: ::core::option::Option<OwnershipStructure>,
    #[prost(message, optional, tag="4")]
    pub config_used: ::core::option::Option<UboCalculationConfig>,
    #[prost(message, optional, tag="5")]
    pub calculated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag="6")]
    pub calculation_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="7")]
    pub calculation_path: ::core::option::Option<CalculationPath>,
    #[prost(message, repeated, tag="8")]
    pub warnings: ::prost::alloc::vec::Vec<UboWarning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UboPerson {
    #[prost(string, tag="1")]
    pub person_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag="3")]
    pub total_ownership_percentage: f64,
    #[prost(double, tag="4")]
    pub total_voting_percentage: f64,
    #[prost(message, repeated, tag="5")]
    pub ownership_paths: ::prost::alloc::vec::Vec<OwnershipPath>,
    #[prost(enumeration="UboClassification", tag="6")]
    pub classification: i32,
    #[prost(enumeration="ControlMechanism", tag="7")]
    pub control_mechanism: i32,
    #[prost(string, repeated, tag="8")]
    pub supporting_documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map="string, message", tag="9")]
    pub person_details: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OwnershipPath {
    #[prost(message, repeated, tag="1")]
    pub segments: ::prost::alloc::vec::Vec<PathSegment>,
    #[prost(double, tag="2")]
    pub path_ownership_percentage: f64,
    #[prost(double, tag="3")]
    pub path_voting_percentage: f64,
    #[prost(enumeration="PathType", tag="4")]
    pub path_type: i32,
    #[prost(uint32, tag="5")]
    pub path_length: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathSegment {
    #[prost(string, tag="1")]
    pub from_entity_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub to_entity_id: ::prost::alloc::string::String,
    #[prost(double, tag="3")]
    pub ownership_percentage: f64,
    #[prost(double, tag="4")]
    pub voting_percentage: f64,
    #[prost(enumeration="RelationType", tag="5")]
    pub relation_type: i32,
    #[prost(string, tag="6")]
    pub relation_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UboCalculationError {
    #[prost(string, tag="1")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="3")]
    pub severity: i32,
    #[prost(string, repeated, tag="4")]
    pub affected_entities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub recovery_suggestion: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UboWarning {
    #[prost(string, tag="1")]
    pub warning_code: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub warning_message: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="3")]
    pub affected_entities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub recommendation: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OwnershipStructure {
    #[prost(string, tag="1")]
    pub root_entity_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="2")]
    pub entities: ::prost::alloc::vec::Vec<Entity>,
    #[prost(message, repeated, tag="3")]
    pub relations: ::prost::alloc::vec::Vec<OwnershipRelation>,
    #[prost(message, optional, tag="4")]
    pub metrics: ::core::option::Option<StructureMetrics>,
    #[prost(message, repeated, tag="5")]
    pub anomalies: ::prost::alloc::vec::Vec<StructureAnomaly>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructureMetrics {
    #[prost(uint32, tag="1")]
    pub total_entities: u32,
    #[prost(uint32, tag="2")]
    pub total_relations: u32,
    #[prost(uint32, tag="3")]
    pub max_ownership_depth: u32,
    #[prost(uint32, tag="4")]
    pub circular_references_count: u32,
    #[prost(double, tag="5")]
    pub network_density: f64,
    #[prost(string, repeated, tag="6")]
    pub jurisdiction_distribution: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructureAnomaly {
    #[prost(enumeration="AnomalyType", tag="1")]
    pub r#type: i32,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="3")]
    pub affected_entities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="4")]
    pub severity: i32,
}
/// Batch calculation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateUboBatchRequest {
    #[prost(string, repeated, tag="1")]
    pub entity_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="2")]
    pub config: ::core::option::Option<UboCalculationConfig>,
    #[prost(string, optional, tag="3")]
    pub batch_context: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag="4")]
    pub parallel_processing: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateUboBatchResponse {
    #[prost(message, repeated, tag="1")]
    pub results: ::prost::alloc::vec::Vec<UboResult>,
    #[prost(message, repeated, tag="2")]
    pub errors: ::prost::alloc::vec::Vec<UboCalculationError>,
    #[prost(message, optional, tag="3")]
    pub batch_metrics: ::core::option::Option<BatchMetrics>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchMetrics {
    #[prost(uint32, tag="1")]
    pub total_entities: u32,
    #[prost(uint32, tag="2")]
    pub successful_calculations: u32,
    #[prost(uint32, tag="3")]
    pub failed_calculations: u32,
    #[prost(message, optional, tag="4")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="5")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="6")]
    pub total_duration_microseconds: u64,
}
/// Streaming calculation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateUboStreamRequest {
    #[prost(oneof="calculate_ubo_stream_request::RequestType", tags="1, 2, 3")]
    pub request_type: ::core::option::Option<calculate_ubo_stream_request::RequestType>,
}
/// Nested message and enum types in `CalculateUboStreamRequest`.
pub mod calculate_ubo_stream_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RequestType {
        #[prost(message, tag="1")]
        Header(super::StreamCalculationHeader),
        #[prost(message, tag="2")]
        EntityBatch(super::StreamEntityBatch),
        #[prost(message, tag="3")]
        Footer(super::StreamCalculationFooter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamCalculationHeader {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<UboCalculationConfig>,
    #[prost(uint32, tag="2")]
    pub expected_entity_count: u32,
    #[prost(string, optional, tag="3")]
    pub stream_context: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamEntityBatch {
    #[prost(string, repeated, tag="1")]
    pub entity_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag="2")]
    pub batch_index: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamCalculationFooter {
    #[prost(string, tag="1")]
    pub checksum: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateUboStreamResponse {
    #[prost(oneof="calculate_ubo_stream_response::ResponseType", tags="1, 2, 3")]
    pub response_type: ::core::option::Option<calculate_ubo_stream_response::ResponseType>,
}
/// Nested message and enum types in `CalculateUboStreamResponse`.
pub mod calculate_ubo_stream_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ResponseType {
        #[prost(message, tag="1")]
        Progress(super::StreamCalculationProgress),
        #[prost(message, tag="2")]
        Result(super::StreamUboResult),
        #[prost(message, tag="3")]
        Error(super::StreamCalculationError),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StreamCalculationProgress {
    #[prost(uint32, tag="1")]
    pub entities_processed: u32,
    #[prost(uint32, tag="2")]
    pub total_entities: u32,
    #[prost(float, tag="3")]
    pub completion_percentage: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamUboResult {
    #[prost(message, optional, tag="1")]
    pub result: ::core::option::Option<UboResult>,
    #[prost(uint32, tag="2")]
    pub result_index: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamCalculationError {
    #[prost(message, optional, tag="1")]
    pub error: ::core::option::Option<UboCalculationError>,
    #[prost(uint32, tag="2")]
    pub error_index: u32,
    #[prost(bool, tag="3")]
    pub is_recoverable: bool,
}
/// UBO History
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUboHistoryRequest {
    #[prost(string, tag="1")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub from_date: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="3")]
    pub to_date: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint32, tag="4")]
    pub limit: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUboHistoryResponse {
    #[prost(message, repeated, tag="1")]
    pub entries: ::prost::alloc::vec::Vec<UboHistoryEntry>,
    #[prost(uint32, tag="2")]
    pub total_count: u32,
    #[prost(string, tag="3")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UboHistoryEntry {
    #[prost(string, tag="1")]
    pub calculation_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub calculated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="3")]
    pub result: ::core::option::Option<UboResult>,
    #[prost(message, optional, tag="4")]
    pub config_used: ::core::option::Option<UboCalculationConfig>,
    #[prost(string, tag="5")]
    pub triggered_by: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="6")]
    pub changes: ::prost::alloc::vec::Vec<UboChange>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UboChange {
    #[prost(enumeration="ChangeType", tag="1")]
    pub change_type: i32,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub previous_value: ::core::option::Option<UboPerson>,
    #[prost(message, optional, tag="4")]
    pub new_value: ::core::option::Option<UboPerson>,
}
/// Ownership Structure Analysis
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeOwnershipRequest {
    #[prost(string, tag="1")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub analysis_config: ::core::option::Option<AnalysisConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnalysisConfig {
    #[prost(bool, tag="1")]
    pub include_risk_assessment: bool,
    #[prost(bool, tag="2")]
    pub include_complexity_analysis: bool,
    #[prost(bool, tag="3")]
    pub include_jurisdiction_analysis: bool,
    #[prost(uint32, tag="4")]
    pub analysis_depth: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalyzeOwnershipResponse {
    #[prost(message, optional, tag="1")]
    pub analysis: ::core::option::Option<OwnershipAnalysis>,
    #[prost(message, optional, tag="2")]
    pub metrics: ::core::option::Option<AnalysisMetrics>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OwnershipAnalysis {
    #[prost(string, tag="1")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub complexity: ::core::option::Option<ComplexityAssessment>,
    #[prost(message, optional, tag="3")]
    pub risk: ::core::option::Option<RiskAssessment>,
    #[prost(message, optional, tag="4")]
    pub jurisdiction: ::core::option::Option<JurisdictionAnalysis>,
    #[prost(message, repeated, tag="5")]
    pub insights: ::prost::alloc::vec::Vec<AnalysisInsight>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ComplexityAssessment {
    #[prost(enumeration="ComplexityLevel", tag="1")]
    pub level: i32,
    #[prost(uint32, tag="2")]
    pub structure_depth: u32,
    #[prost(uint32, tag="3")]
    pub entity_count: u32,
    #[prost(uint32, tag="4")]
    pub relation_count: u32,
    #[prost(double, tag="5")]
    pub complexity_score: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiskAssessment {
    #[prost(enumeration="RiskLevel", tag="1")]
    pub overall_risk: i32,
    #[prost(message, repeated, tag="2")]
    pub risk_factors: ::prost::alloc::vec::Vec<RiskFactor>,
    #[prost(double, tag="3")]
    pub risk_score: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiskFactor {
    #[prost(string, tag="1")]
    pub factor_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(double, tag="3")]
    pub weight: f64,
    #[prost(enumeration="RiskLevel", tag="4")]
    pub level: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JurisdictionAnalysis {
    #[prost(message, repeated, tag="1")]
    pub jurisdictions: ::prost::alloc::vec::Vec<JurisdictionInfo>,
    #[prost(message, repeated, tag="2")]
    pub jurisdiction_risks: ::prost::alloc::vec::Vec<JurisdictionRisk>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JurisdictionInfo {
    #[prost(string, tag="1")]
    pub jurisdiction_code: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub jurisdiction_name: ::prost::alloc::string::String,
    #[prost(uint32, tag="3")]
    pub entity_count: u32,
    #[prost(double, tag="4")]
    pub ownership_percentage: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JurisdictionRisk {
    #[prost(string, tag="1")]
    pub jurisdiction_code: ::prost::alloc::string::String,
    #[prost(enumeration="RiskLevel", tag="2")]
    pub risk_level: i32,
    #[prost(string, repeated, tag="3")]
    pub risk_reasons: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisInsight {
    #[prost(string, tag="1")]
    pub insight_type: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="4")]
    pub importance: i32,
    #[prost(string, repeated, tag="5")]
    pub recommendations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnalysisMetrics {
    #[prost(message, optional, tag="1")]
    pub analysis_duration: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint32, tag="2")]
    pub entities_analyzed: u32,
    #[prost(uint32, tag="3")]
    pub relations_analyzed: u32,
}
/// Validation of UBO rules
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateUboRulesRequest {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<UboCalculationConfig>,
    #[prost(string, optional, tag="2")]
    pub jurisdiction: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateUboRulesResponse {
    #[prost(bool, tag="1")]
    pub is_valid: bool,
    #[prost(message, repeated, tag="2")]
    pub validation_results: ::prost::alloc::vec::Vec<RuleValidationResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleValidationResult {
    #[prost(string, tag="1")]
    pub rule_name: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub is_valid: bool,
    #[prost(string, optional, tag="3")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="4")]
    pub recommendations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// UBO metrics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUboMetricsRequest {
    /// "1h", "24h", "7d", "30d"
    #[prost(string, optional, tag="1")]
    pub time_period: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="2")]
    pub entity_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUboMetricsResponse {
    #[prost(message, optional, tag="1")]
    pub metrics: ::core::option::Option<UboServiceMetrics>,
    #[prost(message, optional, tag="2")]
    pub collected_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UboServiceMetrics {
    #[prost(uint64, tag="1")]
    pub total_calculations: u64,
    #[prost(uint64, tag="2")]
    pub successful_calculations: u64,
    #[prost(uint64, tag="3")]
    pub failed_calculations: u64,
    #[prost(double, tag="4")]
    pub average_calculation_time_ms: f64,
    #[prost(double, tag="5")]
    pub p95_calculation_time_ms: f64,
    #[prost(uint32, tag="6")]
    pub active_calculations: u32,
    #[prost(message, repeated, tag="7")]
    pub algorithm_metrics: ::prost::alloc::vec::Vec<AlgorithmMetrics>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AlgorithmMetrics {
    #[prost(enumeration="UboAlgorithm", tag="1")]
    pub algorithm: i32,
    #[prost(uint64, tag="2")]
    pub usage_count: u64,
    #[prost(double, tag="3")]
    pub average_duration_ms: f64,
    #[prost(double, tag="4")]
    pub success_rate: f64,
}
/// Export UBO results
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportUboResultsRequest {
    #[prost(string, repeated, tag="1")]
    pub calculation_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration="ExportFormat", tag="2")]
    pub format: i32,
    #[prost(message, optional, tag="3")]
    pub options: ::core::option::Option<ExportOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportOptions {
    #[prost(bool, tag="1")]
    pub include_calculation_paths: bool,
    #[prost(bool, tag="2")]
    pub include_supporting_documents: bool,
    #[prost(bool, tag="3")]
    pub include_historical_data: bool,
    #[prost(string, optional, tag="4")]
    pub template_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportUboResultsResponse {
    #[prost(enumeration="ExportFormat", tag="3")]
    pub format: i32,
    #[prost(uint32, tag="4")]
    pub records_exported: u32,
    #[prost(oneof="export_ubo_results_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<export_ubo_results_response::Result>,
}
/// Nested message and enum types in `ExportUboResultsResponse`.
pub mod export_ubo_results_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(bytes, tag="1")]
        ExportedData(::prost::bytes::Bytes),
        #[prost(string, tag="2")]
        ErrorMessage(::prost::alloc::string::String),
    }
}
/// Trace calculation path
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceUboCalculationRequest {
    #[prost(string, tag="1")]
    pub calculation_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag="2")]
    pub entity_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub include_intermediate_steps: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceUboCalculationResponse {
    #[prost(message, optional, tag="1")]
    pub trace: ::core::option::Option<CalculationTrace>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculationTrace {
    #[prost(string, tag="1")]
    pub calculation_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="2")]
    pub steps: ::prost::alloc::vec::Vec<CalculationStep>,
    #[prost(message, optional, tag="3")]
    pub summary: ::core::option::Option<CalculationSummary>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculationStep {
    #[prost(uint32, tag="1")]
    pub step_number: u32,
    #[prost(string, tag="2")]
    pub step_type: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="4")]
    pub input_entities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="5")]
    pub output_entities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="7")]
    pub duration_microseconds: u64,
    #[prost(map="string, message", tag="8")]
    pub step_data: ::std::collections::HashMap<::prost::alloc::string::String, super::dsl::Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CalculationSummary {
    #[prost(message, optional, tag="1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint32, tag="3")]
    pub total_steps: u32,
    #[prost(uint32, tag="4")]
    pub entities_processed: u32,
    #[prost(enumeration="UboAlgorithm", tag="5")]
    pub algorithm_used: i32,
}
/// Update UBO algorithm
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUboAlgorithmRequest {
    #[prost(string, tag="1")]
    pub algorithm_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub definition: ::core::option::Option<AlgorithmDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlgorithmDefinition {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub implementation_code: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub parameters: ::prost::alloc::vec::Vec<AlgorithmParameter>,
    #[prost(message, optional, tag="5")]
    pub metadata: ::core::option::Option<AlgorithmMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlgorithmParameter {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub default_value: ::core::option::Option<super::dsl::Value>,
    #[prost(bool, tag="4")]
    pub is_required: bool,
    #[prost(string, optional, tag="5")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlgorithmMetadata {
    #[prost(string, tag="1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub author: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, repeated, tag="4")]
    pub supported_jurisdictions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUboAlgorithmResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, optional, tag="2")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub previous_version: ::core::option::Option<::prost::alloc::string::String>,
}
/// Shared metrics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UboCalculationMetrics {
    #[prost(message, optional, tag="1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="3")]
    pub duration_microseconds: u64,
    #[prost(uint32, tag="4")]
    pub entities_processed: u32,
    #[prost(uint32, tag="5")]
    pub relations_analyzed: u32,
    #[prost(uint32, tag="6")]
    pub calculation_depth_reached: u32,
    #[prost(uint64, tag="7")]
    pub memory_used_bytes: u64,
    #[prost(uint32, tag="8")]
    pub cache_hits: u32,
    #[prost(uint32, tag="9")]
    pub cache_misses: u32,
}
/// Calculation path for detailed tracing
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculationPath {
    #[prost(message, repeated, tag="1")]
    pub nodes: ::prost::alloc::vec::Vec<CalculationNode>,
    #[prost(message, repeated, tag="2")]
    pub edges: ::prost::alloc::vec::Vec<CalculationEdge>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculationNode {
    #[prost(string, tag="1")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(enumeration="EntityType", tag="2")]
    pub entity_type: i32,
    #[prost(double, tag="3")]
    pub cumulative_ownership: f64,
    #[prost(uint32, tag="4")]
    pub depth_level: u32,
    #[prost(bool, tag="5")]
    pub is_ubo: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculationEdge {
    #[prost(string, tag="1")]
    pub from_entity_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub to_entity_id: ::prost::alloc::string::String,
    #[prost(double, tag="3")]
    pub ownership_percentage: f64,
    #[prost(enumeration="RelationType", tag="4")]
    pub relation_type: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EntityType {
    Unspecified = 0,
    Person = 1,
    Company = 2,
    Trust = 3,
    Foundation = 4,
    Partnership = 5,
    Government = 6,
    Other = 7,
}
impl EntityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EntityType::Unspecified => "ENTITY_TYPE_UNSPECIFIED",
            EntityType::Person => "ENTITY_TYPE_PERSON",
            EntityType::Company => "ENTITY_TYPE_COMPANY",
            EntityType::Trust => "ENTITY_TYPE_TRUST",
            EntityType::Foundation => "ENTITY_TYPE_FOUNDATION",
            EntityType::Partnership => "ENTITY_TYPE_PARTNERSHIP",
            EntityType::Government => "ENTITY_TYPE_GOVERNMENT",
            EntityType::Other => "ENTITY_TYPE_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ENTITY_TYPE_PERSON" => Some(Self::Person),
            "ENTITY_TYPE_COMPANY" => Some(Self::Company),
            "ENTITY_TYPE_TRUST" => Some(Self::Trust),
            "ENTITY_TYPE_FOUNDATION" => Some(Self::Foundation),
            "ENTITY_TYPE_PARTNERSHIP" => Some(Self::Partnership),
            "ENTITY_TYPE_GOVERNMENT" => Some(Self::Government),
            "ENTITY_TYPE_OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EntityStatus {
    Unspecified = 0,
    Active = 1,
    Inactive = 2,
    Dissolved = 3,
    Suspended = 4,
    Pending = 5,
}
impl EntityStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EntityStatus::Unspecified => "ENTITY_STATUS_UNSPECIFIED",
            EntityStatus::Active => "ENTITY_STATUS_ACTIVE",
            EntityStatus::Inactive => "ENTITY_STATUS_INACTIVE",
            EntityStatus::Dissolved => "ENTITY_STATUS_DISSOLVED",
            EntityStatus::Suspended => "ENTITY_STATUS_SUSPENDED",
            EntityStatus::Pending => "ENTITY_STATUS_PENDING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTITY_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ENTITY_STATUS_ACTIVE" => Some(Self::Active),
            "ENTITY_STATUS_INACTIVE" => Some(Self::Inactive),
            "ENTITY_STATUS_DISSOLVED" => Some(Self::Dissolved),
            "ENTITY_STATUS_SUSPENDED" => Some(Self::Suspended),
            "ENTITY_STATUS_PENDING" => Some(Self::Pending),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RelationType {
    Unspecified = 0,
    Ownership = 1,
    Control = 2,
    BeneficialOwnership = 3,
    Management = 4,
    Trusteeship = 5,
    Nominee = 6,
}
impl RelationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RelationType::Unspecified => "RELATION_TYPE_UNSPECIFIED",
            RelationType::Ownership => "RELATION_TYPE_OWNERSHIP",
            RelationType::Control => "RELATION_TYPE_CONTROL",
            RelationType::BeneficialOwnership => "RELATION_TYPE_BENEFICIAL_OWNERSHIP",
            RelationType::Management => "RELATION_TYPE_MANAGEMENT",
            RelationType::Trusteeship => "RELATION_TYPE_TRUSTEESHIP",
            RelationType::Nominee => "RELATION_TYPE_NOMINEE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RELATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RELATION_TYPE_OWNERSHIP" => Some(Self::Ownership),
            "RELATION_TYPE_CONTROL" => Some(Self::Control),
            "RELATION_TYPE_BENEFICIAL_OWNERSHIP" => Some(Self::BeneficialOwnership),
            "RELATION_TYPE_MANAGEMENT" => Some(Self::Management),
            "RELATION_TYPE_TRUSTEESHIP" => Some(Self::Trusteeship),
            "RELATION_TYPE_NOMINEE" => Some(Self::Nominee),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ControlType {
    Unspecified = 0,
    Direct = 1,
    Indirect = 2,
    Joint = 3,
    Ultimate = 4,
    None = 5,
}
impl ControlType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ControlType::Unspecified => "CONTROL_TYPE_UNSPECIFIED",
            ControlType::Direct => "CONTROL_TYPE_DIRECT",
            ControlType::Indirect => "CONTROL_TYPE_INDIRECT",
            ControlType::Joint => "CONTROL_TYPE_JOINT",
            ControlType::Ultimate => "CONTROL_TYPE_ULTIMATE",
            ControlType::None => "CONTROL_TYPE_NONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTROL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CONTROL_TYPE_DIRECT" => Some(Self::Direct),
            "CONTROL_TYPE_INDIRECT" => Some(Self::Indirect),
            "CONTROL_TYPE_JOINT" => Some(Self::Joint),
            "CONTROL_TYPE_ULTIMATE" => Some(Self::Ultimate),
            "CONTROL_TYPE_NONE" => Some(Self::None),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UboAlgorithm {
    Unspecified = 0,
    SimpleThreshold = 1,
    WeightedOwnership = 2,
    ControlBased = 3,
    RegulatoryCompliant = 4,
    Custom = 5,
}
impl UboAlgorithm {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UboAlgorithm::Unspecified => "UBO_ALGORITHM_UNSPECIFIED",
            UboAlgorithm::SimpleThreshold => "UBO_ALGORITHM_SIMPLE_THRESHOLD",
            UboAlgorithm::WeightedOwnership => "UBO_ALGORITHM_WEIGHTED_OWNERSHIP",
            UboAlgorithm::ControlBased => "UBO_ALGORITHM_CONTROL_BASED",
            UboAlgorithm::RegulatoryCompliant => "UBO_ALGORITHM_REGULATORY_COMPLIANT",
            UboAlgorithm::Custom => "UBO_ALGORITHM_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UBO_ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
            "UBO_ALGORITHM_SIMPLE_THRESHOLD" => Some(Self::SimpleThreshold),
            "UBO_ALGORITHM_WEIGHTED_OWNERSHIP" => Some(Self::WeightedOwnership),
            "UBO_ALGORITHM_CONTROL_BASED" => Some(Self::ControlBased),
            "UBO_ALGORITHM_REGULATORY_COMPLIANT" => Some(Self::RegulatoryCompliant),
            "UBO_ALGORITHM_CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PathType {
    Unspecified = 0,
    Direct = 1,
    Indirect = 2,
    ComplexChain = 3,
    Circular = 4,
}
impl PathType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PathType::Unspecified => "PATH_TYPE_UNSPECIFIED",
            PathType::Direct => "PATH_TYPE_DIRECT",
            PathType::Indirect => "PATH_TYPE_INDIRECT",
            PathType::ComplexChain => "PATH_TYPE_COMPLEX_CHAIN",
            PathType::Circular => "PATH_TYPE_CIRCULAR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PATH_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PATH_TYPE_DIRECT" => Some(Self::Direct),
            "PATH_TYPE_INDIRECT" => Some(Self::Indirect),
            "PATH_TYPE_COMPLEX_CHAIN" => Some(Self::ComplexChain),
            "PATH_TYPE_CIRCULAR" => Some(Self::Circular),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UboClassification {
    Unspecified = 0,
    OwnershipBased = 1,
    ControlBased = 2,
    Combined = 3,
    Regulatory = 4,
}
impl UboClassification {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UboClassification::Unspecified => "UBO_CLASSIFICATION_UNSPECIFIED",
            UboClassification::OwnershipBased => "UBO_CLASSIFICATION_OWNERSHIP_BASED",
            UboClassification::ControlBased => "UBO_CLASSIFICATION_CONTROL_BASED",
            UboClassification::Combined => "UBO_CLASSIFICATION_COMBINED",
            UboClassification::Regulatory => "UBO_CLASSIFICATION_REGULATORY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UBO_CLASSIFICATION_UNSPECIFIED" => Some(Self::Unspecified),
            "UBO_CLASSIFICATION_OWNERSHIP_BASED" => Some(Self::OwnershipBased),
            "UBO_CLASSIFICATION_CONTROL_BASED" => Some(Self::ControlBased),
            "UBO_CLASSIFICATION_COMBINED" => Some(Self::Combined),
            "UBO_CLASSIFICATION_REGULATORY" => Some(Self::Regulatory),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ControlMechanism {
    Unspecified = 0,
    OwnershipPercentage = 1,
    VotingRights = 2,
    BoardControl = 3,
    ManagementControl = 4,
    Contractual = 5,
    Other = 6,
}
impl ControlMechanism {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ControlMechanism::Unspecified => "CONTROL_MECHANISM_UNSPECIFIED",
            ControlMechanism::OwnershipPercentage => "CONTROL_MECHANISM_OWNERSHIP_PERCENTAGE",
            ControlMechanism::VotingRights => "CONTROL_MECHANISM_VOTING_RIGHTS",
            ControlMechanism::BoardControl => "CONTROL_MECHANISM_BOARD_CONTROL",
            ControlMechanism::ManagementControl => "CONTROL_MECHANISM_MANAGEMENT_CONTROL",
            ControlMechanism::Contractual => "CONTROL_MECHANISM_CONTRACTUAL",
            ControlMechanism::Other => "CONTROL_MECHANISM_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTROL_MECHANISM_UNSPECIFIED" => Some(Self::Unspecified),
            "CONTROL_MECHANISM_OWNERSHIP_PERCENTAGE" => Some(Self::OwnershipPercentage),
            "CONTROL_MECHANISM_VOTING_RIGHTS" => Some(Self::VotingRights),
            "CONTROL_MECHANISM_BOARD_CONTROL" => Some(Self::BoardControl),
            "CONTROL_MECHANISM_MANAGEMENT_CONTROL" => Some(Self::ManagementControl),
            "CONTROL_MECHANISM_CONTRACTUAL" => Some(Self::Contractual),
            "CONTROL_MECHANISM_OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AnomalyType {
    Unspecified = 0,
    CircularOwnership = 1,
    OrphanedEntity = 2,
    PercentageMismatch = 3,
    JurisdictionInconsistency = 4,
    DateInconsistency = 5,
}
impl AnomalyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AnomalyType::Unspecified => "ANOMALY_TYPE_UNSPECIFIED",
            AnomalyType::CircularOwnership => "ANOMALY_TYPE_CIRCULAR_OWNERSHIP",
            AnomalyType::OrphanedEntity => "ANOMALY_TYPE_ORPHANED_ENTITY",
            AnomalyType::PercentageMismatch => "ANOMALY_TYPE_PERCENTAGE_MISMATCH",
            AnomalyType::JurisdictionInconsistency => "ANOMALY_TYPE_JURISDICTION_INCONSISTENCY",
            AnomalyType::DateInconsistency => "ANOMALY_TYPE_DATE_INCONSISTENCY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANOMALY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ANOMALY_TYPE_CIRCULAR_OWNERSHIP" => Some(Self::CircularOwnership),
            "ANOMALY_TYPE_ORPHANED_ENTITY" => Some(Self::OrphanedEntity),
            "ANOMALY_TYPE_PERCENTAGE_MISMATCH" => Some(Self::PercentageMismatch),
            "ANOMALY_TYPE_JURISDICTION_INCONSISTENCY" => Some(Self::JurisdictionInconsistency),
            "ANOMALY_TYPE_DATE_INCONSISTENCY" => Some(Self::DateInconsistency),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChangeType {
    Unspecified = 0,
    NewUbo = 1,
    RemovedUbo = 2,
    PercentageChange = 3,
    PathChange = 4,
    ClassificationChange = 5,
}
impl ChangeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChangeType::Unspecified => "CHANGE_TYPE_UNSPECIFIED",
            ChangeType::NewUbo => "CHANGE_TYPE_NEW_UBO",
            ChangeType::RemovedUbo => "CHANGE_TYPE_REMOVED_UBO",
            ChangeType::PercentageChange => "CHANGE_TYPE_PERCENTAGE_CHANGE",
            ChangeType::PathChange => "CHANGE_TYPE_PATH_CHANGE",
            ChangeType::ClassificationChange => "CHANGE_TYPE_CLASSIFICATION_CHANGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHANGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CHANGE_TYPE_NEW_UBO" => Some(Self::NewUbo),
            "CHANGE_TYPE_REMOVED_UBO" => Some(Self::RemovedUbo),
            "CHANGE_TYPE_PERCENTAGE_CHANGE" => Some(Self::PercentageChange),
            "CHANGE_TYPE_PATH_CHANGE" => Some(Self::PathChange),
            "CHANGE_TYPE_CLASSIFICATION_CHANGE" => Some(Self::ClassificationChange),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComplexityLevel {
    Unspecified = 0,
    Simple = 1,
    Moderate = 2,
    Complex = 3,
    High = 4,
}
impl ComplexityLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ComplexityLevel::Unspecified => "COMPLEXITY_LEVEL_UNSPECIFIED",
            ComplexityLevel::Simple => "COMPLEXITY_LEVEL_SIMPLE",
            ComplexityLevel::Moderate => "COMPLEXITY_LEVEL_MODERATE",
            ComplexityLevel::Complex => "COMPLEXITY_LEVEL_COMPLEX",
            ComplexityLevel::High => "COMPLEXITY_LEVEL_HIGH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPLEXITY_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "COMPLEXITY_LEVEL_SIMPLE" => Some(Self::Simple),
            "COMPLEXITY_LEVEL_MODERATE" => Some(Self::Moderate),
            "COMPLEXITY_LEVEL_COMPLEX" => Some(Self::Complex),
            "COMPLEXITY_LEVEL_HIGH" => Some(Self::High),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RiskLevel {
    Unspecified = 0,
    Low = 1,
    Medium = 2,
    High = 3,
    Critical = 4,
}
impl RiskLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RiskLevel::Unspecified => "RISK_LEVEL_UNSPECIFIED",
            RiskLevel::Low => "RISK_LEVEL_LOW",
            RiskLevel::Medium => "RISK_LEVEL_MEDIUM",
            RiskLevel::High => "RISK_LEVEL_HIGH",
            RiskLevel::Critical => "RISK_LEVEL_CRITICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RISK_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "RISK_LEVEL_LOW" => Some(Self::Low),
            "RISK_LEVEL_MEDIUM" => Some(Self::Medium),
            "RISK_LEVEL_HIGH" => Some(Self::High),
            "RISK_LEVEL_CRITICAL" => Some(Self::Critical),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExportFormat {
    Unspecified = 0,
    Json = 1,
    Xml = 2,
    Csv = 3,
    Pdf = 4,
    Xlsx = 5,
}
impl ExportFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExportFormat::Unspecified => "EXPORT_FORMAT_UNSPECIFIED",
            ExportFormat::Json => "EXPORT_FORMAT_JSON",
            ExportFormat::Xml => "EXPORT_FORMAT_XML",
            ExportFormat::Csv => "EXPORT_FORMAT_CSV",
            ExportFormat::Pdf => "EXPORT_FORMAT_PDF",
            ExportFormat::Xlsx => "EXPORT_FORMAT_XLSX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXPORT_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "EXPORT_FORMAT_JSON" => Some(Self::Json),
            "EXPORT_FORMAT_XML" => Some(Self::Xml),
            "EXPORT_FORMAT_CSV" => Some(Self::Csv),
            "EXPORT_FORMAT_PDF" => Some(Self::Pdf),
            "EXPORT_FORMAT_XLSX" => Some(Self::Xlsx),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
