// @generated
// This file is @generated by prost-build.
/// Verb definition with full metadata
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbDefinition {
    #[prost(string, tag="1")]
    pub verb_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub signature: ::core::option::Option<VerbSignature>,
    #[prost(enumeration="VerbCategory", tag="5")]
    pub category: i32,
    #[prost(string, repeated, tag="6")]
    pub aliases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="7")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="8")]
    pub metadata: ::core::option::Option<VerbMetadata>,
    #[prost(message, repeated, tag="9")]
    pub examples: ::prost::alloc::vec::Vec<VerbExample>,
    #[prost(message, optional, tag="10")]
    pub validation: ::core::option::Option<VerbValidation>,
    #[prost(message, optional, tag="11")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="12")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbSignature {
    #[prost(message, repeated, tag="1")]
    pub parameters: ::prost::alloc::vec::Vec<Parameter>,
    #[prost(message, optional, tag="2")]
    pub return_type: ::core::option::Option<super::dsl::DslType>,
    #[prost(bool, tag="3")]
    pub is_variadic: bool,
    #[prost(uint32, tag="4")]
    pub min_parameters: u32,
    #[prost(uint32, tag="5")]
    pub max_parameters: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Parameter {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub r#type: ::core::option::Option<super::dsl::DslType>,
    #[prost(bool, tag="3")]
    pub is_required: bool,
    #[prost(message, optional, tag="4")]
    pub default_value: ::core::option::Option<super::dsl::Value>,
    #[prost(string, tag="5")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="6")]
    pub constraints: ::prost::alloc::vec::Vec<super::dsl::TypeConstraint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbMetadata {
    #[prost(string, tag="1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub author: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub documentation_url: ::prost::alloc::string::String,
    #[prost(enumeration="VerbStatus", tag="4")]
    pub status: i32,
    #[prost(message, optional, tag="5")]
    pub deprecation: ::core::option::Option<DeprecationInfo>,
    #[prost(string, repeated, tag="6")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map="string, string", tag="7")]
    pub custom_attributes: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeprecationInfo {
    #[prost(string, tag="1")]
    pub reason: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub deprecated_since: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="3")]
    pub removal_date: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, optional, tag="4")]
    pub replacement_verb: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag="5")]
    pub migration_guide: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbExample {
    #[prost(string, tag="1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub usage_example: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub expected_result: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="5")]
    pub context: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbValidation {
    #[prost(message, repeated, tag="1")]
    pub rules: ::prost::alloc::vec::Vec<ValidationRule>,
    #[prost(string, repeated, tag="2")]
    pub preconditions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="3")]
    pub postconditions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationRule {
    #[prost(string, tag="1")]
    pub rule_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub validation_expression: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="5")]
    pub severity: i32,
}
/// Domain definition and management
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DomainDefinition {
    #[prost(string, tag="1")]
    pub domain_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub metadata: ::core::option::Option<DomainMetadata>,
    #[prost(string, repeated, tag="5")]
    pub verb_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="6")]
    pub policy: ::core::option::Option<DomainPolicy>,
    #[prost(message, optional, tag="7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DomainMetadata {
    #[prost(string, tag="1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="3")]
    pub maintainers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="4")]
    pub documentation_url: ::prost::alloc::string::String,
    #[prost(enumeration="DomainStatus", tag="5")]
    pub status: i32,
    #[prost(map="string, string", tag="6")]
    pub custom_attributes: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DomainPolicy {
    #[prost(message, optional, tag="1")]
    pub naming_policy: ::core::option::Option<VerbNamingPolicy>,
    #[prost(bool, tag="2")]
    pub allow_verb_overrides: bool,
    #[prost(bool, tag="3")]
    pub require_documentation: bool,
    #[prost(string, repeated, tag="4")]
    pub required_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="5")]
    pub deprecation_policy: ::core::option::Option<DeprecationPolicy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbNamingPolicy {
    #[prost(string, tag="1")]
    pub pattern_regex: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="2")]
    pub reserved_prefixes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="3")]
    pub forbidden_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="4")]
    pub enforce_domain_prefix: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeprecationPolicy {
    #[prost(uint32, tag="1")]
    pub min_deprecation_days: u32,
    #[prost(bool, tag="2")]
    pub require_replacement: bool,
    #[prost(bool, tag="3")]
    pub require_migration_guide: bool,
    #[prost(string, repeated, tag="4")]
    pub notification_channels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Register Verb Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterVerbRequest {
    #[prost(message, optional, tag="1")]
    pub verb: ::core::option::Option<VerbDefinition>,
    #[prost(message, optional, tag="2")]
    pub options: ::core::option::Option<RegisterOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegisterOptions {
    #[prost(bool, tag="1")]
    pub validate_before_register: bool,
    #[prost(bool, tag="2")]
    pub overwrite_existing: bool,
    #[prost(bool, tag="3")]
    pub skip_domain_validation: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterVerbResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, optional, tag="2")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub conflict: ::core::option::Option<VerbConflict>,
    #[prost(message, optional, tag="4")]
    pub stats: ::core::option::Option<VerbRegistrationStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbConflict {
    #[prost(string, tag="1")]
    pub conflicting_verb: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub existing_domain: ::prost::alloc::string::String,
    #[prost(enumeration="ConflictResolution", tag="3")]
    pub suggested_resolution: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbRegistrationStats {
    #[prost(message, optional, tag="1")]
    pub registration_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag="2")]
    pub registered_by: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub registration_id: ::prost::alloc::string::String,
}
/// Update Verb Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateVerbRequest {
    #[prost(string, tag="1")]
    pub verb_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub updated_verb: ::core::option::Option<VerbDefinition>,
    #[prost(message, optional, tag="4")]
    pub options: ::core::option::Option<UpdateOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateOptions {
    #[prost(bool, tag="1")]
    pub validate_before_update: bool,
    #[prost(bool, tag="2")]
    pub create_backup: bool,
    #[prost(bool, tag="3")]
    pub notify_dependents: bool,
    #[prost(enumeration="VersioningStrategy", tag="4")]
    pub versioning: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateVerbResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, optional, tag="2")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub backup_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag="4")]
    pub previous_version: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub new_version: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="6")]
    pub affected_dependents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Remove Verb Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveVerbRequest {
    #[prost(string, tag="1")]
    pub verb_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub options: ::core::option::Option<RemovalOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemovalOptions {
    #[prost(bool, tag="1")]
    pub force_removal: bool,
    #[prost(bool, tag="2")]
    pub check_dependencies: bool,
    #[prost(bool, tag="3")]
    pub create_backup: bool,
    #[prost(message, optional, tag="4")]
    pub scheduled_removal: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveVerbResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, optional, tag="2")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="3")]
    pub blocking_dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub backup_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Get Verb Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVerbRequest {
    #[prost(string, tag="1")]
    pub verb_name: ::prost::alloc::string::String,
    #[prost(string, optional, tag="2")]
    pub domain: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub include_examples: bool,
    #[prost(bool, tag="4")]
    pub include_dependencies: bool,
    #[prost(string, optional, tag="5")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVerbResponse {
    #[prost(message, repeated, tag="3")]
    pub related_verbs: ::prost::alloc::vec::Vec<VerbDefinition>,
    #[prost(message, optional, tag="4")]
    pub usage_stats: ::core::option::Option<VerbUsageStats>,
    #[prost(oneof="get_verb_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<get_verb_response::Result>,
}
/// Nested message and enum types in `GetVerbResponse`.
pub mod get_verb_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Verb(super::VerbDefinition),
        #[prost(string, tag="2")]
        ErrorMessage(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbUsageStats {
    #[prost(uint64, tag="1")]
    pub total_usage_count: u64,
    #[prost(uint64, tag="2")]
    pub recent_usage_count: u64,
    #[prost(message, optional, tag="3")]
    pub last_used: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag="4")]
    pub usage_contexts: ::prost::alloc::vec::Vec<UsageContext>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsageContext {
    #[prost(string, tag="1")]
    pub context_name: ::prost::alloc::string::String,
    #[prost(uint64, tag="2")]
    pub usage_count: u64,
    #[prost(message, optional, tag="3")]
    pub last_used: ::core::option::Option<::prost_types::Timestamp>,
}
/// List Verbs Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVerbsRequest {
    #[prost(string, optional, tag="1")]
    pub domain: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="2")]
    pub filter: ::core::option::Option<VerbFilter>,
    #[prost(message, optional, tag="3")]
    pub sort: ::core::option::Option<SortOptions>,
    #[prost(message, optional, tag="4")]
    pub pagination: ::core::option::Option<PaginationOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbFilter {
    #[prost(enumeration="VerbCategory", repeated, tag="1")]
    pub categories: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration="VerbStatus", repeated, tag="2")]
    pub statuses: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag="3")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub name_pattern: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="5")]
    pub created_after: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="6")]
    pub updated_after: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SortOptions {
    #[prost(enumeration="SortField", tag="1")]
    pub sort_by: i32,
    #[prost(enumeration="SortOrder", tag="2")]
    pub order: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaginationOptions {
    #[prost(uint32, tag="1")]
    pub page_size: u32,
    #[prost(string, tag="2")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVerbsResponse {
    #[prost(message, repeated, tag="1")]
    pub verbs: ::prost::alloc::vec::Vec<VerbDefinition>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(uint32, tag="3")]
    pub total_count: u32,
    #[prost(message, optional, tag="4")]
    pub stats: ::core::option::Option<ListingStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListingStats {
    #[prost(uint32, tag="1")]
    pub active_verbs: u32,
    #[prost(uint32, tag="2")]
    pub deprecated_verbs: u32,
    #[prost(uint32, tag="3")]
    pub experimental_verbs: u32,
    #[prost(map="string, uint32", tag="4")]
    pub category_counts: ::std::collections::HashMap<::prost::alloc::string::String, u32>,
}
/// Search Verbs Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchVerbsRequest {
    #[prost(string, tag="1")]
    pub query: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub options: ::core::option::Option<SearchOptions>,
    #[prost(string, repeated, tag="3")]
    pub domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag="4")]
    pub max_results: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchOptions {
    #[prost(bool, tag="1")]
    pub fuzzy_matching: bool,
    #[prost(bool, tag="2")]
    pub include_aliases: bool,
    #[prost(bool, tag="3")]
    pub include_descriptions: bool,
    #[prost(bool, tag="4")]
    pub include_examples: bool,
    #[prost(float, tag="5")]
    pub similarity_threshold: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchVerbsResponse {
    #[prost(message, repeated, tag="1")]
    pub results: ::prost::alloc::vec::Vec<SearchResult>,
    #[prost(message, optional, tag="2")]
    pub search_stats: ::core::option::Option<SearchStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    #[prost(message, optional, tag="1")]
    pub verb: ::core::option::Option<VerbDefinition>,
    #[prost(float, tag="2")]
    pub relevance_score: f32,
    #[prost(string, repeated, tag="3")]
    pub matched_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="4")]
    pub match_explanation: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchStats {
    #[prost(uint32, tag="1")]
    pub total_results: u32,
    #[prost(message, optional, tag="2")]
    pub search_duration: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, repeated, tag="3")]
    pub searched_domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Validate Verb Usage Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateVerbUsageRequest {
    #[prost(string, tag="1")]
    pub verb_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="3")]
    pub arguments: ::prost::alloc::vec::Vec<super::dsl::Value>,
    #[prost(message, optional, tag="4")]
    pub usage_context: ::core::option::Option<UsageContext>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateVerbUsageResponse {
    #[prost(bool, tag="1")]
    pub is_valid: bool,
    #[prost(message, repeated, tag="2")]
    pub errors: ::prost::alloc::vec::Vec<super::dsl::ValidationError>,
    #[prost(message, repeated, tag="3")]
    pub warnings: ::prost::alloc::vec::Vec<super::dsl::ValidationWarning>,
    #[prost(string, repeated, tag="4")]
    pub suggestions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Register Domain Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterDomainRequest {
    #[prost(message, optional, tag="1")]
    pub domain: ::core::option::Option<DomainDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterDomainResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, optional, tag="2")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
}
/// List Domains Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDomainsRequest {
    #[prost(message, optional, tag="1")]
    pub filter: ::core::option::Option<DomainFilter>,
    #[prost(message, optional, tag="2")]
    pub sort: ::core::option::Option<SortOptions>,
    #[prost(message, optional, tag="3")]
    pub pagination: ::core::option::Option<PaginationOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DomainFilter {
    #[prost(enumeration="DomainStatus", repeated, tag="1")]
    pub statuses: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, optional, tag="2")]
    pub name_pattern: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDomainsResponse {
    #[prost(message, repeated, tag="1")]
    pub domains: ::prost::alloc::vec::Vec<DomainDefinition>,
    #[prost(string, tag="2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(uint32, tag="3")]
    pub total_count: u32,
}
/// Get Domain Info Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDomainInfoRequest {
    #[prost(string, tag="1")]
    pub domain_name: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub include_verb_list: bool,
    #[prost(bool, tag="3")]
    pub include_stats: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDomainInfoResponse {
    #[prost(oneof="get_domain_info_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<get_domain_info_response::Result>,
}
/// Nested message and enum types in `GetDomainInfoResponse`.
pub mod get_domain_info_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Info(super::DomainInfo),
        #[prost(string, tag="2")]
        ErrorMessage(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DomainInfo {
    #[prost(message, optional, tag="1")]
    pub domain: ::core::option::Option<DomainDefinition>,
    #[prost(message, optional, tag="2")]
    pub stats: ::core::option::Option<DomainStats>,
    #[prost(string, repeated, tag="3")]
    pub recent_verbs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DomainStats {
    #[prost(uint32, tag="1")]
    pub total_verbs: u32,
    #[prost(uint32, tag="2")]
    pub active_verbs: u32,
    #[prost(uint32, tag="3")]
    pub deprecated_verbs: u32,
    #[prost(message, optional, tag="4")]
    pub last_activity: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(uint64, tag="5")]
    pub total_usage: u64,
}
/// Migrate Verbs Request/Response
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateVerbsRequest {
    #[prost(string, tag="1")]
    pub source_domain: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub target_domain: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="3")]
    pub verb_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="4")]
    pub options: ::core::option::Option<MigrationOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MigrationOptions {
    #[prost(bool, tag="1")]
    pub preserve_source: bool,
    #[prost(bool, tag="2")]
    pub update_references: bool,
    #[prost(bool, tag="3")]
    pub validate_target_domain: bool,
    #[prost(enumeration="ConflictResolution", tag="4")]
    pub conflict_resolution: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateVerbsResponse {
    #[prost(uint32, tag="1")]
    pub migrated_count: u32,
    #[prost(message, repeated, tag="2")]
    pub results: ::prost::alloc::vec::Vec<MigrationResult>,
    #[prost(string, repeated, tag="3")]
    pub migration_warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrationResult {
    #[prost(string, tag="1")]
    pub verb_name: ::prost::alloc::string::String,
    #[prost(bool, tag="2")]
    pub success: bool,
    #[prost(string, optional, tag="3")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub new_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Export/Import Vocabulary
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportVocabularyRequest {
    #[prost(string, repeated, tag="1")]
    pub domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration="ExportFormat", tag="2")]
    pub format: i32,
    #[prost(message, optional, tag="3")]
    pub options: ::core::option::Option<ExportOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportOptions {
    #[prost(bool, tag="1")]
    pub include_examples: bool,
    #[prost(bool, tag="2")]
    pub include_metadata: bool,
    #[prost(bool, tag="3")]
    pub include_deprecated: bool,
    #[prost(bool, tag="4")]
    pub minify_output: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportVocabularyResponse {
    #[prost(enumeration="ExportFormat", tag="3")]
    pub format: i32,
    #[prost(message, optional, tag="4")]
    pub stats: ::core::option::Option<ExportStats>,
    #[prost(oneof="export_vocabulary_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<export_vocabulary_response::Result>,
}
/// Nested message and enum types in `ExportVocabularyResponse`.
pub mod export_vocabulary_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(bytes, tag="1")]
        ExportedData(::prost::bytes::Bytes),
        #[prost(string, tag="2")]
        ErrorMessage(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportStats {
    #[prost(uint32, tag="1")]
    pub domains_exported: u32,
    #[prost(uint32, tag="2")]
    pub verbs_exported: u32,
    #[prost(uint32, tag="3")]
    pub file_size_bytes: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportVocabularyRequest {
    #[prost(bytes="bytes", tag="1")]
    pub vocabulary_data: ::prost::bytes::Bytes,
    #[prost(enumeration="ExportFormat", tag="2")]
    pub format: i32,
    #[prost(message, optional, tag="3")]
    pub options: ::core::option::Option<ImportOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportOptions {
    #[prost(bool, tag="1")]
    pub validate_before_import: bool,
    #[prost(bool, tag="2")]
    pub overwrite_existing: bool,
    #[prost(bool, tag="3")]
    pub skip_deprecated: bool,
    #[prost(enumeration="ConflictResolution", tag="4")]
    pub conflict_resolution: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportVocabularyResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, repeated, tag="2")]
    pub error_messages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="3")]
    pub stats: ::core::option::Option<ImportStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportStats {
    #[prost(uint32, tag="1")]
    pub domains_imported: u32,
    #[prost(uint32, tag="2")]
    pub verbs_imported: u32,
    #[prost(uint32, tag="3")]
    pub conflicts_resolved: u32,
    #[prost(uint32, tag="4")]
    pub errors_encountered: u32,
}
/// Vocabulary Statistics
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVocabularyStatsRequest {
    /// "1h", "24h", "7d", "30d"
    #[prost(string, optional, tag="1")]
    pub time_period: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="2")]
    pub domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVocabularyStatsResponse {
    #[prost(message, optional, tag="1")]
    pub stats: ::core::option::Option<VocabularyStats>,
    #[prost(message, optional, tag="2")]
    pub collected_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VocabularyStats {
    #[prost(uint32, tag="1")]
    pub total_domains: u32,
    #[prost(uint32, tag="2")]
    pub total_verbs: u32,
    #[prost(uint64, tag="3")]
    pub total_usage: u64,
    #[prost(message, repeated, tag="4")]
    pub top_verbs: ::prost::alloc::vec::Vec<TopVerb>,
    #[prost(message, repeated, tag="5")]
    pub domain_usage: ::prost::alloc::vec::Vec<DomainUsage>,
    #[prost(message, optional, tag="6")]
    pub category_breakdown: ::core::option::Option<CategoryBreakdown>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopVerb {
    #[prost(string, tag="1")]
    pub verb_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub domain: ::prost::alloc::string::String,
    #[prost(uint64, tag="3")]
    pub usage_count: u64,
    #[prost(float, tag="4")]
    pub usage_percentage: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DomainUsage {
    #[prost(string, tag="1")]
    pub domain_name: ::prost::alloc::string::String,
    #[prost(uint32, tag="2")]
    pub verb_count: u32,
    #[prost(uint64, tag="3")]
    pub total_usage: u64,
    #[prost(float, tag="4")]
    pub usage_percentage: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CategoryBreakdown {
    #[prost(map="string, uint32", tag="1")]
    pub category_counts: ::std::collections::HashMap<::prost::alloc::string::String, u32>,
    #[prost(map="string, uint64", tag="2")]
    pub category_usage: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
}
/// Consistency Validation
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateVocabularyConsistencyRequest {
    #[prost(string, repeated, tag="1")]
    pub domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag="2")]
    pub options: ::core::option::Option<ConsistencyCheckOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConsistencyCheckOptions {
    #[prost(bool, tag="1")]
    pub check_naming_conventions: bool,
    #[prost(bool, tag="2")]
    pub check_dependencies: bool,
    #[prost(bool, tag="3")]
    pub check_duplicates: bool,
    #[prost(bool, tag="4")]
    pub check_circular_references: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateVocabularyConsistencyResponse {
    #[prost(bool, tag="1")]
    pub is_consistent: bool,
    #[prost(message, repeated, tag="2")]
    pub issues: ::prost::alloc::vec::Vec<ConsistencyIssue>,
    #[prost(message, optional, tag="3")]
    pub stats: ::core::option::Option<ConsistencyStats>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsistencyIssue {
    #[prost(enumeration="IssueType", tag="1")]
    pub r#type: i32,
    #[prost(enumeration="super::dsl::ErrorSeverity", tag="2")]
    pub severity: i32,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="4")]
    pub affected_items: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="5")]
    pub recommendations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConsistencyStats {
    #[prost(uint32, tag="1")]
    pub total_checks: u32,
    #[prost(uint32, tag="2")]
    pub passed_checks: u32,
    #[prost(uint32, tag="3")]
    pub failed_checks: u32,
    #[prost(uint32, tag="4")]
    pub warnings: u32,
    #[prost(message, optional, tag="5")]
    pub check_duration: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VerbCategory {
    Unspecified = 0,
    EntityManagement = 1,
    Relationship = 2,
    Calculation = 3,
    Validation = 4,
    WorkflowControl = 5,
    DataManipulation = 6,
    Reporting = 7,
    Integration = 8,
    Custom = 9,
}
impl VerbCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VerbCategory::Unspecified => "VERB_CATEGORY_UNSPECIFIED",
            VerbCategory::EntityManagement => "VERB_CATEGORY_ENTITY_MANAGEMENT",
            VerbCategory::Relationship => "VERB_CATEGORY_RELATIONSHIP",
            VerbCategory::Calculation => "VERB_CATEGORY_CALCULATION",
            VerbCategory::Validation => "VERB_CATEGORY_VALIDATION",
            VerbCategory::WorkflowControl => "VERB_CATEGORY_WORKFLOW_CONTROL",
            VerbCategory::DataManipulation => "VERB_CATEGORY_DATA_MANIPULATION",
            VerbCategory::Reporting => "VERB_CATEGORY_REPORTING",
            VerbCategory::Integration => "VERB_CATEGORY_INTEGRATION",
            VerbCategory::Custom => "VERB_CATEGORY_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERB_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "VERB_CATEGORY_ENTITY_MANAGEMENT" => Some(Self::EntityManagement),
            "VERB_CATEGORY_RELATIONSHIP" => Some(Self::Relationship),
            "VERB_CATEGORY_CALCULATION" => Some(Self::Calculation),
            "VERB_CATEGORY_VALIDATION" => Some(Self::Validation),
            "VERB_CATEGORY_WORKFLOW_CONTROL" => Some(Self::WorkflowControl),
            "VERB_CATEGORY_DATA_MANIPULATION" => Some(Self::DataManipulation),
            "VERB_CATEGORY_REPORTING" => Some(Self::Reporting),
            "VERB_CATEGORY_INTEGRATION" => Some(Self::Integration),
            "VERB_CATEGORY_CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VerbStatus {
    Unspecified = 0,
    Active = 1,
    Deprecated = 2,
    Experimental = 3,
    Internal = 4,
}
impl VerbStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VerbStatus::Unspecified => "VERB_STATUS_UNSPECIFIED",
            VerbStatus::Active => "VERB_STATUS_ACTIVE",
            VerbStatus::Deprecated => "VERB_STATUS_DEPRECATED",
            VerbStatus::Experimental => "VERB_STATUS_EXPERIMENTAL",
            VerbStatus::Internal => "VERB_STATUS_INTERNAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERB_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "VERB_STATUS_ACTIVE" => Some(Self::Active),
            "VERB_STATUS_DEPRECATED" => Some(Self::Deprecated),
            "VERB_STATUS_EXPERIMENTAL" => Some(Self::Experimental),
            "VERB_STATUS_INTERNAL" => Some(Self::Internal),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DomainStatus {
    Unspecified = 0,
    Active = 1,
    Deprecated = 2,
    Experimental = 3,
    Archived = 4,
}
impl DomainStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DomainStatus::Unspecified => "DOMAIN_STATUS_UNSPECIFIED",
            DomainStatus::Active => "DOMAIN_STATUS_ACTIVE",
            DomainStatus::Deprecated => "DOMAIN_STATUS_DEPRECATED",
            DomainStatus::Experimental => "DOMAIN_STATUS_EXPERIMENTAL",
            DomainStatus::Archived => "DOMAIN_STATUS_ARCHIVED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DOMAIN_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "DOMAIN_STATUS_ACTIVE" => Some(Self::Active),
            "DOMAIN_STATUS_DEPRECATED" => Some(Self::Deprecated),
            "DOMAIN_STATUS_EXPERIMENTAL" => Some(Self::Experimental),
            "DOMAIN_STATUS_ARCHIVED" => Some(Self::Archived),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConflictResolution {
    Unspecified = 0,
    UseNamespace = 1,
    RenameVerb = 2,
    Override = 3,
    Merge = 4,
}
impl ConflictResolution {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ConflictResolution::Unspecified => "CONFLICT_RESOLUTION_UNSPECIFIED",
            ConflictResolution::UseNamespace => "CONFLICT_RESOLUTION_USE_NAMESPACE",
            ConflictResolution::RenameVerb => "CONFLICT_RESOLUTION_RENAME_VERB",
            ConflictResolution::Override => "CONFLICT_RESOLUTION_OVERRIDE",
            ConflictResolution::Merge => "CONFLICT_RESOLUTION_MERGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONFLICT_RESOLUTION_UNSPECIFIED" => Some(Self::Unspecified),
            "CONFLICT_RESOLUTION_USE_NAMESPACE" => Some(Self::UseNamespace),
            "CONFLICT_RESOLUTION_RENAME_VERB" => Some(Self::RenameVerb),
            "CONFLICT_RESOLUTION_OVERRIDE" => Some(Self::Override),
            "CONFLICT_RESOLUTION_MERGE" => Some(Self::Merge),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VersioningStrategy {
    Unspecified = 0,
    Patch = 1,
    Minor = 2,
    Major = 3,
    Custom = 4,
}
impl VersioningStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VersioningStrategy::Unspecified => "VERSIONING_STRATEGY_UNSPECIFIED",
            VersioningStrategy::Patch => "VERSIONING_STRATEGY_PATCH",
            VersioningStrategy::Minor => "VERSIONING_STRATEGY_MINOR",
            VersioningStrategy::Major => "VERSIONING_STRATEGY_MAJOR",
            VersioningStrategy::Custom => "VERSIONING_STRATEGY_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERSIONING_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
            "VERSIONING_STRATEGY_PATCH" => Some(Self::Patch),
            "VERSIONING_STRATEGY_MINOR" => Some(Self::Minor),
            "VERSIONING_STRATEGY_MAJOR" => Some(Self::Major),
            "VERSIONING_STRATEGY_CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SortField {
    Unspecified = 0,
    Name = 1,
    Domain = 2,
    CreatedAt = 3,
    UpdatedAt = 4,
    UsageCount = 5,
}
impl SortField {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SortField::Unspecified => "SORT_FIELD_UNSPECIFIED",
            SortField::Name => "SORT_FIELD_NAME",
            SortField::Domain => "SORT_FIELD_DOMAIN",
            SortField::CreatedAt => "SORT_FIELD_CREATED_AT",
            SortField::UpdatedAt => "SORT_FIELD_UPDATED_AT",
            SortField::UsageCount => "SORT_FIELD_USAGE_COUNT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SORT_FIELD_UNSPECIFIED" => Some(Self::Unspecified),
            "SORT_FIELD_NAME" => Some(Self::Name),
            "SORT_FIELD_DOMAIN" => Some(Self::Domain),
            "SORT_FIELD_CREATED_AT" => Some(Self::CreatedAt),
            "SORT_FIELD_UPDATED_AT" => Some(Self::UpdatedAt),
            "SORT_FIELD_USAGE_COUNT" => Some(Self::UsageCount),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SortOrder {
    Unspecified = 0,
    Asc = 1,
    Desc = 2,
}
impl SortOrder {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SortOrder::Unspecified => "SORT_ORDER_UNSPECIFIED",
            SortOrder::Asc => "SORT_ORDER_ASC",
            SortOrder::Desc => "SORT_ORDER_DESC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SORT_ORDER_UNSPECIFIED" => Some(Self::Unspecified),
            "SORT_ORDER_ASC" => Some(Self::Asc),
            "SORT_ORDER_DESC" => Some(Self::Desc),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExportFormat {
    Unspecified = 0,
    Json = 1,
    Yaml = 2,
    Xml = 3,
    Protobuf = 4,
    Openapi = 5,
}
impl ExportFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExportFormat::Unspecified => "EXPORT_FORMAT_UNSPECIFIED",
            ExportFormat::Json => "EXPORT_FORMAT_JSON",
            ExportFormat::Yaml => "EXPORT_FORMAT_YAML",
            ExportFormat::Xml => "EXPORT_FORMAT_XML",
            ExportFormat::Protobuf => "EXPORT_FORMAT_PROTOBUF",
            ExportFormat::Openapi => "EXPORT_FORMAT_OPENAPI",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXPORT_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "EXPORT_FORMAT_JSON" => Some(Self::Json),
            "EXPORT_FORMAT_YAML" => Some(Self::Yaml),
            "EXPORT_FORMAT_XML" => Some(Self::Xml),
            "EXPORT_FORMAT_PROTOBUF" => Some(Self::Protobuf),
            "EXPORT_FORMAT_OPENAPI" => Some(Self::Openapi),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IssueType {
    Unspecified = 0,
    NamingViolation = 1,
    DuplicateVerb = 2,
    MissingDependency = 3,
    CircularReference = 4,
    DeprecatedUsage = 5,
}
impl IssueType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            IssueType::Unspecified => "ISSUE_TYPE_UNSPECIFIED",
            IssueType::NamingViolation => "ISSUE_TYPE_NAMING_VIOLATION",
            IssueType::DuplicateVerb => "ISSUE_TYPE_DUPLICATE_VERB",
            IssueType::MissingDependency => "ISSUE_TYPE_MISSING_DEPENDENCY",
            IssueType::CircularReference => "ISSUE_TYPE_CIRCULAR_REFERENCE",
            IssueType::DeprecatedUsage => "ISSUE_TYPE_DEPRECATED_USAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ISSUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ISSUE_TYPE_NAMING_VIOLATION" => Some(Self::NamingViolation),
            "ISSUE_TYPE_DUPLICATE_VERB" => Some(Self::DuplicateVerb),
            "ISSUE_TYPE_MISSING_DEPENDENCY" => Some(Self::MissingDependency),
            "ISSUE_TYPE_CIRCULAR_REFERENCE" => Some(Self::CircularReference),
            "ISSUE_TYPE_DEPRECATED_USAGE" => Some(Self::DeprecatedUsage),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
