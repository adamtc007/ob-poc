// @generated
// This file is @generated by prost-build.
/// Core DSL value types
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof="value::ValueType", tags="1, 2, 3, 4, 5, 6, 7, 8")]
    pub value_type: ::core::option::Option<value::ValueType>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ValueType {
        #[prost(string, tag="1")]
        StringValue(::prost::alloc::string::String),
        #[prost(double, tag="2")]
        NumberValue(f64),
        #[prost(int64, tag="3")]
        IntegerValue(i64),
        #[prost(bool, tag="4")]
        BooleanValue(bool),
        #[prost(message, tag="5")]
        ListValue(super::ValueList),
        #[prost(message, tag="6")]
        MapValue(super::ValueMap),
        #[prost(message, tag="7")]
        DatetimeValue(::prost_types::Timestamp),
        /// UUID as string
        #[prost(string, tag="8")]
        UuidValue(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueList {
    #[prost(message, repeated, tag="1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValueMap {
    #[prost(map="string, message", tag="1")]
    pub values: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
}
/// Property map for workflow and statement properties
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropertyMap {
    #[prost(map="string, message", tag="1")]
    pub properties: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
}
/// Source location information for error reporting
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceLocation {
    #[prost(uint32, tag="1")]
    pub line: u32,
    #[prost(uint32, tag="2")]
    pub column: u32,
    #[prost(string, optional, tag="3")]
    pub file: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="4")]
    pub span: ::core::option::Option<SourceSpan>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SourceSpan {
    #[prost(uint32, tag="1")]
    pub start: u32,
    #[prost(uint32, tag="2")]
    pub end: u32,
}
/// DSL type system
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DslType {
    #[prost(bool, tag="13")]
    pub nullable: bool,
    #[prost(oneof="dsl_type::TypeDef", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12")]
    pub type_def: ::core::option::Option<dsl_type::TypeDef>,
}
/// Nested message and enum types in `DSLType`.
pub mod dsl_type {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TypeDef {
        #[prost(message, tag="1")]
        StringType(super::StringType),
        #[prost(message, tag="2")]
        NumberType(super::NumberType),
        #[prost(message, tag="3")]
        IntegerType(super::IntegerType),
        #[prost(message, tag="4")]
        BooleanType(super::BooleanType),
        #[prost(message, tag="5")]
        DatetimeType(super::DateTimeType),
        #[prost(message, tag="6")]
        UuidType(super::UuidType),
        #[prost(message, tag="7")]
        EntityReferenceType(super::EntityReferenceType),
        #[prost(message, tag="8")]
        VocabularyVerbType(super::VocabularyVerbType),
        #[prost(message, tag="9")]
        ListType(::prost::alloc::boxed::Box<super::ListType>),
        #[prost(message, tag="10")]
        MapType(::prost::alloc::boxed::Box<super::MapType>),
        #[prost(message, tag="11")]
        UnionType(super::UnionType),
        #[prost(message, tag="12")]
        CustomType(super::CustomType),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringType {
    #[prost(uint32, optional, tag="1")]
    pub max_length: ::core::option::Option<u32>,
    /// enum-like constraints
    #[prost(string, repeated, tag="2")]
    pub allowed_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NumberType {
    #[prost(double, optional, tag="1")]
    pub min_value: ::core::option::Option<f64>,
    #[prost(double, optional, tag="2")]
    pub max_value: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IntegerType {
    #[prost(int64, optional, tag="1")]
    pub min_value: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="2")]
    pub max_value: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BooleanType {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateTimeType {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UuidType {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityReferenceType {
    #[prost(string, tag="1")]
    pub entity_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VocabularyVerbType {
    #[prost(string, tag="1")]
    pub domain: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListType {
    #[prost(message, optional, boxed, tag="1")]
    pub element_type: ::core::option::Option<::prost::alloc::boxed::Box<DslType>>,
    #[prost(uint32, optional, tag="2")]
    pub min_length: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub max_length: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapType {
    #[prost(message, optional, boxed, tag="1")]
    pub value_type: ::core::option::Option<::prost::alloc::boxed::Box<DslType>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnionType {
    #[prost(message, repeated, tag="1")]
    pub types: ::prost::alloc::vec::Vec<DslType>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomType {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    #[prost(map="string, message", tag="2")]
    pub schema: ::std::collections::HashMap<::prost::alloc::string::String, DslType>,
}
/// Type constraints
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeConstraint {
    #[prost(oneof="type_constraint::ConstraintType", tags="1, 2, 3, 4, 5, 6")]
    pub constraint_type: ::core::option::Option<type_constraint::ConstraintType>,
}
/// Nested message and enum types in `TypeConstraint`.
pub mod type_constraint {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConstraintType {
        #[prost(message, tag="1")]
        Required(super::RequiredConstraint),
        #[prost(message, tag="2")]
        Unique(super::UniqueConstraint),
        #[prost(message, tag="3")]
        Length(super::LengthConstraint),
        #[prost(message, tag="4")]
        Pattern(super::PatternConstraint),
        #[prost(message, tag="5")]
        Set(super::SetConstraint),
        #[prost(message, tag="6")]
        Custom(super::CustomConstraint),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequiredConstraint {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UniqueConstraint {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LengthConstraint {
    #[prost(uint32, optional, tag="1")]
    pub min_length: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub max_length: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatternConstraint {
    #[prost(string, tag="1")]
    pub regex_pattern: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetConstraint {
    #[prost(string, repeated, tag="1")]
    pub allowed_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomConstraint {
    #[prost(string, tag="1")]
    pub validator_name: ::prost::alloc::string::String,
    #[prost(map="string, message", tag="2")]
    pub parameters: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
}
/// Type information with semantic analysis
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeInfo {
    #[prost(message, optional, tag="1")]
    pub expected_type: ::core::option::Option<DslType>,
    #[prost(message, optional, tag="2")]
    pub inferred_type: ::core::option::Option<DslType>,
    #[prost(message, repeated, tag="3")]
    pub constraints: ::prost::alloc::vec::Vec<TypeConstraint>,
    #[prost(bool, tag="4")]
    pub nullable: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationError {
    #[prost(string, tag="1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    #[prost(enumeration="ErrorSeverity", tag="3")]
    pub severity: i32,
    #[prost(message, optional, tag="4")]
    pub location: ::core::option::Option<SourceLocation>,
    #[prost(map="string, string", tag="5")]
    pub context: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationWarning {
    #[prost(string, tag="1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub location: ::core::option::Option<SourceLocation>,
    #[prost(map="string, string", tag="4")]
    pub context: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Database integration
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseReference {
    #[prost(string, tag="1")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub column_name: ::prost::alloc::string::String,
    #[prost(string, optional, tag="3")]
    pub database_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub schema_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration="DatabaseReferenceType", tag="5")]
    pub reference_type: i32,
}
/// Semantic information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SemanticInfo {
    #[prost(message, optional, tag="1")]
    pub source_location: ::core::option::Option<SourceLocation>,
    #[prost(message, optional, tag="2")]
    pub type_info: ::core::option::Option<TypeInfo>,
    #[prost(enumeration="ValidationState", tag="3")]
    pub validation_state: i32,
    #[prost(string, repeated, tag="4")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="5")]
    pub database_refs: ::prost::alloc::vec::Vec<DatabaseReference>,
    #[prost(message, repeated, tag="6")]
    pub validation_errors: ::prost::alloc::vec::Vec<ValidationError>,
    #[prost(message, repeated, tag="7")]
    pub validation_warnings: ::prost::alloc::vec::Vec<ValidationWarning>,
}
/// AST Statement types
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Statement {
    #[prost(message, optional, tag="6")]
    pub properties: ::core::option::Option<PropertyMap>,
    #[prost(message, optional, tag="7")]
    pub semantic_info: ::core::option::Option<SemanticInfo>,
    #[prost(oneof="statement::StatementType", tags="1, 2, 3, 4, 5")]
    pub statement_type: ::core::option::Option<statement::StatementType>,
}
/// Nested message and enum types in `Statement`.
pub mod statement {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StatementType {
        #[prost(message, tag="1")]
        DeclareEntity(super::DeclareEntityStatement),
        #[prost(message, tag="2")]
        ObtainDocument(super::ObtainDocumentStatement),
        #[prost(message, tag="3")]
        CreateEdge(super::CreateEdgeStatement),
        #[prost(message, tag="4")]
        CalculateUbo(super::CalculateUboStatement),
        #[prost(message, tag="5")]
        Custom(super::CustomStatement),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeclareEntityStatement {
    #[prost(string, tag="1")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub entity_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObtainDocumentStatement {
    #[prost(string, tag="1")]
    pub document_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub document_type: ::prost::alloc::string::String,
    #[prost(string, optional, tag="3")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEdgeStatement {
    #[prost(string, tag="1")]
    pub from_entity: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub to_entity: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub relationship_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateUboStatement {
    #[prost(string, tag="1")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag="2")]
    pub algorithm: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, optional, tag="3")]
    pub threshold: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomStatement {
    #[prost(string, tag="1")]
    pub verb: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="2")]
    pub arguments: ::prost::alloc::vec::Vec<Value>,
}
/// Workflow definition
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Workflow {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub properties: ::core::option::Option<PropertyMap>,
    #[prost(message, repeated, tag="3")]
    pub statements: ::prost::alloc::vec::Vec<Statement>,
    #[prost(message, optional, tag="4")]
    pub semantic_info: ::core::option::Option<SemanticInfo>,
    #[prost(message, optional, tag="5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Complete DSL program
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Program {
    #[prost(message, repeated, tag="1")]
    pub workflows: ::prost::alloc::vec::Vec<Workflow>,
    #[prost(message, optional, tag="2")]
    pub global_properties: ::core::option::Option<PropertyMap>,
    #[prost(message, repeated, tag="3")]
    pub global_errors: ::prost::alloc::vec::Vec<ValidationError>,
    #[prost(message, repeated, tag="4")]
    pub global_warnings: ::prost::alloc::vec::Vec<ValidationWarning>,
    #[prost(message, optional, tag="5")]
    pub semantic_info: ::core::option::Option<SemanticInfo>,
    #[prost(message, optional, tag="6")]
    pub parsed_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Configuration for DSL processing
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DslConfig {
    #[prost(bool, tag="1")]
    pub strict_validation: bool,
    #[prost(uint32, tag="2")]
    pub max_depth: u32,
    #[prost(bool, tag="3")]
    pub debug_mode: bool,
    #[prost(string, optional, tag="4")]
    pub grammar_file: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map="string, string", tag="5")]
    pub custom_settings: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// System information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemInfo {
    #[prost(string, tag="1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub package_name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub rust_version: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub build_date: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="5")]
    pub environment: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Validation states and errors
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ValidationState {
    Unspecified = 0,
    Pending = 1,
    Valid = 2,
    Invalid = 3,
    Warning = 4,
}
impl ValidationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ValidationState::Unspecified => "VALIDATION_STATE_UNSPECIFIED",
            ValidationState::Pending => "VALIDATION_STATE_PENDING",
            ValidationState::Valid => "VALIDATION_STATE_VALID",
            ValidationState::Invalid => "VALIDATION_STATE_INVALID",
            ValidationState::Warning => "VALIDATION_STATE_WARNING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VALIDATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "VALIDATION_STATE_PENDING" => Some(Self::Pending),
            "VALIDATION_STATE_VALID" => Some(Self::Valid),
            "VALIDATION_STATE_INVALID" => Some(Self::Invalid),
            "VALIDATION_STATE_WARNING" => Some(Self::Warning),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorSeverity {
    Unspecified = 0,
    Info = 1,
    Warning = 2,
    Error = 3,
    Fatal = 4,
}
impl ErrorSeverity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ErrorSeverity::Unspecified => "ERROR_SEVERITY_UNSPECIFIED",
            ErrorSeverity::Info => "ERROR_SEVERITY_INFO",
            ErrorSeverity::Warning => "ERROR_SEVERITY_WARNING",
            ErrorSeverity::Error => "ERROR_SEVERITY_ERROR",
            ErrorSeverity::Fatal => "ERROR_SEVERITY_FATAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR_SEVERITY_INFO" => Some(Self::Info),
            "ERROR_SEVERITY_WARNING" => Some(Self::Warning),
            "ERROR_SEVERITY_ERROR" => Some(Self::Error),
            "ERROR_SEVERITY_FATAL" => Some(Self::Fatal),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatabaseReferenceType {
    Unspecified = 0,
    ForeignKey = 1,
    Lookup = 2,
    Validation = 3,
}
impl DatabaseReferenceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DatabaseReferenceType::Unspecified => "DATABASE_REFERENCE_TYPE_UNSPECIFIED",
            DatabaseReferenceType::ForeignKey => "DATABASE_REFERENCE_TYPE_FOREIGN_KEY",
            DatabaseReferenceType::Lookup => "DATABASE_REFERENCE_TYPE_LOOKUP",
            DatabaseReferenceType::Validation => "DATABASE_REFERENCE_TYPE_VALIDATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATABASE_REFERENCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "DATABASE_REFERENCE_TYPE_FOREIGN_KEY" => Some(Self::ForeignKey),
            "DATABASE_REFERENCE_TYPE_LOOKUP" => Some(Self::Lookup),
            "DATABASE_REFERENCE_TYPE_VALIDATION" => Some(Self::Validation),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
