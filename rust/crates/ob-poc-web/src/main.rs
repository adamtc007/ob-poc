//! OB-POC Web Server
//!
//! Serves the React frontend and provides all API endpoints
//! for DSL generation, entity search, attributes, and DSL viewer.

mod routes;
mod state;

use axum::{routing::get, Router};
use http::header::{HeaderValue, CACHE_CONTROL};
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Duration;
use tower::ServiceBuilder;
use tower_http::{
    cors::{Any, CorsLayer},
    services::{ServeDir, ServeFile},
    set_header::SetResponseHeaderLayer,
    trace::TraceLayer,
};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

use crate::state::AppState;

// Import API routers from main ob-poc crate
use ob_poc::api::{
    control_routes, create_agent_router_with_semantic, create_attribute_router,
    create_cbu_session_router_with_pool, create_client_router, create_deal_router,
    create_dsl_viewer_router, create_entity_router, create_graph_router, create_resolution_router,
    create_scoped_entity_router, create_session_graph_router, create_session_store,
    create_taxonomy_router, create_trading_matrix_router, create_universe_router,
    create_verb_discovery_router, service_resource_router,
};

// Import gateway resolver for resolution routes
use entity_gateway::proto::ob::gateway::v1::entity_gateway_client::EntityGatewayClient;
use ob_poc::dsl_v2::{gateway_resolver::gateway_addr, GatewayRefResolver};

// Import verb sync and config loader for startup sync
use ob_poc::dsl_v2::ConfigLoader;
use ob_poc::session::VerbSyncService;

// Import background learning task
use ob_poc::agent::learning::{create_learning_status, spawn_learning_task, LearningConfig};
use std::sync::atomic::AtomicBool;

// EntityGateway for entity resolution
use entity_gateway::{
    config::StartupMode,
    index::{IndexRegistry, TantivyIndex},
    proto::ob::gateway::v1::entity_gateway_server::EntityGatewayServer,
    refresh::{run_refresh_loop, RefreshPipeline},
    server::EntityGatewayService,
    GatewayConfig,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "ob_poc_web=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    tracing::info!("Starting OB-POC Hybrid Web Server");

    // Database connection pool configuration
    // Production-ready settings for concurrent connections
    let database_url =
        std::env::var("DATABASE_URL").unwrap_or_else(|_| "postgresql:///data_designer".to_string());

    let max_connections: u32 = std::env::var("DATABASE_POOL_MAX")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(50);

    let min_connections: u32 = std::env::var("DATABASE_POOL_MIN")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(5);

    let acquire_timeout_secs: u64 = std::env::var("DATABASE_ACQUIRE_TIMEOUT")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(5);

    let idle_timeout_secs: u64 = std::env::var("DATABASE_IDLE_TIMEOUT")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(600);

    tracing::info!(
        "Database pool config: max={}, min={}, acquire_timeout={}s, idle_timeout={}s",
        max_connections,
        min_connections,
        acquire_timeout_secs,
        idle_timeout_secs
    );

    let pool = match sqlx::postgres::PgPoolOptions::new()
        .max_connections(max_connections)
        .min_connections(min_connections)
        .acquire_timeout(Duration::from_secs(acquire_timeout_secs))
        .idle_timeout(Duration::from_secs(idle_timeout_secs))
        .connect(&database_url)
        .await
    {
        Ok(p) => {
            tracing::info!(
                "Database connection pool established ({} min, {} max connections)",
                min_connections,
                max_connections
            );
            p
        }
        Err(e) => {
            tracing::error!("Failed to connect to database at {}: {}", database_url, e);
            tracing::error!(
                "Please check DATABASE_URL environment variable and ensure PostgreSQL is running"
            );
            return Err(format!("Database connection failed: {}", e).into());
        }
    };

    // =========================================================================
    // Sync verb definitions from YAML to database
    // With DYNAMIC VERB EXPANSION from entity_types table
    // Invocation phrases are auto-generated by dsl-core ConfigLoader
    // =========================================================================
    tracing::info!("Syncing verb definitions to database...");

    let verb_sync_service = VerbSyncService::new(pool.clone());
    let config_loader = ConfigLoader::from_env();

    match config_loader.load_verbs() {
        Ok(verbs_config) => {
            // Use from_config_with_db to expand dynamic verbs from entity_types table
            // This generates entity.create-{type_code} verbs for ALL entity types in DB
            let registry = match ob_poc::dsl_v2::RuntimeVerbRegistry::from_config_with_db(
                &verbs_config,
                &pool,
            )
            .await
            {
                Ok(r) => {
                    tracing::info!(
                        "Verb registry loaded with {} verbs (including dynamic expansion)",
                        r.len()
                    );
                    r
                }
                Err(e) => {
                    tracing::warn!(
                        "Dynamic verb expansion failed, falling back to static config: {}",
                        e
                    );
                    ob_poc::dsl_v2::RuntimeVerbRegistry::from_config(&verbs_config)
                }
            };

            // Sync verbs AND invocation_phrases to DB (yaml_intent_patterns column)
            // V1 YAML now has auto-generated phrases from dsl-core ConfigLoader
            let sync_result = verb_sync_service
                .sync_all_with_phrases(&registry, &verbs_config)
                .await;

            match sync_result {
                Ok(result) => {
                    tracing::info!(
                        "Verb sync complete: {} added, {} updated, {} unchanged in {}ms",
                        result.verbs_added,
                        result.verbs_updated,
                        result.verbs_unchanged,
                        result.duration_ms
                    );
                }
                Err(e) => {
                    tracing::warn!("Verb sync failed (non-fatal): {}", e);
                    tracing::warn!("Verb discovery will use fallback behavior");
                }
            }
        }
        Err(e) => {
            tracing::warn!("Failed to load verb config (non-fatal): {}", e);
            tracing::warn!("Verb discovery will use fallback behavior");
        }
    }

    // =========================================================================
    // Start embedded EntityGateway gRPC service
    // =========================================================================
    tracing::info!("Starting embedded EntityGateway...");

    let gateway_config_path = std::env::var("ENTITY_GATEWAY_CONFIG")
        .unwrap_or_else(|_| "crates/entity-gateway/config/entity_index.yaml".to_string());

    let gateway_config = match GatewayConfig::from_file(&gateway_config_path) {
        Ok(cfg) => Some(cfg),
        Err(e) => {
            tracing::warn!(
                "Failed to load EntityGateway config from {}: {}",
                gateway_config_path,
                e
            );
            tracing::warn!("Entity resolution features will not be available");
            None
        }
    };

    if let Some(gateway_config) = gateway_config {
        let configs_by_nickname: std::collections::HashMap<String, _> = gateway_config
            .entities
            .values()
            .map(|cfg| (cfg.nickname.clone(), cfg.clone()))
            .collect();
        let registry = Arc::new(IndexRegistry::new(configs_by_nickname));

        for entity_config in gateway_config.entities.values() {
            match TantivyIndex::new(entity_config.clone()) {
                Ok(index) => {
                    registry
                        .register(entity_config.nickname.clone(), Arc::new(index))
                        .await;
                    tracing::debug!("Registered index: {}", entity_config.nickname);
                }
                Err(e) => {
                    tracing::warn!(
                        "Failed to create index for {}: {}",
                        entity_config.nickname,
                        e
                    );
                }
            }
        }

        let refresh_registry = registry.clone();
        let refresh_config = gateway_config.clone();
        tokio::spawn(async move {
            match RefreshPipeline::new(refresh_config.clone()).await {
                Ok(pipeline) => {
                    match refresh_config.refresh.startup_mode {
                        StartupMode::Sync => {
                            tracing::info!("Performing initial index refresh (sync)...");
                            if let Err(e) = pipeline.refresh_all(&refresh_registry).await {
                                tracing::warn!("Initial refresh failed: {}", e);
                            }
                        }
                        StartupMode::Async => {
                            tracing::info!("Starting async initial refresh...");
                            let reg = refresh_registry.clone();
                            tokio::spawn(async move {
                                if let Err(e) = pipeline.refresh_all(&reg).await {
                                    tracing::error!("Async initial refresh failed: {}", e);
                                }
                            });
                        }
                    }

                    let loop_pipeline = match RefreshPipeline::new(refresh_config.clone()).await {
                        Ok(p) => p,
                        Err(e) => {
                            tracing::error!("Failed to create refresh loop pipeline: {}", e);
                            return;
                        }
                    };
                    run_refresh_loop(
                        loop_pipeline,
                        refresh_registry,
                        refresh_config.refresh.interval_secs,
                    )
                    .await;
                }
                Err(e) => {
                    tracing::warn!("Failed to initialize refresh pipeline: {}", e);
                }
            }
        });

        let grpc_service = EntityGatewayService::new(registry);
        // Default gRPC address - validated at compile time
        const DEFAULT_GRPC_ADDR: &str = "[::]:50051";
        let grpc_addr: SocketAddr = std::env::var("ENTITY_GATEWAY_ADDR")
            .unwrap_or_else(|_| DEFAULT_GRPC_ADDR.to_string())
            .parse()
            .unwrap_or_else(|e| {
                tracing::warn!(
                    "Invalid ENTITY_GATEWAY_ADDR, using default {}: {}",
                    DEFAULT_GRPC_ADDR,
                    e
                );
                DEFAULT_GRPC_ADDR
                    .parse()
                    .expect("default gRPC address is valid")
            });

        tokio::spawn(async move {
            tracing::info!("EntityGateway gRPC listening on {}", grpc_addr);
            if let Err(e) = tonic::transport::Server::builder()
                .add_service(EntityGatewayServer::new(grpc_service))
                .serve(grpc_addr)
                .await
            {
                tracing::error!("EntityGateway gRPC server error: {}", e);
            }
        });

        tracing::info!("EntityGateway started successfully");
    }

    // Create single shared session store for agent routers
    let sessions = create_session_store();

    // Create gateway resolver for entity reference resolution
    let gateway_channel = tonic::transport::Channel::from_shared(gateway_addr())
        .expect("valid gateway address")
        .connect_lazy();
    let gateway_client = EntityGatewayClient::new(gateway_channel);
    let gateway_resolver = GatewayRefResolver::new(gateway_client);

    // Create shared state for CBU/graph endpoints
    let state = AppState::new(pool.clone());

    // Static file serving - point to our static directory
    // Use manifest dir at compile time, or STATIC_DIR env var at runtime
    let static_dir = std::env::var("STATIC_DIR").unwrap_or_else(|_| {
        // Try to find static dir relative to the crate
        let manifest_dir = env!("CARGO_MANIFEST_DIR");
        format!("{}/static", manifest_dir)
    });
    tracing::info!("Serving static files from: {}", static_dir);

    // CORS for development
    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers(Any);

    // Build stateless API router (from main ob-poc crate) with SHARED session store
    // Use async semantic-enabled router for Candle-based verb search
    let agent_router = create_agent_router_with_semantic(pool.clone(), sessions.clone()).await;

    let api_router: Router<()> = Router::new()
        .merge(agent_router)
        .merge(create_attribute_router(pool.clone()))
        .merge(create_entity_router())
        .merge(create_dsl_viewer_router(pool.clone()))
        .merge(create_resolution_router(sessions.clone(), gateway_resolver))
        // Client portal router (separate auth, scoped access)
        .merge(create_client_router(pool.clone(), sessions.clone()))
        // Verb discovery router (RAG-style verb suggestions)
        .merge(create_verb_discovery_router(pool.clone()))
        // Trading matrix router (custody taxonomy browser)
        .merge(create_trading_matrix_router(pool.clone()))
        // Taxonomy navigation router (fractal drill-down)
        .merge(create_taxonomy_router(pool.clone(), sessions.clone()))
        // Deal taxonomy router (deal visualization and navigation)
        .merge(create_deal_router(pool.clone(), sessions.clone()))
        // Graph visualization (legacy CBU endpoints)
        .merge(create_graph_router(pool.clone()))
        // Session-scoped graph (shares state with REPL and taxonomy)
        .merge(create_session_graph_router(pool.clone(), sessions.clone()))
        // Galaxy navigation - universe view and cluster detail
        .merge(create_universe_router(pool.clone()))
        // Control/ownership routes (board controller, control sphere)
        .merge(control_routes(pool.clone()))
        // Session-scoped entity search (constraint cascade)
        .merge(create_scoped_entity_router(sessions.clone()))
        // Service resource pipeline (intents, discovery, readiness)
        .merge(service_resource_router(pool.clone()))
        // CBU session management (load/unload CBUs, undo/redo)
        .nest(
            "/api/cbu-session",
            create_cbu_session_router_with_pool(pool.clone()),
        );

    // Build voice matching router (semantic + phonetic)
    let voice_router = routes::voice::create_voice_router(pool.clone());

    // =========================================================================
    // BPMN-Lite Integration (before REPL V2 — determines executor)
    // =========================================================================
    let bpmn_executor_v2: Option<Arc<dyn ob_poc::repl::orchestrator_v2::DslExecutorV2>> = {
        use ob_poc::bpmn_integration::{
            client::BpmnLiteConnection, config::WorkflowConfigIndex, correlation::CorrelationStore,
            dispatcher::WorkflowDispatcher, job_frames::JobFrameStore,
            parked_tokens::ParkedTokenStore, pending_dispatch_worker::PendingDispatchWorker,
            pending_dispatches::PendingDispatchStore, worker::JobWorker,
        };
        use ob_poc::repl::executor_bridge::RealDslExecutor;

        match std::env::var("BPMN_LITE_GRPC_URL") {
            Ok(bpmn_url) => {
                tracing::info!("BPMN-Lite integration enabled at {}", bpmn_url);

                match BpmnLiteConnection::connect_lazy(&bpmn_url) {
                    Ok(client) => {
                        // Load workflow config
                        let config_dir = std::env::var("DSL_CONFIG_DIR").unwrap_or_else(|_| {
                            let manifest_dir = env!("CARGO_MANIFEST_DIR");
                            format!("{}/../../config", manifest_dir)
                        });
                        let config_path = std::path::Path::new(&config_dir).join("workflows.yaml");

                        match WorkflowConfigIndex::load_from_file(&config_path) {
                            Ok(mut config_index) => {
                                // Auto-register durable verbs from verb YAML
                                {
                                    use ob_poc::dsl_v2::config::types::DurableConfig;
                                    use ob_poc::dsl_v2::runtime_registry::{
                                        runtime_registry, RuntimeBehavior,
                                    };
                                    let reg = runtime_registry();
                                    let mut registered = 0usize;
                                    for verb in reg.all_verbs() {
                                        if let RuntimeBehavior::Durable(d) = &verb.behavior {
                                            let durable_config = DurableConfig {
                                                runtime: d.runtime,
                                                process_key: d.process_key.clone(),
                                                correlation_field: d.correlation_field.clone(),
                                                task_bindings: d.task_bindings.clone(),
                                                timeout: d.timeout.clone(),
                                                escalation: d.escalation.clone(),
                                            };
                                            config_index.register_from_durable_config(
                                                &verb.full_name,
                                                &durable_config,
                                            );
                                            registered += 1;
                                        }
                                    }
                                    if registered > 0 {
                                        tracing::info!(
                                            "Auto-registered {} durable verbs in WorkflowConfigIndex",
                                            registered
                                        );
                                    }
                                }

                                let config_index = Arc::new(config_index);

                                // Inner executor for direct verb execution
                                let inner: Arc<dyn ob_poc::repl::orchestrator_v2::DslExecutorV2> =
                                    Arc::new(RealDslExecutor::new(pool.clone()));

                                // WorkflowDispatcher — routes Direct vs Orchestrated.
                                // Each store wraps a PgPool (cheap Arc clone), so we
                                // create separate instances per consumer.
                                let dispatcher = WorkflowDispatcher::new(
                                    inner,
                                    config_index.clone(),
                                    client.clone(),
                                    CorrelationStore::new(pool.clone()),
                                    ParkedTokenStore::new(pool.clone()),
                                    PendingDispatchStore::new(pool.clone()),
                                )
                                .with_pool(pool.clone());

                                // Spawn JobWorker (long-poll job activation loop)
                                let (job_shutdown_tx, job_shutdown_rx) =
                                    tokio::sync::watch::channel(false);
                                let worker_executor: Arc<
                                    dyn ob_poc::repl::orchestrator_v2::DslExecutorV2,
                                > = Arc::new(RealDslExecutor::new(pool.clone()));
                                let job_worker = JobWorker::new(
                                    format!("ob-poc-worker-{}", std::process::id()),
                                    client.clone(),
                                    config_index.clone(),
                                    JobFrameStore::new(pool.clone()),
                                    worker_executor,
                                );
                                tokio::spawn(async move {
                                    job_worker.run(job_shutdown_rx).await;
                                });
                                std::mem::forget(job_shutdown_tx);

                                // Spawn PendingDispatchWorker (retry queued dispatches)
                                let (pending_shutdown_tx, pending_shutdown_rx) =
                                    tokio::sync::watch::channel(false);
                                let pending_worker = PendingDispatchWorker::new(
                                    client.clone(),
                                    PendingDispatchStore::new(pool.clone()),
                                    CorrelationStore::new(pool.clone()),
                                    config_index.clone(),
                                );
                                tokio::spawn(async move {
                                    pending_worker.run(pending_shutdown_rx).await;
                                });
                                std::mem::forget(pending_shutdown_tx);

                                tracing::info!(
                                    "BPMN-Lite integration initialized: client={}, task_types={:?}",
                                    bpmn_url,
                                    config_index.all_task_types()
                                );

                                Some(Arc::new(dispatcher)
                                    as Arc<dyn ob_poc::repl::orchestrator_v2::DslExecutorV2>)
                            }
                            Err(e) => {
                                tracing::warn!(
                                    "Failed to load workflow config from {}: {}",
                                    config_path.display(),
                                    e
                                );
                                tracing::warn!(
                                    "BPMN-Lite disabled — WorkflowDispatcher not available"
                                );
                                None
                            }
                        }
                    }
                    Err(e) => {
                        tracing::warn!("Failed to create BPMN-Lite client: {}", e);
                        tracing::warn!("BPMN-Lite integration disabled");
                        None
                    }
                }
            }
            Err(_) => {
                tracing::debug!("BPMN-Lite integration disabled (BPMN_LITE_GRPC_URL not set)");
                None
            }
        }
    };

    // =========================================================================
    // REPL V2 — Pack-Guided Runbook Pipeline
    // =========================================================================
    let repl_v2_router = {
        use ob_poc::api::repl_routes_v2::{self, ReplV2RouteState};
        use ob_poc::journey::router::PackRouter;
        use ob_poc::repl::orchestrator_v2::ReplOrchestratorV2;

        // Load journey packs from config dir (if available), otherwise empty router.
        let pack_router = {
            let config_dir =
                std::path::Path::new(env!("CARGO_MANIFEST_DIR")).join("../../config/packs");
            PackRouter::load(&config_dir).unwrap_or_else(|_| PackRouter::new(vec![]))
        };

        // Legacy DslExecutor for the constructor (fallback path — never parks)
        use ob_poc::repl::executor_bridge::RealDslExecutor;
        let legacy_executor: Arc<dyn ob_poc::repl::orchestrator_v2::DslExecutor> =
            Arc::new(RealDslExecutor::new(pool.clone()));

        let mut orchestrator =
            ReplOrchestratorV2::new(pack_router, legacy_executor).with_pool(pool.clone());

        // Wire the V2 executor that supports parking (WorkflowDispatcher or RealDslExecutor)
        if let Some(ref bpmn_exec) = bpmn_executor_v2 {
            orchestrator = orchestrator.with_executor_v2(bpmn_exec.clone());
            tracing::info!("REPL V2 executor: WorkflowDispatcher (BPMN-routed)");
        } else {
            // No BPMN — wire RealDslExecutor directly (it auto-impls DslExecutorV2
            // via the blanket impl, so execute_v2 maps to Completed/Failed, never Parked)
            orchestrator =
                orchestrator.with_executor_v2(Arc::new(RealDslExecutor::new(pool.clone())));
            tracing::info!("REPL V2 executor: RealDslExecutor (direct, no BPMN)");
        }

        // =====================================================================
        // Wire IntentService for semantic verb search in V2 REPL
        //
        // This is the critical wiring that enables the V2 orchestrator to resolve
        // user utterances to DSL verbs via the same 10-tier search pipeline
        // (Candle embeddings, learned phrases, macros, lexicon) that the V1
        // agent chat uses.
        // =====================================================================
        {
            use ob_poc::agent::learning::embedder::CandleEmbedder;
            use ob_poc::agent::learning::warmup::LearningWarmup;
            use ob_poc::dsl_v2::ConfigLoader;
            use ob_poc::macros::OperatorMacroRegistry;
            use ob_poc::mcp::verb_search_factory::VerbSearcherFactory;
            use ob_poc::mcp::verb_search_intent_matcher::VerbSearchIntentMatcher;
            use ob_poc::repl::intent_service::IntentService;
            use ob_poc::repl::verb_config_index::VerbConfigIndex;

            tracing::info!("Initializing V2 REPL IntentService...");
            let intent_start = std::time::Instant::now();

            // 1. Load VerbsConfig from YAML for VerbConfigIndex
            let verb_config_index = {
                let config_loader = ConfigLoader::from_env();
                match config_loader.load_verbs() {
                    Ok(verbs_config) => {
                        let index = VerbConfigIndex::from_verbs_config(&verbs_config);
                        tracing::info!("VerbConfigIndex loaded: {} verbs", index.len());
                        Arc::new(index)
                    }
                    Err(e) => {
                        tracing::warn!(
                            "Failed to load verbs config for VerbConfigIndex: {}. Using empty index.",
                            e
                        );
                        Arc::new(VerbConfigIndex::empty())
                    }
                }
            };

            // 2. Initialize Candle embedder for semantic search
            let embedder_result = tokio::task::spawn_blocking(CandleEmbedder::new).await;
            match embedder_result {
                Ok(Ok(embedder)) => {
                    let embedder = Arc::new(embedder);
                    let dyn_embedder: Arc<dyn ob_poc::agent::learning::embedder::Embedder> =
                        embedder.clone();

                    // 3. Load learned data for exact phrase matching
                    let warmup = LearningWarmup::new(pool.clone());
                    let learned_data = match warmup.warmup().await {
                        Ok((data, stats)) => {
                            tracing::info!(
                                "V2 REPL learned data: {} phrases, {} aliases",
                                stats.invocation_phrases_loaded,
                                stats.entity_aliases_loaded
                            );
                            Some(data)
                        }
                        Err(e) => {
                            tracing::warn!("V2 REPL learned data warmup failed: {}", e);
                            None
                        }
                    };

                    // 4. Load lexicon snapshot
                    let lexicon: Option<ob_poc::mcp::verb_search::SharedLexicon> = {
                        use ob_poc::lexicon::{LexiconServiceImpl, LexiconSnapshot};
                        let snapshot_paths = [
                            std::path::Path::new("rust/assets/lexicon.snapshot.bin"),
                            std::path::Path::new("assets/lexicon.snapshot.bin"),
                            std::path::Path::new("../rust/assets/lexicon.snapshot.bin"),
                        ];
                        let mut loaded = None;
                        for path in &snapshot_paths {
                            if path.exists() {
                                if let Ok(snapshot) = LexiconSnapshot::load_binary(path) {
                                    loaded =
                                        Some(Arc::new(LexiconServiceImpl::new(Arc::new(snapshot)))
                                            as Arc<dyn ob_poc::lexicon::LexiconService>);
                                    break;
                                }
                            }
                        }
                        loaded
                    };

                    // 5. Load macro registry for operator vocabulary
                    let macro_dir = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                        .join("../../config/verb_schemas/macros");
                    let macro_reg = Arc::new(
                        OperatorMacroRegistry::load_from_dir(&macro_dir)
                            .unwrap_or_else(|_| OperatorMacroRegistry::new()),
                    );

                    // 6. Build HybridVerbSearcher via factory
                    let searcher = Arc::new(VerbSearcherFactory::build(
                        &pool,
                        dyn_embedder,
                        learned_data,
                        macro_reg,
                        lexicon,
                    ));

                    // 7. Wrap in IntentMatcher → IntentService
                    let intent_matcher: Arc<dyn ob_poc::repl::IntentMatcher> =
                        Arc::new(VerbSearchIntentMatcher::new(searcher));

                    let intent_service = Arc::new(IntentService::new(
                        intent_matcher.clone(),
                        verb_config_index.clone(),
                    ));

                    // 8. Wire into orchestrator
                    orchestrator = orchestrator
                        .with_verb_config_index(verb_config_index)
                        .with_intent_matcher(intent_matcher)
                        .with_intent_service(intent_service);

                    tracing::info!(
                        "V2 REPL IntentService wired in {}ms (semantic verb search enabled)",
                        intent_start.elapsed().as_millis()
                    );
                }
                Ok(Err(e)) => {
                    tracing::error!(
                        "V2 REPL: Candle embedder init failed: {}. Semantic search disabled.",
                        e
                    );
                    // Orchestrator continues without intent service — falls back to stub
                    orchestrator = orchestrator.with_verb_config_index(verb_config_index);
                }
                Err(e) => {
                    tracing::error!(
                        "V2 REPL: Candle embedder task panicked: {}. Semantic search disabled.",
                        e
                    );
                    orchestrator = orchestrator.with_verb_config_index(verb_config_index);
                }
            }
        }

        let v2_state = ReplV2RouteState {
            orchestrator: Arc::new(orchestrator),
        };

        tracing::info!("REPL V2 orchestrator initialized with semantic intent service");

        repl_routes_v2::router().with_state(v2_state)
    };

    // React dist directory - serve assets from React build
    let react_dist_dir = std::env::var("REACT_DIST_DIR").unwrap_or_else(|_| {
        // Try to find React dist relative to the crate
        let manifest_dir = env!("CARGO_MANIFEST_DIR");
        let candidates = [
            format!("{}/../../ob-poc-ui-react/dist", manifest_dir),
            format!("{}/../../../ob-poc-ui-react/dist", manifest_dir),
        ];
        for candidate in &candidates {
            if std::path::Path::new(candidate).exists() {
                return candidate.clone();
            }
        }
        // Fallback to placeholder
        format!("{}/static", manifest_dir)
    });
    tracing::info!("Serving React assets from: {}", react_dist_dir);

    // Build main app router with state
    // Session routes (including /bind) share session store via create_agent_router_with_semantic
    // Note: CBU routes (/api/cbu, /api/cbu/:id, /api/cbu/:id/graph) are provided by create_graph_router in api_router
    let app = Router::new()
        // CBU search uses local AppState implementation
        .route("/api/cbu/search", get(routes::api::search_cbus))
        // SSE streaming for agent chat
        .route("/api/chat/stream", get(routes::chat::chat_stream))
        // React assets (JS, CSS bundles) - served from /assets/ path
        .nest_service(
            "/assets",
            ServiceBuilder::new()
                .layer(SetResponseHeaderLayer::overriding(
                    CACHE_CONTROL,
                    HeaderValue::from_static("public, max-age=31536000, immutable"),
                ))
                .service(ServeDir::new(format!("{}/assets", react_dist_dir)).precompressed_gzip()),
        )
        // Legacy static files (kept for backwards compatibility)
        .nest_service(
            "/static",
            ServiceBuilder::new()
                .layer(SetResponseHeaderLayer::overriding(
                    CACHE_CONTROL,
                    HeaderValue::from_static("no-cache, no-store, must-revalidate"),
                ))
                .service(ServeDir::new(&static_dir).precompressed_gzip()),
        )
        // Vite favicon
        .nest_service(
            "/vite.svg",
            ServeFile::new(format!("{}/vite.svg", react_dist_dir)),
        )
        // Index.html at root (React app)
        .route("/", get(routes::static_files::serve_index))
        // SPA fallback: serve index.html for client-side routing
        // This catches routes like /chat/:id, /viewport/:id, /inspector/:id
        .fallback(get(routes::static_files::serve_index))
        // Add state
        .with_state(state)
        // Merge stateless API routes (includes session, agent, entity, dsl viewer)
        .merge(api_router)
        // Voice matching routes (semantic ML + phonetic) - stateless router
        .merge(voice_router)
        // REPL V2 — Pack-guided runbook pipeline with bootstrap resolution
        .nest("/api/repl/v2", repl_v2_router)
        // Layers
        .layer(TraceLayer::new_for_http())
        .layer(cors);

    let port: u16 = std::env::var("SERVER_PORT")
        .ok()
        .and_then(|p| p.parse().ok())
        .unwrap_or(3000);
    let addr = SocketAddr::from(([0, 0, 0, 0], port));

    tracing::info!("");
    tracing::info!("===========================================");
    tracing::info!("  OB-POC Web Server running on http://{}", addr);
    tracing::info!("===========================================");
    tracing::info!("");
    tracing::info!("UI: http://localhost:{}", port);
    tracing::info!("");
    tracing::info!("API Endpoints:");
    tracing::info!("  /api/cbu              - List CBUs");
    tracing::info!("  /api/cbu/:id/graph    - Get CBU graph");
    tracing::info!("  /api/session          - Session management");
    tracing::info!("  /api/session/:id/resolution/* - Entity resolution");
    tracing::info!("  /api/agent/*          - DSL generation");
    tracing::info!("  /api/entity/search    - Entity search");
    tracing::info!("  /api/dsl/*            - DSL viewer");
    tracing::info!("  /api/verbs/discover   - Verb discovery (RAG)");
    tracing::info!("  /api/verbs/agent-context - Agent verb context");
    tracing::info!("  /api/voice/match      - Semantic voice matching");
    tracing::info!("  /api/voice/health     - Voice matcher health");
    tracing::info!("  /api/repl/v2/session  - REPL V2 session management");
    tracing::info!("  /api/repl/v2/session/:id/input - REPL V2 unified input");
    tracing::info!("  /api/universe         - Galaxy universe view");
    tracing::info!("  /api/cluster/:type/:id - Cluster detail view");
    tracing::info!("");
    tracing::info!("Client Portal API:");
    tracing::info!("  /api/client/login     - Client authentication");
    tracing::info!("  /api/client/status    - Get CBU status");
    tracing::info!("  /api/client/outstanding - List outstanding requests");
    tracing::info!("  /api/client/chat      - Client chat endpoint");
    tracing::info!("");
    tracing::info!("Service Resource Pipeline:");
    tracing::info!("  POST /api/cbu/:id/service-intents   - Create service intent");
    tracing::info!("  POST /api/cbu/:id/resource-discover - Run resource discovery");
    tracing::info!("  POST /api/cbu/:id/pipeline/full     - Run full pipeline");
    tracing::info!("  GET  /api/cbu/:id/readiness         - Service readiness");
    tracing::info!("  GET  /api/srdefs                    - SRDEF registry");
    tracing::info!("");

    let listener = match tokio::net::TcpListener::bind(addr).await {
        Ok(l) => l,
        Err(e) => {
            tracing::error!("Failed to bind to {}: {}", addr, e);
            if e.kind() == std::io::ErrorKind::AddrInUse {
                tracing::error!(
                    "Port {} is already in use. Try: lsof -ti:{} | xargs kill -9",
                    port,
                    port
                );
            }
            return Err(format!("Failed to bind to {}: {}", addr, e).into());
        }
    };

    // =========================================================================
    // Initialize macro registry (operator vocabulary layer)
    // =========================================================================
    match ob_poc::mcp::init_macro_registry() {
        Ok(()) => {
            let registry = ob_poc::mcp::macro_registry();
            tracing::info!(
                "Macro registry initialized: {} macros, {} domains",
                registry.len(),
                registry.domains().count()
            );
        }
        Err(e) => {
            tracing::warn!("Macro registry initialization failed (non-fatal): {}", e);
            tracing::warn!("Operator macros will not be available");
        }
    }

    // =========================================================================
    // Spawn background learning task (non-blocking)
    // =========================================================================
    let learning_config = LearningConfig::from_env();
    let learning_status = create_learning_status();
    let shutdown_flag = Arc::new(AtomicBool::new(false));

    spawn_learning_task(
        pool.clone(),
        learning_config,
        learning_status,
        shutdown_flag,
    );

    tracing::info!("Background learning task spawned");

    if let Err(e) = axum::serve(listener, app).await {
        tracing::error!("Server error: {}", e);
        return Err(format!("Server error: {}", e).into());
    }

    Ok(())
}
