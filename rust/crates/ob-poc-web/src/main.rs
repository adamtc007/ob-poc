//! OB-POC Web Server
//!
//! Serves the React frontend and provides all API endpoints
//! for DSL generation, entity search, attributes, and DSL viewer.

mod routes;
mod state;

use axum::{routing::get, Router};
use http::header::{HeaderValue, CACHE_CONTROL};
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Duration;
use tower::ServiceBuilder;
use tower_http::{
    cors::{Any, CorsLayer},
    services::{ServeDir, ServeFile},
    set_header::SetResponseHeaderLayer,
    trace::TraceLayer,
};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

use crate::state::AppState;

// Import API routers from main ob-poc crate
use ob_poc::api::{
    control_routes, create_agent_router_with_semantic, create_attribute_router,
    create_cbu_session_router_with_pool, create_client_router, create_deal_router,
    create_dsl_viewer_router, create_entity_router, create_graph_router, create_repl_router,
    create_resolution_router, create_scoped_entity_router, create_session_graph_router,
    create_session_store, create_taxonomy_router, create_trading_matrix_router,
    create_universe_router, create_verb_discovery_router, service_resource_router, ReplRouteState,
};

// Import REPL orchestrator and related types
use ob_poc::mcp::verb_search::HybridVerbSearcher;
use ob_poc::repl::{HybridIntentMatcher, ReplOrchestrator};

// Import gateway resolver for resolution routes
use entity_gateway::proto::ob::gateway::v1::entity_gateway_client::EntityGatewayClient;
use ob_poc::dsl_v2::{gateway_resolver::gateway_addr, GatewayRefResolver};

// Import verb sync and config loader for startup sync
use ob_poc::dsl_v2::ConfigLoader;
use ob_poc::session::VerbSyncService;

// Import background learning task
use ob_poc::agent::learning::{create_learning_status, spawn_learning_task, LearningConfig};
use std::sync::atomic::AtomicBool;

// EntityGateway for entity resolution
use entity_gateway::{
    config::StartupMode,
    index::{IndexRegistry, TantivyIndex},
    proto::ob::gateway::v1::entity_gateway_server::EntityGatewayServer,
    refresh::{run_refresh_loop, RefreshPipeline},
    server::EntityGatewayService,
    GatewayConfig,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logging
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "ob_poc_web=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    tracing::info!("Starting OB-POC Hybrid Web Server");

    // Database connection pool configuration
    // Production-ready settings for concurrent connections
    let database_url =
        std::env::var("DATABASE_URL").unwrap_or_else(|_| "postgresql:///data_designer".to_string());

    let max_connections: u32 = std::env::var("DATABASE_POOL_MAX")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(50);

    let min_connections: u32 = std::env::var("DATABASE_POOL_MIN")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(5);

    let acquire_timeout_secs: u64 = std::env::var("DATABASE_ACQUIRE_TIMEOUT")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(5);

    let idle_timeout_secs: u64 = std::env::var("DATABASE_IDLE_TIMEOUT")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(600);

    tracing::info!(
        "Database pool config: max={}, min={}, acquire_timeout={}s, idle_timeout={}s",
        max_connections,
        min_connections,
        acquire_timeout_secs,
        idle_timeout_secs
    );

    let pool = match sqlx::postgres::PgPoolOptions::new()
        .max_connections(max_connections)
        .min_connections(min_connections)
        .acquire_timeout(Duration::from_secs(acquire_timeout_secs))
        .idle_timeout(Duration::from_secs(idle_timeout_secs))
        .connect(&database_url)
        .await
    {
        Ok(p) => {
            tracing::info!(
                "Database connection pool established ({} min, {} max connections)",
                min_connections,
                max_connections
            );
            p
        }
        Err(e) => {
            tracing::error!("Failed to connect to database at {}: {}", database_url, e);
            tracing::error!(
                "Please check DATABASE_URL environment variable and ensure PostgreSQL is running"
            );
            return Err(format!("Database connection failed: {}", e).into());
        }
    };

    // =========================================================================
    // Sync verb definitions from YAML to database
    // With DYNAMIC VERB EXPANSION from entity_types table
    // Invocation phrases are auto-generated by dsl-core ConfigLoader
    // =========================================================================
    tracing::info!("Syncing verb definitions to database...");

    let verb_sync_service = VerbSyncService::new(pool.clone());
    let config_loader = ConfigLoader::from_env();

    match config_loader.load_verbs() {
        Ok(verbs_config) => {
            // Use from_config_with_db to expand dynamic verbs from entity_types table
            // This generates entity.create-{type_code} verbs for ALL entity types in DB
            let registry = match ob_poc::dsl_v2::RuntimeVerbRegistry::from_config_with_db(
                &verbs_config,
                &pool,
            )
            .await
            {
                Ok(r) => {
                    tracing::info!(
                        "Verb registry loaded with {} verbs (including dynamic expansion)",
                        r.len()
                    );
                    r
                }
                Err(e) => {
                    tracing::warn!(
                        "Dynamic verb expansion failed, falling back to static config: {}",
                        e
                    );
                    ob_poc::dsl_v2::RuntimeVerbRegistry::from_config(&verbs_config)
                }
            };

            // Sync verbs AND invocation_phrases to DB (yaml_intent_patterns column)
            // V1 YAML now has auto-generated phrases from dsl-core ConfigLoader
            let sync_result = verb_sync_service
                .sync_all_with_phrases(&registry, &verbs_config)
                .await;

            match sync_result {
                Ok(result) => {
                    tracing::info!(
                        "Verb sync complete: {} added, {} updated, {} unchanged in {}ms",
                        result.verbs_added,
                        result.verbs_updated,
                        result.verbs_unchanged,
                        result.duration_ms
                    );
                }
                Err(e) => {
                    tracing::warn!("Verb sync failed (non-fatal): {}", e);
                    tracing::warn!("Verb discovery will use fallback behavior");
                }
            }
        }
        Err(e) => {
            tracing::warn!("Failed to load verb config (non-fatal): {}", e);
            tracing::warn!("Verb discovery will use fallback behavior");
        }
    }

    // =========================================================================
    // Start embedded EntityGateway gRPC service
    // =========================================================================
    tracing::info!("Starting embedded EntityGateway...");

    let gateway_config_path = std::env::var("ENTITY_GATEWAY_CONFIG")
        .unwrap_or_else(|_| "crates/entity-gateway/config/entity_index.yaml".to_string());

    let gateway_config = match GatewayConfig::from_file(&gateway_config_path) {
        Ok(cfg) => Some(cfg),
        Err(e) => {
            tracing::warn!(
                "Failed to load EntityGateway config from {}: {}",
                gateway_config_path,
                e
            );
            tracing::warn!("Entity resolution features will not be available");
            None
        }
    };

    if let Some(gateway_config) = gateway_config {
        let configs_by_nickname: std::collections::HashMap<String, _> = gateway_config
            .entities
            .values()
            .map(|cfg| (cfg.nickname.clone(), cfg.clone()))
            .collect();
        let registry = Arc::new(IndexRegistry::new(configs_by_nickname));

        for entity_config in gateway_config.entities.values() {
            match TantivyIndex::new(entity_config.clone()) {
                Ok(index) => {
                    registry
                        .register(entity_config.nickname.clone(), Arc::new(index))
                        .await;
                    tracing::debug!("Registered index: {}", entity_config.nickname);
                }
                Err(e) => {
                    tracing::warn!(
                        "Failed to create index for {}: {}",
                        entity_config.nickname,
                        e
                    );
                }
            }
        }

        let refresh_registry = registry.clone();
        let refresh_config = gateway_config.clone();
        tokio::spawn(async move {
            match RefreshPipeline::new(refresh_config.clone()).await {
                Ok(pipeline) => {
                    match refresh_config.refresh.startup_mode {
                        StartupMode::Sync => {
                            tracing::info!("Performing initial index refresh (sync)...");
                            if let Err(e) = pipeline.refresh_all(&refresh_registry).await {
                                tracing::warn!("Initial refresh failed: {}", e);
                            }
                        }
                        StartupMode::Async => {
                            tracing::info!("Starting async initial refresh...");
                            let reg = refresh_registry.clone();
                            tokio::spawn(async move {
                                if let Err(e) = pipeline.refresh_all(&reg).await {
                                    tracing::error!("Async initial refresh failed: {}", e);
                                }
                            });
                        }
                    }

                    let loop_pipeline = match RefreshPipeline::new(refresh_config.clone()).await {
                        Ok(p) => p,
                        Err(e) => {
                            tracing::error!("Failed to create refresh loop pipeline: {}", e);
                            return;
                        }
                    };
                    run_refresh_loop(
                        loop_pipeline,
                        refresh_registry,
                        refresh_config.refresh.interval_secs,
                    )
                    .await;
                }
                Err(e) => {
                    tracing::warn!("Failed to initialize refresh pipeline: {}", e);
                }
            }
        });

        let grpc_service = EntityGatewayService::new(registry);
        // Default gRPC address - validated at compile time
        const DEFAULT_GRPC_ADDR: &str = "[::]:50051";
        let grpc_addr: SocketAddr = std::env::var("ENTITY_GATEWAY_ADDR")
            .unwrap_or_else(|_| DEFAULT_GRPC_ADDR.to_string())
            .parse()
            .unwrap_or_else(|e| {
                tracing::warn!(
                    "Invalid ENTITY_GATEWAY_ADDR, using default {}: {}",
                    DEFAULT_GRPC_ADDR,
                    e
                );
                DEFAULT_GRPC_ADDR
                    .parse()
                    .expect("default gRPC address is valid")
            });

        tokio::spawn(async move {
            tracing::info!("EntityGateway gRPC listening on {}", grpc_addr);
            if let Err(e) = tonic::transport::Server::builder()
                .add_service(EntityGatewayServer::new(grpc_service))
                .serve(grpc_addr)
                .await
            {
                tracing::error!("EntityGateway gRPC server error: {}", e);
            }
        });

        tracing::info!("EntityGateway started successfully");
    }

    // Create single shared session store for agent routers
    let sessions = create_session_store();

    // Create gateway resolver for entity reference resolution
    let gateway_channel = tonic::transport::Channel::from_shared(gateway_addr())
        .expect("valid gateway address")
        .connect_lazy();
    let gateway_client = EntityGatewayClient::new(gateway_channel);
    let gateway_resolver = GatewayRefResolver::new(gateway_client);

    // Create shared state for CBU/graph endpoints
    let state = AppState::new(pool.clone());

    // Static file serving - point to our static directory
    // Use manifest dir at compile time, or STATIC_DIR env var at runtime
    let static_dir = std::env::var("STATIC_DIR").unwrap_or_else(|_| {
        // Try to find static dir relative to the crate
        let manifest_dir = env!("CARGO_MANIFEST_DIR");
        format!("{}/static", manifest_dir)
    });
    tracing::info!("Serving static files from: {}", static_dir);

    // CORS for development
    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers(Any);

    // Build stateless API router (from main ob-poc crate) with SHARED session store
    // Use async semantic-enabled router for Candle-based verb search
    let agent_router = create_agent_router_with_semantic(pool.clone(), sessions.clone()).await;

    let api_router: Router<()> = Router::new()
        .merge(agent_router)
        .merge(create_attribute_router(pool.clone()))
        .merge(create_entity_router())
        .merge(create_dsl_viewer_router(pool.clone()))
        .merge(create_resolution_router(sessions.clone(), gateway_resolver))
        // Client portal router (separate auth, scoped access)
        .merge(create_client_router(pool.clone(), sessions.clone()))
        // Verb discovery router (RAG-style verb suggestions)
        .merge(create_verb_discovery_router(pool.clone()))
        // Trading matrix router (custody taxonomy browser)
        .merge(create_trading_matrix_router(pool.clone()))
        // Taxonomy navigation router (fractal drill-down)
        .merge(create_taxonomy_router(pool.clone(), sessions.clone()))
        // Deal taxonomy router (deal visualization and navigation)
        .merge(create_deal_router(pool.clone(), sessions.clone()))
        // Graph visualization (legacy CBU endpoints)
        .merge(create_graph_router(pool.clone()))
        // Session-scoped graph (shares state with REPL and taxonomy)
        .merge(create_session_graph_router(pool.clone(), sessions.clone()))
        // Galaxy navigation - universe view and cluster detail
        .merge(create_universe_router(pool.clone()))
        // Control/ownership routes (board controller, control sphere)
        .merge(control_routes(pool.clone()))
        // Session-scoped entity search (constraint cascade)
        .merge(create_scoped_entity_router(sessions.clone()))
        // Service resource pipeline (intents, discovery, readiness)
        .merge(service_resource_router(pool.clone()))
        // CBU session management (load/unload CBUs, undo/redo)
        .nest(
            "/api/cbu-session",
            create_cbu_session_router_with_pool(pool.clone()),
        );

    // Build voice matching router (semantic + phonetic)
    let voice_router = routes::voice::create_voice_router(pool.clone());

    // =========================================================================
    // Build REPL Orchestrator (new state machine architecture)
    // =========================================================================
    // Create a stub verb searcher for now - will be replaced with full implementation
    // once the orchestrator is integrated with the existing agent pipeline
    let verb_searcher = Arc::new(HybridVerbSearcher::minimal());
    let intent_matcher = Arc::new(HybridIntentMatcher::new(verb_searcher));
    let repl_orchestrator = Arc::new(ReplOrchestrator::new(intent_matcher));

    let repl_state = ReplRouteState {
        orchestrator: repl_orchestrator,
    };

    tracing::info!("REPL Orchestrator initialized (stub mode - semantic search not yet wired)");

    // React dist directory - serve assets from React build
    let react_dist_dir = std::env::var("REACT_DIST_DIR").unwrap_or_else(|_| {
        // Try to find React dist relative to the crate
        let manifest_dir = env!("CARGO_MANIFEST_DIR");
        let candidates = [
            format!("{}/../../ob-poc-ui-react/dist", manifest_dir),
            format!("{}/../../../ob-poc-ui-react/dist", manifest_dir),
        ];
        for candidate in &candidates {
            if std::path::Path::new(candidate).exists() {
                return candidate.clone();
            }
        }
        // Fallback to placeholder
        format!("{}/static", manifest_dir)
    });
    tracing::info!("Serving React assets from: {}", react_dist_dir);

    // Build main app router with state
    // Session routes (including /bind) share session store via create_agent_router_with_semantic
    // Note: CBU routes (/api/cbu, /api/cbu/:id, /api/cbu/:id/graph) are provided by create_graph_router in api_router
    let app = Router::new()
        // CBU search uses local AppState implementation
        .route("/api/cbu/search", get(routes::api::search_cbus))
        // SSE streaming for agent chat
        .route("/api/chat/stream", get(routes::chat::chat_stream))
        // React assets (JS, CSS bundles) - served from /assets/ path
        .nest_service(
            "/assets",
            ServiceBuilder::new()
                .layer(SetResponseHeaderLayer::overriding(
                    CACHE_CONTROL,
                    HeaderValue::from_static("public, max-age=31536000, immutable"),
                ))
                .service(ServeDir::new(format!("{}/assets", react_dist_dir)).precompressed_gzip()),
        )
        // Legacy static files (kept for backwards compatibility)
        .nest_service(
            "/static",
            ServiceBuilder::new()
                .layer(SetResponseHeaderLayer::overriding(
                    CACHE_CONTROL,
                    HeaderValue::from_static("no-cache, no-store, must-revalidate"),
                ))
                .service(ServeDir::new(&static_dir).precompressed_gzip()),
        )
        // Vite favicon
        .nest_service(
            "/vite.svg",
            ServeFile::new(format!("{}/vite.svg", react_dist_dir)),
        )
        // Index.html at root (React app)
        .route("/", get(routes::static_files::serve_index))
        // SPA fallback: serve index.html for client-side routing
        // This catches routes like /chat/:id, /viewport/:id, /inspector/:id
        .fallback(get(routes::static_files::serve_index))
        // Add state
        .with_state(state)
        // Merge stateless API routes (includes session, agent, entity, dsl viewer)
        .merge(api_router)
        // Voice matching routes (semantic ML + phonetic) - stateless router
        .merge(voice_router)
        // REPL state machine routes (new architecture)
        .nest("/api/repl", create_repl_router().with_state(repl_state))
        // Layers
        .layer(TraceLayer::new_for_http())
        .layer(cors);

    let port: u16 = std::env::var("SERVER_PORT")
        .ok()
        .and_then(|p| p.parse().ok())
        .unwrap_or(3000);
    let addr = SocketAddr::from(([0, 0, 0, 0], port));

    tracing::info!("");
    tracing::info!("===========================================");
    tracing::info!("  OB-POC Web Server running on http://{}", addr);
    tracing::info!("===========================================");
    tracing::info!("");
    tracing::info!("UI: http://localhost:{}", port);
    tracing::info!("");
    tracing::info!("API Endpoints:");
    tracing::info!("  /api/cbu              - List CBUs");
    tracing::info!("  /api/cbu/:id/graph    - Get CBU graph");
    tracing::info!("  /api/session          - Session management");
    tracing::info!("  /api/session/:id/resolution/* - Entity resolution");
    tracing::info!("  /api/agent/*          - DSL generation");
    tracing::info!("  /api/entity/search    - Entity search");
    tracing::info!("  /api/dsl/*            - DSL viewer");
    tracing::info!("  /api/verbs/discover   - Verb discovery (RAG)");
    tracing::info!("  /api/verbs/agent-context - Agent verb context");
    tracing::info!("  /api/voice/match      - Semantic voice matching");
    tracing::info!("  /api/voice/health     - Voice matcher health");
    tracing::info!("  /api/universe         - Galaxy universe view");
    tracing::info!("  /api/cluster/:type/:id - Cluster detail view");
    tracing::info!("");
    tracing::info!("Client Portal API:");
    tracing::info!("  /api/client/login     - Client authentication");
    tracing::info!("  /api/client/status    - Get CBU status");
    tracing::info!("  /api/client/outstanding - List outstanding requests");
    tracing::info!("  /api/client/chat      - Client chat endpoint");
    tracing::info!("");
    tracing::info!("Service Resource Pipeline:");
    tracing::info!("  POST /api/cbu/:id/service-intents   - Create service intent");
    tracing::info!("  POST /api/cbu/:id/resource-discover - Run resource discovery");
    tracing::info!("  POST /api/cbu/:id/pipeline/full     - Run full pipeline");
    tracing::info!("  GET  /api/cbu/:id/readiness         - Service readiness");
    tracing::info!("  GET  /api/srdefs                    - SRDEF registry");
    tracing::info!("");
    tracing::info!("REPL State Machine API (NEW):");
    tracing::info!("  POST /api/repl/session              - Create REPL session");
    tracing::info!("  GET  /api/repl/session/:id          - Get session state");
    tracing::info!("  POST /api/repl/session/:id/input    - Send input (unified endpoint)");
    tracing::info!("  DELETE /api/repl/session/:id        - Delete session");
    tracing::info!("");

    let listener = match tokio::net::TcpListener::bind(addr).await {
        Ok(l) => l,
        Err(e) => {
            tracing::error!("Failed to bind to {}: {}", addr, e);
            if e.kind() == std::io::ErrorKind::AddrInUse {
                tracing::error!(
                    "Port {} is already in use. Try: lsof -ti:{} | xargs kill -9",
                    port,
                    port
                );
            }
            return Err(format!("Failed to bind to {}: {}", addr, e).into());
        }
    };

    // =========================================================================
    // Initialize macro registry (operator vocabulary layer)
    // =========================================================================
    match ob_poc::mcp::init_macro_registry() {
        Ok(()) => {
            let registry = ob_poc::mcp::macro_registry();
            tracing::info!(
                "Macro registry initialized: {} macros, {} domains",
                registry.len(),
                registry.domains().count()
            );
        }
        Err(e) => {
            tracing::warn!("Macro registry initialization failed (non-fatal): {}", e);
            tracing::warn!("Operator macros will not be available");
        }
    }

    // =========================================================================
    // Spawn background learning task (non-blocking)
    // =========================================================================
    let learning_config = LearningConfig::from_env();
    let learning_status = create_learning_status();
    let shutdown_flag = Arc::new(AtomicBool::new(false));

    spawn_learning_task(
        pool.clone(),
        learning_config,
        learning_status,
        shutdown_flag,
    );

    tracing::info!("Background learning task spawned");

    if let Err(e) = axum::serve(listener, app).await {
        tracing::error!("Server error: {}", e);
        return Err(format!("Server error: {}", e).into());
    }

    Ok(())
}
