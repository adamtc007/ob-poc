//! Cache loading for the governed query proc macro.
//!
//! The cache is a bincode-serialized `GovernedCache` at a well-known path.
//! It is generated by `cargo x governed-cache refresh` and read at compile
//! time by the proc macro.

use crate::registry_types::GovernedCache;
use std::sync::OnceLock;

/// Global cache singleton. Loaded once per compilation session.
static CACHE: OnceLock<Result<GovernedCache, String>> = OnceLock::new();

/// Default cache path relative to the workspace root.
const DEFAULT_CACHE_FILENAME: &str = "assets/governed_cache.bin";

/// Load the governance cache. Returns a reference to the cached result.
///
/// Resolution order:
/// 1. `GOVERNED_CACHE_PATH` env var (absolute path)
/// 2. `CARGO_MANIFEST_DIR/../assets/governed_cache.bin` (workspace-relative)
/// 3. Walk up from CARGO_MANIFEST_DIR looking for `assets/governed_cache.bin`
pub fn load_cache() -> Result<&'static GovernedCache, String> {
    CACHE
        .get_or_init(load_cache_inner)
        .as_ref()
        .map_err(|e| e.clone())
}

fn load_cache_inner() -> Result<GovernedCache, String> {
    let path = resolve_cache_path()?;

    let bytes = std::fs::read(&path).map_err(|e| {
        format!(
            "governed_query: cannot read cache at '{}': {}. \
             Run `cargo x governed-cache refresh` to generate it.",
            path.display(),
            e
        )
    })?;

    let cache: GovernedCache = bincode::deserialize(&bytes).map_err(|e| {
        format!(
            "governed_query: cannot deserialize cache at '{}': {}. \
             Cache may be corrupted â€” run `cargo x governed-cache refresh`.",
            path.display(),
            e
        )
    })?;

    if cache.version != GovernedCache::CURRENT_VERSION {
        return Err(format!(
            "governed_query: cache version mismatch (got {}, expected {}). \
             Run `cargo x governed-cache refresh`.",
            cache.version,
            GovernedCache::CURRENT_VERSION,
        ));
    }

    Ok(cache)
}

fn resolve_cache_path() -> Result<std::path::PathBuf, String> {
    // 1. Explicit env var
    if let Ok(path) = std::env::var("GOVERNED_CACHE_PATH") {
        return Ok(std::path::PathBuf::from(path));
    }

    // 2. Walk up from CARGO_MANIFEST_DIR looking for assets/governed_cache.bin
    if let Ok(manifest_dir) = std::env::var("CARGO_MANIFEST_DIR") {
        let mut dir = std::path::PathBuf::from(&manifest_dir);
        // Walk up to find the workspace root (where assets/ lives)
        for _ in 0..5 {
            let candidate = dir.join(DEFAULT_CACHE_FILENAME);
            if candidate.exists() {
                return Ok(candidate);
            }
            if !dir.pop() {
                break;
            }
        }
    }

    Err("governed_query: cannot find governance cache. \
         Set GOVERNED_CACHE_PATH or run `cargo x governed-cache refresh`."
        .to_string())
}
