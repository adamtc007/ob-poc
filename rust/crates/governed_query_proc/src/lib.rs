//! `governed_query` — compile-time governance verification for Semantic OS.
//!
//! This proc macro makes the Semantic OS registry a compiler input.
//! Functions annotated with `#[governed_query(verb = "domain.action")]`
//! are checked at compile time against the governance cache:
//!
//! 1. **Verb lifecycle** — verb must be Active (not Deprecated/Retired)
//! 2. **Principal requirement** — Governed-tier verbs require `&Principal` param
//! 3. **PII authorization** — PII-labelled verbs/attrs require `allow_pii = true`
//! 4. **Proof rule** — Proof trust class requires Governed tier
//! 5. **Attribute lifecycle** — referenced attributes must be Active
//!
//! # Usage
//!
//! ```rust,ignore
//! #[governed_query(verb = "cbu.create")]
//! fn create_cbu(pool: &PgPool, principal: &Principal, name: &str) -> Result<Uuid> {
//!     // ...
//! }
//!
//! #[governed_query(verb = "entity.get-pii", attrs = ["entity.tax_id"], allow_pii = true)]
//! fn get_entity_pii(pool: &PgPool, principal: &Principal, id: Uuid) -> Result<PiiData> {
//!     // ...
//! }
//! ```
//!
//! # Cache
//!
//! The macro reads from `assets/governed_cache.bin`, generated by:
//! ```bash
//! cargo x governed-cache refresh
//! ```

mod cache;
mod checks;
mod parse;
mod registry_types;

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

/// Compile-time governance verification for functions that interact with
/// Semantic OS governed resources.
///
/// # Attributes
///
/// - `verb = "domain.action"` (**required**) — the verb FQN to check
/// - `attrs = ["attr1", "attr2"]` — referenced attribute FQNs
/// - `allow_pii = true` — acknowledge PII handling
/// - `skip_principal_check = true` — skip Principal parameter requirement
#[proc_macro_attribute]
pub fn governed_query(attr: TokenStream, item: TokenStream) -> TokenStream {
    let args = parse_macro_input!(attr as parse::GovernedQueryArgs);
    let input_fn = parse_macro_input!(item as ItemFn);

    // Load governance cache (once per compilation)
    let cache = match cache::load_cache() {
        Ok(c) => c,
        Err(_msg) => {
            // If cache is missing, check if we should skip (bootstrap mode)
            if std::env::var("GOVERNED_CACHE_SKIP").is_ok() {
                // Skip governance checks — emit function unchanged.
                // Used during bootstrapping before cache is generated.
                return quote! { #input_fn }.into();
            }
            // Otherwise emit a compile error pointing to the fix
            let err = syn::Error::new_spanned(&input_fn.sig.ident, _msg);
            let err_tokens = err.to_compile_error();
            return quote! {
                #err_tokens
                #input_fn
            }
            .into();
        }
    };

    // Run all 5 governance checks
    let violations = checks::run_checks(&args, &input_fn.sig, cache);

    if violations.is_empty() {
        // All checks pass — emit the function unchanged
        quote! { #input_fn }.into()
    } else {
        // Emit compile_error! for each violation, plus the original function
        // (emitting the function prevents cascading "not found" errors)
        let errors: Vec<_> = violations
            .iter()
            .map(|v| {
                let msg = &v.message;
                syn::Error::new_spanned(&input_fn.sig.ident, msg).to_compile_error()
            })
            .collect();

        quote! {
            #(#errors)*
            #input_fn
        }
        .into()
    }
}
