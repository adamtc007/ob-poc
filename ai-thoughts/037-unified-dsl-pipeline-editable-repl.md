# 037: Unified DSL Pipeline with Editable REPL

> **Status:** Plan
> **Created:** 2026-01-19

## Problem Statement

Currently DSL generation and execution has multiple paths that don't all feed the learning loop consistently. Additionally, users need the ability to edit agent-generated DSL before execution - this is a normal workflow, not an edge case.

## Design Principles

1. **Agent Everywhere** - Chat window is the primary interface, REPL is a passive but editable workspace
2. **Single Pipeline** - All DSL (NL-generated, user-typed, user-edited) flows through the same pipe
3. **Learning from Edits** - The diff between proposed and executed DSL is valuable correction signal

## User Experience

```
┌─────────────────────────────────────────────────────────────────┐
│  Chat (has focus)                     │  REPL (editable, passive)│
│                                       │                          │
│  User: "create a fund for Acme"       │  (cbu.create             │
│  Agent: Here's the DSL...             │    :name "Acme"          │
│                                       │    :jurisdiction "LU")   │
│  > cursor here                        │                          │
│                                       │  [Execute]               │
│                                       │                          │
│  Two edit paths:                      │                          │
│  A) Chat: "change jurisdiction to IE" │                          │
│  B) Click REPL, edit directly         │                          │
│                                       │                          │
│  Either way → DSL pipeline → outcome  │                          │
└─────────────────────────────────────────────────────────────────┘
```

## DSL Input Types

All inputs go through intent recognition:

| Input Type | Match Method | Example |
|------------|--------------|---------|
| Natural Language | Semantic/Exact/Phonetic | "create a fund for Acme" |
| Direct DSL | DirectDsl | "(cbu.create :name \"Acme\")" |
| Edit via Chat | Correction | "change jurisdiction to IE" |
| Edit in REPL | ReplEdit | User modifies text directly |

## Pipeline Flow

```
Any Input (NL, DirectDsl, Chat Edit, REPL Edit)
                    ↓
            Intent Recognition
            - NL → verb_search → LLM arg extraction
            - DirectDsl → parse to extract verb
            - Edit → delta from previous state
                    ↓
            Learning Loop Capture
            - phrase/input
            - match_method
            - matched_verb
            - proposed_dsl (if agent generated)
                    ↓
            DSL appears in REPL
            (editable)
                    ↓
            User clicks [Execute] or edits
                    ↓
            On Execute:
            - Capture final_dsl
            - Compute diff (proposed vs final)
                    ↓
         ┌─────────────────────────────────────────┐
         │  DSL Pipeline (same for all)            │
         │  Parse → Compile → Validate → Execute   │
         └─────────────────────────────────────────┘
                    ↓
            Outcome recorded
            - success/failed
            - error message if failed
            - user_edits (diff)
                    ↓
            Learning signal derived
```

## Schema Changes

### Migration 040: Add DSL diff tracking to intent_feedback

```sql
ALTER TABLE "ob-poc".intent_feedback
ADD COLUMN IF NOT EXISTS generated_dsl TEXT,
ADD COLUMN IF NOT EXISTS final_dsl TEXT,
ADD COLUMN IF NOT EXISTS user_edits JSONB;

COMMENT ON COLUMN "ob-poc".intent_feedback.generated_dsl IS 'DSL as generated by agent (before user edits)';
COMMENT ON COLUMN "ob-poc".intent_feedback.final_dsl IS 'DSL as actually executed (after user edits)';
COMMENT ON COLUMN "ob-poc".intent_feedback.user_edits IS 'Array of {field, from, to} edit records';
```

### MatchMethod Enum Update

Already done - added `DirectDsl` variant.

## Backend Changes

### 1. Session Context - Track Proposed DSL

```rust
// In SessionContext
pub struct SessionContext {
    // ... existing fields ...
    
    /// DSL as proposed by agent (before user edits)
    pub proposed_dsl: Option<String>,
    
    /// Current DSL in REPL (may differ from proposed)
    pub current_dsl: Option<String>,
}
```

### 2. AgentService - Detect DirectDsl Input

In `process_chat()`, before LLM call:

```rust
// Check if input looks like DSL (try to parse it)
if let Some(direct_dsl_response) = self.try_direct_dsl(&request.message, session).await {
    return Ok(direct_dsl_response);
}
```

The `try_direct_dsl` method:
1. Attempts `parse_program()` on input
2. If succeeds → extract verb from AST
3. Create MatchResult with `MatchMethod::DirectDsl`
4. Feed to learning loop
5. Return response with DSL in REPL

### 3. Execute Endpoint - Capture Diff

When executing, compare `proposed_dsl` vs `final_dsl`:

```rust
// In execute_session_dsl
let proposed = session.context.proposed_dsl.as_ref();
let final_dsl = &req.source; // What's actually being executed

let user_edits = if let Some(proposed) = proposed {
    compute_dsl_diff(proposed, final_dsl)
} else {
    None
};

// Record in learning loop
feedback_service.record_execution(
    interaction_id,
    proposed.map(|s| s.as_str()),
    final_dsl,
    user_edits.as_ref(),
    outcome,
).await;
```

### 4. FeedbackService - Extended Recording

```rust
impl FeedbackService {
    pub async fn record_execution(
        &self,
        interaction_id: Uuid,
        generated_dsl: Option<&str>,
        final_dsl: &str,
        user_edits: Option<&[DslEdit]>,
        outcome: Outcome,
    ) -> Result<()>;
}

pub struct DslEdit {
    pub field: String,
    pub from: String,
    pub to: String,
}
```

### 5. API Endpoint - REPL Edit Events

New endpoint for UI to report REPL edits:

```
POST /api/session/:id/repl-edit
{
    "current_dsl": "(cbu.create :name \"Acme\" :jurisdiction \"IE\")"
}
```

This updates `session.context.current_dsl` so we can track edits before execution.

## Learning Signals

| Scenario | Signal | Value |
|----------|--------|-------|
| NL → Execute unchanged | success | Verb match was correct |
| NL → User edits → Execute | correction | Learn from the diff |
| NL → Execute fails | false_positive | Verb match led to failure |
| DirectDsl → Execute | direct_success | User knows DSL |
| DirectDsl → Fails | direct_failure | Syntax/validation issue |

## Implementation Order

1. **Schema** - Migration 040 for diff tracking fields
2. **MatchMethod** - Already done (DirectDsl added)
3. **Session Context** - Add proposed_dsl, current_dsl fields
4. **AgentService** - Add try_direct_dsl() detection
5. **Execute Endpoint** - Capture and record diff
6. **FeedbackService** - Extended record_execution method
7. **API** - REPL edit endpoint
8. **UI** - Make REPL editable, report edits

## Files to Modify

| File | Changes |
|------|---------|
| `migrations/040_dsl_diff_tracking.sql` | New migration |
| `rust/crates/ob-semantic-matcher/src/types.rs` | MatchMethod::DirectDsl (done) |
| `rust/crates/ob-semantic-matcher/src/feedback.rs` | Extended recording |
| `rust/src/api/session.rs` | SessionContext fields |
| `rust/src/api/agent_service.rs` | try_direct_dsl() method |
| `rust/src/api/agent_routes.rs` | Execute diff capture, REPL edit endpoint |
| `rust/crates/ob-poc-ui/src/panels/repl.rs` | Editable REPL |

## Testing

1. NL input → generates DSL → execute unchanged → verify learning record
2. NL input → generates DSL → edit in REPL → execute → verify diff captured
3. Direct DSL input → verify DirectDsl match method → execute → verify outcome
4. Invalid DSL input → verify DirectDsl with parse error recorded
5. Chat edit ("change X to Y") → verify correction captured

## Open Questions

1. Should REPL edits trigger real-time validation feedback in chat?
2. How granular should user_edits be? (field-level vs full diff)
3. Should we track edit history (multiple edits before execute) or just final diff?
