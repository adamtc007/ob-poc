diff --git a/ai-thoughts/037-unified-dsl-pipeline-editable-repl.md b/ai-thoughts/037-unified-dsl-pipeline-editable-repl.md
new file mode 100644
index 00000000..e21af91e
--- /dev/null
+++ b/ai-thoughts/037-unified-dsl-pipeline-editable-repl.md
@@ -0,0 +1,243 @@
+# 037: Unified DSL Pipeline with Editable REPL
+
+> **Status:** Plan
+> **Created:** 2026-01-19
+
+## Problem Statement
+
+Currently DSL generation and execution has multiple paths that don't all feed the learning loop consistently. Additionally, users need the ability to edit agent-generated DSL before execution - this is a normal workflow, not an edge case.
+
+## Design Principles
+
+1. **Agent Everywhere** - Chat window is the primary interface, REPL is a passive but editable workspace
+2. **Single Pipeline** - All DSL (NL-generated, user-typed, user-edited) flows through the same pipe
+3. **Learning from Edits** - The diff between proposed and executed DSL is valuable correction signal
+
+## User Experience
+
+```
+┌─────────────────────────────────────────────────────────────────┐
+│  Chat (has focus)                     │  REPL (editable, passive)│
+│                                       │                          │
+│  User: "create a fund for Acme"       │  (cbu.create             │
+│  Agent: Here's the DSL...             │    :name "Acme"          │
+│                                       │    :jurisdiction "LU")   │
+│  > cursor here                        │                          │
+│                                       │  [Execute]               │
+│                                       │                          │
+│  Two edit paths:                      │                          │
+│  A) Chat: "change jurisdiction to IE" │                          │
+│  B) Click REPL, edit directly         │                          │
+│                                       │                          │
+│  Either way → DSL pipeline → outcome  │                          │
+└─────────────────────────────────────────────────────────────────┘
+```
+
+## DSL Input Types
+
+All inputs go through intent recognition:
+
+| Input Type | Match Method | Example |
+|------------|--------------|---------|
+| Natural Language | Semantic/Exact/Phonetic | "create a fund for Acme" |
+| Direct DSL | DirectDsl | "(cbu.create :name \"Acme\")" |
+| Edit via Chat | Correction | "change jurisdiction to IE" |
+| Edit in REPL | ReplEdit | User modifies text directly |
+
+## Pipeline Flow
+
+```
+Any Input (NL, DirectDsl, Chat Edit, REPL Edit)
+                    ↓
+            Intent Recognition
+            - NL → verb_search → LLM arg extraction
+            - DirectDsl → parse to extract verb
+            - Edit → delta from previous state
+                    ↓
+            Learning Loop Capture
+            - phrase/input
+            - match_method
+            - matched_verb
+            - proposed_dsl (if agent generated)
+                    ↓
+            DSL appears in REPL
+            (editable)
+                    ↓
+            User clicks [Execute] or edits
+                    ↓
+            On Execute:
+            - Capture final_dsl
+            - Compute diff (proposed vs final)
+                    ↓
+         ┌─────────────────────────────────────────┐
+         │  DSL Pipeline (same for all)            │
+         │  Parse → Compile → Validate → Execute   │
+         └─────────────────────────────────────────┘
+                    ↓
+            Outcome recorded
+            - success/failed
+            - error message if failed
+            - user_edits (diff)
+                    ↓
+            Learning signal derived
+```
+
+## Schema Changes
+
+### Migration 040: Add DSL diff tracking to intent_feedback
+
+```sql
+ALTER TABLE "ob-poc".intent_feedback
+ADD COLUMN IF NOT EXISTS generated_dsl TEXT,
+ADD COLUMN IF NOT EXISTS final_dsl TEXT,
+ADD COLUMN IF NOT EXISTS user_edits JSONB;
+
+COMMENT ON COLUMN "ob-poc".intent_feedback.generated_dsl IS 'DSL as generated by agent (before user edits)';
+COMMENT ON COLUMN "ob-poc".intent_feedback.final_dsl IS 'DSL as actually executed (after user edits)';
+COMMENT ON COLUMN "ob-poc".intent_feedback.user_edits IS 'Array of {field, from, to} edit records';
+```
+
+### MatchMethod Enum Update
+
+Already done - added `DirectDsl` variant.
+
+## Backend Changes
+
+### 1. Session Context - Track Proposed DSL
+
+```rust
+// In SessionContext
+pub struct SessionContext {
+    // ... existing fields ...
+    
+    /// DSL as proposed by agent (before user edits)
+    pub proposed_dsl: Option<String>,
+    
+    /// Current DSL in REPL (may differ from proposed)
+    pub current_dsl: Option<String>,
+}
+```
+
+### 2. AgentService - Detect DirectDsl Input
+
+In `process_chat()`, before LLM call:
+
+```rust
+// Check if input looks like DSL (try to parse it)
+if let Some(direct_dsl_response) = self.try_direct_dsl(&request.message, session).await {
+    return Ok(direct_dsl_response);
+}
+```
+
+The `try_direct_dsl` method:
+1. Attempts `parse_program()` on input
+2. If succeeds → extract verb from AST
+3. Create MatchResult with `MatchMethod::DirectDsl`
+4. Feed to learning loop
+5. Return response with DSL in REPL
+
+### 3. Execute Endpoint - Capture Diff
+
+When executing, compare `proposed_dsl` vs `final_dsl`:
+
+```rust
+// In execute_session_dsl
+let proposed = session.context.proposed_dsl.as_ref();
+let final_dsl = &req.source; // What's actually being executed
+
+let user_edits = if let Some(proposed) = proposed {
+    compute_dsl_diff(proposed, final_dsl)
+} else {
+    None
+};
+
+// Record in learning loop
+feedback_service.record_execution(
+    interaction_id,
+    proposed.map(|s| s.as_str()),
+    final_dsl,
+    user_edits.as_ref(),
+    outcome,
+).await;
+```
+
+### 4. FeedbackService - Extended Recording
+
+```rust
+impl FeedbackService {
+    pub async fn record_execution(
+        &self,
+        interaction_id: Uuid,
+        generated_dsl: Option<&str>,
+        final_dsl: &str,
+        user_edits: Option<&[DslEdit]>,
+        outcome: Outcome,
+    ) -> Result<()>;
+}
+
+pub struct DslEdit {
+    pub field: String,
+    pub from: String,
+    pub to: String,
+}
+```
+
+### 5. API Endpoint - REPL Edit Events
+
+New endpoint for UI to report REPL edits:
+
+```
+POST /api/session/:id/repl-edit
+{
+    "current_dsl": "(cbu.create :name \"Acme\" :jurisdiction \"IE\")"
+}
+```
+
+This updates `session.context.current_dsl` so we can track edits before execution.
+
+## Learning Signals
+
+| Scenario | Signal | Value |
+|----------|--------|-------|
+| NL → Execute unchanged | success | Verb match was correct |
+| NL → User edits → Execute | correction | Learn from the diff |
+| NL → Execute fails | false_positive | Verb match led to failure |
+| DirectDsl → Execute | direct_success | User knows DSL |
+| DirectDsl → Fails | direct_failure | Syntax/validation issue |
+
+## Implementation Order
+
+1. **Schema** - Migration 040 for diff tracking fields
+2. **MatchMethod** - Already done (DirectDsl added)
+3. **Session Context** - Add proposed_dsl, current_dsl fields
+4. **AgentService** - Add try_direct_dsl() detection
+5. **Execute Endpoint** - Capture and record diff
+6. **FeedbackService** - Extended record_execution method
+7. **API** - REPL edit endpoint
+8. **UI** - Make REPL editable, report edits
+
+## Files to Modify
+
+| File | Changes |
+|------|---------|
+| `migrations/040_dsl_diff_tracking.sql` | New migration |
+| `rust/crates/ob-semantic-matcher/src/types.rs` | MatchMethod::DirectDsl (done) |
+| `rust/crates/ob-semantic-matcher/src/feedback.rs` | Extended recording |
+| `rust/src/api/session.rs` | SessionContext fields |
+| `rust/src/api/agent_service.rs` | try_direct_dsl() method |
+| `rust/src/api/agent_routes.rs` | Execute diff capture, REPL edit endpoint |
+| `rust/crates/ob-poc-ui/src/panels/repl.rs` | Editable REPL |
+
+## Testing
+
+1. NL input → generates DSL → execute unchanged → verify learning record
+2. NL input → generates DSL → edit in REPL → execute → verify diff captured
+3. Direct DSL input → verify DirectDsl match method → execute → verify outcome
+4. Invalid DSL input → verify DirectDsl with parse error recorded
+5. Chat edit ("change X to Y") → verify correction captured
+
+## Open Questions
+
+1. Should REPL edits trigger real-time validation feedback in chat?
+2. How granular should user_edits be? (field-level vs full diff)
+3. Should we track edit history (multiple edits before execute) or just final diff?
diff --git a/migrations/040_dsl_diff_tracking.sql b/migrations/040_dsl_diff_tracking.sql
new file mode 100644
index 00000000..f37582b6
--- /dev/null
+++ b/migrations/040_dsl_diff_tracking.sql
@@ -0,0 +1,95 @@
+-- Migration 040: DSL Diff Tracking for Learning Loop
+--
+-- Captures the diff between agent-generated DSL and what the user actually executed.
+-- This is valuable correction signal for improving the agent.
+
+-- Add DSL tracking columns to intent_feedback
+ALTER TABLE "ob-poc".intent_feedback
+ADD COLUMN IF NOT EXISTS generated_dsl TEXT,
+ADD COLUMN IF NOT EXISTS final_dsl TEXT,
+ADD COLUMN IF NOT EXISTS user_edits JSONB;
+
+COMMENT ON COLUMN "ob-poc".intent_feedback.generated_dsl IS 'DSL as generated by agent (before user edits)';
+COMMENT ON COLUMN "ob-poc".intent_feedback.final_dsl IS 'DSL as actually executed (after user edits)';
+COMMENT ON COLUMN "ob-poc".intent_feedback.user_edits IS 'Array of {field, from, to} edit records capturing what user changed';
+
+-- Add direct_dsl to match_method enum if not exists
+DO $$
+BEGIN
+    -- Check if direct_dsl already exists in the enum
+    IF NOT EXISTS (
+        SELECT 1 FROM pg_enum
+        WHERE enumlabel = 'direct_dsl'
+        AND enumtypid = (SELECT oid FROM pg_type WHERE typname = 'match_method' AND typnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'ob-poc'))
+    ) THEN
+        ALTER TYPE "ob-poc".match_method ADD VALUE IF NOT EXISTS 'direct_dsl';
+    END IF;
+END$$;
+
+-- Update the learning feedback view to include DSL diff info
+CREATE OR REPLACE VIEW "ob-poc".v_learning_feedback AS
+SELECT
+    f.id,
+    f.interaction_id,
+    f.session_id,
+    f.input_phrase,
+    f.input_source,
+    f.matched_verb,
+    f.match_method,
+    f.similarity_score,
+    f.domain_context,
+    f.outcome,
+    f.generated_dsl,
+    f.final_dsl,
+    f.user_edits,
+    f.created_at,
+    g.execution_status,
+    g.execution_error,
+    g.executed_at,
+    -- Learning signal derivation
+    CASE
+        WHEN f.outcome = 'executed' AND f.user_edits IS NULL THEN 'success'
+        WHEN f.outcome = 'executed' AND f.user_edits IS NOT NULL THEN 'correction'
+        WHEN f.outcome = 'wrong_match' THEN 'wrong_match'
+        WHEN f.outcome = 'rejected' THEN 'rejection'
+        WHEN f.matched_verb IS NULL THEN 'no_match'
+        WHEN g.execution_status = 'failed' THEN 'false_positive'
+        ELSE 'pending'
+    END AS learning_signal,
+    -- Was DSL edited?
+    CASE
+        WHEN f.generated_dsl IS NOT NULL AND f.final_dsl IS NOT NULL
+             AND f.generated_dsl != f.final_dsl THEN true
+        ELSE false
+    END AS was_edited,
+    -- Time from phrase to execution
+    CASE
+        WHEN g.executed_at IS NOT NULL THEN
+            EXTRACT(EPOCH FROM (g.executed_at - f.created_at)) * 1000
+        ELSE NULL
+    END AS phrase_to_execution_ms
+FROM "ob-poc".intent_feedback f
+LEFT JOIN "ob-poc".dsl_generation_log g ON g.intent_feedback_id = f.id;
+
+-- Index for finding corrections (edited DSL)
+CREATE INDEX IF NOT EXISTS idx_intent_feedback_has_edits
+ON "ob-poc".intent_feedback ((user_edits IS NOT NULL))
+WHERE user_edits IS NOT NULL;
+
+-- View for analyzing user corrections
+CREATE OR REPLACE VIEW "ob-poc".v_user_corrections AS
+SELECT
+    f.matched_verb,
+    f.input_phrase,
+    f.generated_dsl,
+    f.final_dsl,
+    f.user_edits,
+    jsonb_array_length(f.user_edits) AS edit_count,
+    f.outcome,
+    f.created_at
+FROM "ob-poc".intent_feedback f
+WHERE f.user_edits IS NOT NULL
+  AND jsonb_array_length(f.user_edits) > 0
+ORDER BY f.created_at DESC;
+
+COMMENT ON VIEW "ob-poc".v_user_corrections IS 'Shows cases where users edited agent-generated DSL - valuable for learning';
diff --git a/rust/crates/ob-semantic-matcher/src/feedback/repository.rs b/rust/crates/ob-semantic-matcher/src/feedback/repository.rs
index 12281656..472d04e3 100644
--- a/rust/crates/ob-semantic-matcher/src/feedback/repository.rs
+++ b/rust/crates/ob-semantic-matcher/src/feedback/repository.rs
@@ -59,7 +59,10 @@ impl FeedbackRepository {
             SET outcome = $2,
                 outcome_verb = $3,
                 correction_input = $4,
-                time_to_outcome_ms = $5
+                time_to_outcome_ms = $5,
+                generated_dsl = $6,
+                final_dsl = $7,
+                user_edits = $8
             WHERE interaction_id = $1
               AND outcome IS NULL
             "#,
@@ -69,6 +72,9 @@ impl FeedbackRepository {
         .bind(&update.outcome_verb)
         .bind(&update.correction_input)
         .bind(update.time_to_outcome_ms)
+        .bind(&update.generated_dsl)
+        .bind(&update.final_dsl)
+        .bind(&update.user_edits)
         .execute(&self.pool)
         .await?;
 
diff --git a/rust/crates/ob-semantic-matcher/src/feedback/service.rs b/rust/crates/ob-semantic-matcher/src/feedback/service.rs
index 19c857e5..0e8e239f 100644
--- a/rust/crates/ob-semantic-matcher/src/feedback/service.rs
+++ b/rust/crates/ob-semantic-matcher/src/feedback/service.rs
@@ -91,6 +91,32 @@ impl FeedbackService {
         outcome_verb: Option<String>,
         correction_input: Option<String>,
         time_to_outcome_ms: Option<i32>,
+    ) -> Result<bool> {
+        self.record_outcome_with_dsl(
+            interaction_id,
+            outcome,
+            outcome_verb,
+            correction_input,
+            time_to_outcome_ms,
+            None,
+            None,
+            None,
+        )
+        .await
+    }
+
+    /// Record the outcome of an interaction with DSL diff tracking
+    #[allow(clippy::too_many_arguments)]
+    pub async fn record_outcome_with_dsl(
+        &self,
+        interaction_id: Uuid,
+        outcome: Outcome,
+        outcome_verb: Option<String>,
+        correction_input: Option<String>,
+        time_to_outcome_ms: Option<i32>,
+        generated_dsl: Option<String>,
+        final_dsl: Option<String>,
+        user_edits: Option<serde_json::Value>,
     ) -> Result<bool> {
         let update = OutcomeUpdate {
             interaction_id,
@@ -98,6 +124,9 @@ impl FeedbackService {
             outcome_verb,
             correction_input,
             time_to_outcome_ms,
+            generated_dsl,
+            final_dsl,
+            user_edits,
         };
 
         self.repository.record_outcome(&update).await
diff --git a/rust/crates/ob-semantic-matcher/src/feedback/types.rs b/rust/crates/ob-semantic-matcher/src/feedback/types.rs
index 86f460c1..ca7adab0 100644
--- a/rust/crates/ob-semantic-matcher/src/feedback/types.rs
+++ b/rust/crates/ob-semantic-matcher/src/feedback/types.rs
@@ -116,6 +116,12 @@ pub struct OutcomeUpdate {
     pub outcome_verb: Option<String>,
     pub correction_input: Option<String>,
     pub time_to_outcome_ms: Option<i32>,
+    /// DSL as generated by agent (before user edits)
+    pub generated_dsl: Option<String>,
+    /// DSL as actually executed (after user edits)
+    pub final_dsl: Option<String>,
+    /// JSON array of {field, from, to} edit records
+    pub user_edits: Option<serde_json::Value>,
 }
 
 /// Analysis result types
diff --git a/rust/crates/ob-semantic-matcher/src/types.rs b/rust/crates/ob-semantic-matcher/src/types.rs
index f7e71a04..b5db7973 100644
--- a/rust/crates/ob-semantic-matcher/src/types.rs
+++ b/rust/crates/ob-semantic-matcher/src/types.rs
@@ -36,6 +36,8 @@ pub enum MatchMethod {
     Exact,
     /// Cached from previous lookup
     Cached,
+    /// User input DSL directly - verb extracted from syntax
+    DirectDsl,
 }
 
 impl std::fmt::Display for MatchMethod {
@@ -45,6 +47,7 @@ impl std::fmt::Display for MatchMethod {
             MatchMethod::Phonetic => write!(f, "phonetic"),
             MatchMethod::Exact => write!(f, "exact"),
             MatchMethod::Cached => write!(f, "cached"),
+            MatchMethod::DirectDsl => write!(f, "direct_dsl"),
         }
     }
 }
diff --git a/rust/src/api/agent_routes.rs b/rust/src/api/agent_routes.rs
index 61a29431..6660a8ae 100644
--- a/rust/src/api/agent_routes.rs
+++ b/rust/src/api/agent_routes.rs
@@ -828,6 +828,7 @@ pub fn create_agent_router_with_sessions(pool: PgPool, sessions: SessionStore) -
         .route("/api/session/:id", delete(delete_session))
         .route("/api/session/:id/chat", post(chat_session))
         .route("/api/session/:id/execute", post(execute_session_dsl))
+        .route("/api/session/:id/repl-edit", post(repl_edit_session))
         .route("/api/session/:id/clear", post(clear_session_dsl))
         .route("/api/session/:id/bind", post(set_session_binding))
         .route("/api/session/:id/context", get(get_session_context))
@@ -2215,12 +2216,21 @@ async fn chat_session(
     // =========================================================================
     if !response.intents.is_empty() {
         let first_intent = &response.intents[0];
+
+        // Determine match method: DirectDsl if user typed DSL, Semantic if LLM generated
+        let is_direct_dsl = req.message.trim().starts_with('(');
+        let match_method = if is_direct_dsl {
+            ob_semantic_matcher::MatchMethod::DirectDsl
+        } else {
+            ob_semantic_matcher::MatchMethod::Semantic
+        };
+
         // Build a MatchResult from the intent for feedback capture
         let match_result = ob_semantic_matcher::MatchResult {
             verb_name: first_intent.verb.clone(),
             pattern_phrase: req.message.clone(), // The user's input
-            similarity: 1.0,                     // LLM selected this verb
-            match_method: ob_semantic_matcher::MatchMethod::Semantic, // LLM uses semantic understanding
+            similarity: if is_direct_dsl { 1.0 } else { 1.0 }, // Direct or LLM selected
+            match_method,
             category: "chat".to_string(),
             is_agent_bound: true,
         };
@@ -2252,9 +2262,10 @@ async fn chat_session(
                 {
                     session.context.pending_feedback_id = Some(feedback_id);
                     tracing::debug!(
-                        "Captured feedback: interaction_id={}, feedback_id={}",
+                        "Captured feedback: interaction_id={}, feedback_id={}, method={:?}",
                         interaction_id,
-                        feedback_id
+                        feedback_id,
+                        match_method
                     );
                 }
             }
@@ -2264,6 +2275,20 @@ async fn chat_session(
         }
     }
 
+    // =========================================================================
+    // TRACK PROPOSED DSL FOR DIFF (learning from user edits)
+    // =========================================================================
+    if let Some(ref dsl_source) = response.dsl_source {
+        // Only set proposed_dsl if agent generated it (not DirectDsl)
+        let is_direct_dsl = req.message.trim().starts_with('(');
+        if !is_direct_dsl {
+            state
+                .session_manager
+                .set_proposed_dsl(session_id, dsl_source)
+                .await;
+        }
+    }
+
     // Persist session changes back
     {
         let mut sessions = state.sessions.write().await;
@@ -2900,6 +2925,30 @@ async fn execute_session_dsl(
                 }
             }
 
+            // =========================================================================
+            // CAPTURE DSL DIFF FOR LEARNING (proposed vs final)
+            // =========================================================================
+            let dsl_diff = state
+                .session_manager
+                .capture_dsl_diff(session_id, &dsl)
+                .await;
+            if let Some(ref diff) = dsl_diff {
+                if diff.was_edited {
+                    tracing::info!(
+                        "[EXEC] DSL was edited by user: {} edit(s) detected",
+                        diff.edits.len()
+                    );
+                    for edit in &diff.edits {
+                        tracing::debug!(
+                            "[EXEC] Edit: {} changed from '{}' to '{}'",
+                            edit.field,
+                            edit.from,
+                            edit.to
+                        );
+                    }
+                }
+            }
+
             // =========================================================================
             // LOG SUCCESS
             // =========================================================================
@@ -2938,17 +2987,38 @@ async fn execute_session_dsl(
                     .await;
             }
 
-            // Update intent_feedback outcome
+            // Update intent_feedback outcome with DSL diff
             if let Some(interaction_id) = pending_interaction_id {
                 let elapsed_ms = start_time.elapsed().as_millis() as i32;
+
+                // Convert DSL diff to feedback format
+                let (generated_dsl, final_dsl_str, user_edits_json) =
+                    if let Some(ref diff) = dsl_diff {
+                        let edits_json = if diff.edits.is_empty() {
+                            None
+                        } else {
+                            Some(serde_json::to_value(&diff.edits).unwrap_or_default())
+                        };
+                        (
+                            Some(diff.proposed.clone()),
+                            Some(diff.final_dsl.clone()),
+                            edits_json,
+                        )
+                    } else {
+                        (None, Some(dsl.clone()), None)
+                    };
+
                 let _ = state
                     .feedback_service
-                    .record_outcome(
+                    .record_outcome_with_dsl(
                         interaction_id,
                         ob_semantic_matcher::feedback::Outcome::Executed,
                         None, // outcome_verb same as matched
                         None, // no correction
                         Some(elapsed_ms),
+                        generated_dsl,
+                        final_dsl_str,
+                        user_edits_json,
                     )
                     .await;
             }
@@ -3236,6 +3306,52 @@ async fn execute_session_dsl(
     }))
 }
 
+/// POST /api/session/:id/repl-edit - Record REPL edit event
+///
+/// Called by the UI when the user edits DSL in the REPL editor.
+/// This tracks the current_dsl so we can compute diff on execute.
+async fn repl_edit_session(
+    State(state): State<AgentState>,
+    Path(session_id): Path<Uuid>,
+    Json(req): Json<ReplEditRequest>,
+) -> Result<Json<ReplEditResponse>, StatusCode> {
+    use crate::dsl_v2::parse_program;
+
+    tracing::debug!(
+        "[REPL_EDIT] Session {} - DSL length: {}",
+        session_id,
+        req.current_dsl.len()
+    );
+
+    // Update current_dsl in session via SessionManager
+    state
+        .session_manager
+        .update_current_dsl(session_id, &req.current_dsl)
+        .await;
+
+    // Check if there are edits (proposed != current)
+    let has_edits = state.session_manager.has_dsl_edits(session_id).await;
+
+    // Validate the current DSL
+    let (valid, errors) = match parse_program(&req.current_dsl) {
+        Ok(ast) => {
+            // Parse succeeded, try compile
+            match crate::dsl_v2::compile(&ast) {
+                Ok(_) => (true, None),
+                Err(e) => (false, Some(vec![format!("Compile error: {:?}", e)])),
+            }
+        }
+        Err(e) => (false, Some(vec![format!("Parse error: {:?}", e)])),
+    };
+
+    Ok(Json(ReplEditResponse {
+        recorded: true,
+        has_edits,
+        valid,
+        errors,
+    }))
+}
+
 /// POST /api/session/:id/clear - Clear/cancel pending DSL
 async fn clear_session_dsl(
     State(state): State<AgentState>,
@@ -5663,6 +5779,27 @@ pub struct ExecuteDslRequest {
     pub dsl: Option<String>,
 }
 
+/// Request body for REPL edit events
+#[derive(Debug, Clone, Deserialize)]
+pub struct ReplEditRequest {
+    /// Current DSL content in the REPL editor
+    pub current_dsl: String,
+}
+
+/// Response for REPL edit events
+#[derive(Debug, Clone, Serialize)]
+pub struct ReplEditResponse {
+    /// Whether the edit was recorded
+    pub recorded: bool,
+    /// Whether the DSL differs from the proposed DSL
+    pub has_edits: bool,
+    /// Validation status of the current DSL
+    pub valid: bool,
+    /// Validation errors if any
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub errors: Option<Vec<String>>,
+}
+
 // NOTE: Direct /execute endpoint removed - use /api/session/:id/execute instead
 // All DSL execution now requires a session for proper binding persistence and audit trail
 
diff --git a/rust/src/api/agent_service.rs b/rust/src/api/agent_service.rs
index 53bdceb2..ffc2fdf8 100644
--- a/rust/src/api/agent_service.rs
+++ b/rust/src/api/agent_service.rs
@@ -846,6 +846,13 @@ Use `(kyc-case.state :case-id @case)` to get full state with embedded awaiting r
             return Ok(response);
         }
 
+        // Handle direct DSL input (user types DSL directly)
+        // This recognizes the intent and extracts verb(s), but DSL still goes through
+        // all gates (parse/compile/validate/execute) on the execute path
+        if let Some(response) = self.try_direct_dsl(&request.message, session) {
+            return Ok(response);
+        }
+
         // If this is a disambiguation response, handle it
         if let Some(disambig_response) = &request.disambiguation_response {
             return self
@@ -1758,6 +1765,163 @@ Use `(kyc-case.state :case-id @case)` to get full state with embedded awaiting r
     // NOTE: Legacy handle_esper_command removed - now using trie-based EsperCommandRegistry
     // See handle_esper_command() above (line ~1388) which uses registry.lookup_with_semantic()
 
+    /// Handle direct DSL input from user
+    ///
+    /// When user types DSL directly (e.g., "(cbu.create :name \"Acme\")"), we:
+    /// 1. Try to parse it as DSL
+    /// 2. If successful, extract the verb(s) from the AST
+    /// 3. Create a DirectDsl match for the learning loop
+    /// 4. Return the DSL for display in REPL (still goes through all gates on execute)
+    ///
+    /// This is NOT a bypass - the DSL still flows through parse/compile/validate/execute
+    /// on the execute path. This just recognizes the intent and extracts the verb.
+    fn try_direct_dsl(
+        &self,
+        message: &str,
+        session: &mut AgentSession,
+    ) -> Option<AgentChatResponse> {
+        use crate::dsl_v2::parse_program;
+
+        let trimmed = message.trim();
+
+        // Quick heuristic: DSL starts with '('
+        if !trimmed.starts_with('(') {
+            return None;
+        }
+
+        // Try to parse as DSL
+        let ast = match parse_program(trimmed) {
+            Ok(ast) => ast,
+            Err(parse_error) => {
+                // Looks like DSL but doesn't parse - still DirectDsl intent, but with error
+                tracing::debug!("DirectDsl parse error: {:?}", parse_error);
+
+                // Return helpful error message
+                return Some(AgentChatResponse {
+                    message: format!(
+                        "I see you're writing DSL directly. There's a syntax error:\n\n```\n{}\n```\n\nError: {:?}",
+                        trimmed, parse_error
+                    ),
+                    intents: vec![],
+                    validation_results: vec![],
+                    session_state: SessionState::PendingValidation,
+                    can_execute: false,
+                    dsl_source: Some(trimmed.to_string()),
+                    ast: None,
+                    disambiguation: None,
+                    commands: None,
+                    unresolved_refs: None,
+                    current_ref_index: None,
+                });
+            }
+        };
+
+        // Extract verb(s) from AST
+        let verbs: Vec<String> = ast
+            .statements
+            .iter()
+            .filter_map(|stmt| {
+                if let crate::dsl_v2::Statement::VerbCall(call) = stmt {
+                    Some(format!("{}.{}", call.domain, call.verb))
+                } else {
+                    None
+                }
+            })
+            .collect();
+
+        if verbs.is_empty() {
+            return None; // No verb calls found, let it fall through
+        }
+
+        let primary_verb = verbs.first().cloned().unwrap_or_default();
+
+        // Store user message
+        session.add_user_message(message.to_string());
+
+        // Build intents from parsed AST for validation
+        let intents: Vec<VerbIntent> = ast
+            .statements
+            .iter()
+            .filter_map(|stmt| {
+                if let crate::dsl_v2::Statement::VerbCall(call) = stmt {
+                    Some(VerbIntent {
+                        verb: format!("{}.{}", call.domain, call.verb),
+                        parameters: call
+                            .arguments
+                            .iter()
+                            .map(|arg| crate::api::intent::IntentParam {
+                                name: arg.key.clone(),
+                                value: ParamValue::String(format!("{:?}", arg.value)),
+                            })
+                            .collect(),
+                        lookups: std::collections::HashMap::new(),
+                        refs: std::collections::HashMap::new(),
+                        binding: call.bind_as.clone(),
+                    })
+                } else {
+                    None
+                }
+            })
+            .collect();
+
+        // Validate intents
+        let validation_results: Vec<IntentValidation> =
+            intents.iter().map(|i| validate_intent(i)).collect();
+
+        let all_valid = validation_results.iter().all(|v| v.valid);
+
+        // Build response message
+        let verb_list = verbs.join(", ");
+        let response_message = if all_valid {
+            format!(
+                "I see you're writing DSL directly. Detected verb(s): {}\n\nReady to execute.",
+                verb_list
+            )
+        } else {
+            let errors: Vec<String> = validation_results
+                .iter()
+                .flat_map(|v| v.errors.iter().map(|e| e.message.clone()))
+                .collect();
+            format!(
+                "I see you're writing DSL directly. Detected verb(s): {}\n\nValidation issues:\n- {}",
+                verb_list,
+                errors.join("\n- ")
+            )
+        };
+
+        // Update session state
+        session.state = if all_valid {
+            SessionState::ReadyToExecute
+        } else {
+            SessionState::PendingValidation
+        };
+
+        // Store the DSL in session for tracking
+        session.context.proposed_dsl = None; // No agent-proposed DSL for DirectDsl
+        session.context.current_dsl = Some(trimmed.to_string());
+
+        tracing::info!(
+            "DirectDsl detected: verb={}, valid={}, statement_count={}",
+            primary_verb,
+            all_valid,
+            ast.statements.len()
+        );
+
+        Some(AgentChatResponse {
+            message: response_message,
+            intents,
+            validation_results,
+            session_state: session.state.clone(),
+            can_execute: all_valid,
+            dsl_source: Some(trimmed.to_string()),
+            ast: Some(ast.statements),
+            disambiguation: None,
+            commands: None,
+            unresolved_refs: None,
+            current_ref_index: None,
+        })
+    }
+
     /// Handle "show/load/select CBU" commands
     async fn handle_show_command(
         &self,
diff --git a/rust/src/api/session.rs b/rust/src/api/session.rs
index e6b60001..6a9eed56 100644
--- a/rust/src/api/session.rs
+++ b/rust/src/api/session.rs
@@ -2049,6 +2049,19 @@ pub struct SessionContext {
     /// Used to call FeedbackService.record_outcome() after execution
     #[serde(skip_serializing_if = "Option::is_none")]
     pub pending_interaction_id: Option<Uuid>,
+
+    // =========================================================================
+    // DSL Diff Tracking (for learning from user edits)
+    // =========================================================================
+    /// DSL as proposed by agent (before user edits in REPL)
+    /// Set when agent generates DSL, compared against final_dsl on execute
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub proposed_dsl: Option<String>,
+
+    /// Current DSL in REPL (may differ from proposed if user edited)
+    /// Updated via REPL edit events, used to compute diff on execute
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub current_dsl: Option<String>,
 }
 
 /// Primary domain keys tracked across the session
diff --git a/rust/src/api/session_manager.rs b/rust/src/api/session_manager.rs
index 2c537636..6c5ab0f4 100644
--- a/rust/src/api/session_manager.rs
+++ b/rust/src/api/session_manager.rs
@@ -340,6 +340,209 @@ impl Clone for SessionManager {
     }
 }
 
+// =============================================================================
+// DSL Diff Tracking for Learning Loop
+// =============================================================================
+
+/// A single edit made by the user to the proposed DSL
+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
+pub struct DslEdit {
+    /// The field/parameter that was changed
+    pub field: String,
+    /// Original value (from proposed DSL)
+    pub from: String,
+    /// New value (in final DSL)
+    pub to: String,
+}
+
+/// Result of computing DSL diff
+#[derive(Debug, Clone)]
+pub struct DslDiff {
+    /// DSL as proposed by agent
+    pub proposed: String,
+    /// DSL as executed (after user edits)
+    pub final_dsl: String,
+    /// Individual edits detected
+    pub edits: Vec<DslEdit>,
+    /// Whether any edits were made
+    pub was_edited: bool,
+}
+
+impl SessionManager {
+    // =========================================================================
+    // DSL Diff Tracking Methods
+    // =========================================================================
+
+    /// Set the proposed DSL (called when agent generates DSL)
+    ///
+    /// This captures the DSL as generated by the agent, before any user edits.
+    /// Also sets current_dsl to the same value initially.
+    pub async fn set_proposed_dsl(&self, session_id: Uuid, dsl: &str) {
+        self.update_session(session_id, |session| {
+            session.context.proposed_dsl = Some(dsl.to_string());
+            session.context.current_dsl = Some(dsl.to_string());
+        })
+        .await;
+    }
+
+    /// Update the current DSL (called when REPL edit happens)
+    ///
+    /// This tracks what the user has edited in the REPL.
+    pub async fn update_current_dsl(&self, session_id: Uuid, dsl: &str) {
+        self.update_session(session_id, |session| {
+            session.context.current_dsl = Some(dsl.to_string());
+        })
+        .await;
+    }
+
+    /// Capture DSL diff and clear tracking state (called before execute)
+    ///
+    /// Returns the diff between proposed and current DSL, then clears the
+    /// tracking fields so the next interaction starts fresh.
+    pub async fn capture_dsl_diff(&self, session_id: Uuid, final_dsl: &str) -> Option<DslDiff> {
+        self.update_session_with(session_id, |session| {
+            let proposed = session.context.proposed_dsl.take();
+            let _ = session.context.current_dsl.take(); // Clear but don't need
+
+            match proposed {
+                Some(proposed_dsl) => {
+                    let edits = compute_dsl_edits(&proposed_dsl, final_dsl);
+                    let was_edited = !edits.is_empty();
+
+                    Some(DslDiff {
+                        proposed: proposed_dsl,
+                        final_dsl: final_dsl.to_string(),
+                        edits,
+                        was_edited,
+                    })
+                }
+                None => {
+                    // No proposed DSL - this might be direct DSL input
+                    // Still return a diff structure but with no edits
+                    Some(DslDiff {
+                        proposed: final_dsl.to_string(),
+                        final_dsl: final_dsl.to_string(),
+                        edits: vec![],
+                        was_edited: false,
+                    })
+                }
+            }
+        })
+        .await
+        .flatten()
+    }
+
+    /// Get the current proposed DSL (for inspection)
+    pub async fn get_proposed_dsl(&self, session_id: Uuid) -> Option<String> {
+        self.query_session(session_id, |session| session.context.proposed_dsl.clone())
+            .await
+            .flatten()
+    }
+
+    /// Get the current DSL in REPL (for inspection)
+    pub async fn get_current_dsl(&self, session_id: Uuid) -> Option<String> {
+        self.query_session(session_id, |session| session.context.current_dsl.clone())
+            .await
+            .flatten()
+    }
+
+    /// Check if DSL has been edited (proposed != current)
+    pub async fn has_dsl_edits(&self, session_id: Uuid) -> bool {
+        self.query_session(session_id, |session| {
+            match (&session.context.proposed_dsl, &session.context.current_dsl) {
+                (Some(proposed), Some(current)) => proposed != current,
+                _ => false,
+            }
+        })
+        .await
+        .unwrap_or(false)
+    }
+}
+
+/// Compute field-level edits between two DSL strings
+///
+/// This is a simple diff that looks for parameter value changes.
+/// For a more sophisticated diff, we could parse both and compare ASTs.
+fn compute_dsl_edits(proposed: &str, final_dsl: &str) -> Vec<DslEdit> {
+    use crate::dsl_v2::parse_program;
+
+    let mut edits = Vec::new();
+
+    // Try to parse both DSL strings
+    let proposed_ast = match parse_program(proposed) {
+        Ok(ast) => ast,
+        Err(_) => return edits, // Can't diff if we can't parse
+    };
+
+    let final_ast = match parse_program(final_dsl) {
+        Ok(ast) => ast,
+        Err(_) => return edits,
+    };
+
+    // Compare statements (simple case: same number of statements)
+    for (prop_stmt, final_stmt) in proposed_ast
+        .statements
+        .iter()
+        .zip(final_ast.statements.iter())
+    {
+        // Compare verb calls
+        if let (
+            crate::dsl_v2::Statement::VerbCall(prop_call),
+            crate::dsl_v2::Statement::VerbCall(final_call),
+        ) = (prop_stmt, final_stmt)
+        {
+            // Same verb, compare arguments
+            if prop_call.domain == final_call.domain && prop_call.verb == final_call.verb {
+                // Build arg maps for comparison
+                let prop_args: std::collections::HashMap<_, _> = prop_call
+                    .arguments
+                    .iter()
+                    .map(|a| (a.key.clone(), format!("{:?}", a.value)))
+                    .collect();
+
+                let final_args: std::collections::HashMap<_, _> = final_call
+                    .arguments
+                    .iter()
+                    .map(|a| (a.key.clone(), format!("{:?}", a.value)))
+                    .collect();
+
+                // Find changed args
+                for (key, final_val) in &final_args {
+                    if let Some(prop_val) = prop_args.get(key) {
+                        if prop_val != final_val {
+                            edits.push(DslEdit {
+                                field: key.clone(),
+                                from: prop_val.clone(),
+                                to: final_val.clone(),
+                            });
+                        }
+                    } else {
+                        // New arg added
+                        edits.push(DslEdit {
+                            field: key.clone(),
+                            from: String::new(),
+                            to: final_val.clone(),
+                        });
+                    }
+                }
+
+                // Find removed args
+                for (key, prop_val) in &prop_args {
+                    if !final_args.contains_key(key) {
+                        edits.push(DslEdit {
+                            field: key.clone(),
+                            from: prop_val.clone(),
+                            to: String::new(),
+                        });
+                    }
+                }
+            }
+        }
+    }
+
+    edits
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;
diff --git a/rust/src/mcp/handlers/core.rs b/rust/src/mcp/handlers/core.rs
index 511851a0..6b2becc9 100644
--- a/rust/src/mcp/handlers/core.rs
+++ b/rust/src/mcp/handlers/core.rs
@@ -40,6 +40,7 @@ pub struct ToolHandlersConfig {
     pub cbu_sessions: Option<CbuSessionStore>,
     pub learned_data: Option<SharedLearnedData>,
     pub embedder: Option<SharedEmbedder>,
+    pub feedback_service: Option<Arc<ob_semantic_matcher::FeedbackService>>,
 }
 
 impl ToolHandlersConfig {
@@ -51,6 +52,7 @@ impl ToolHandlersConfig {
             cbu_sessions: None,
             learned_data: None,
             embedder: None,
+            feedback_service: None,
         }
     }
 
@@ -90,8 +92,18 @@ impl ToolHandlersConfig {
             verb_searcher: Arc::new(Mutex::new(None)),
             learned_data: self.learned_data,
             embedder: self.embedder,
+            feedback_service: self.feedback_service,
         }
     }
+
+    /// Add feedback service for learning loop
+    pub fn with_feedback_service(
+        mut self,
+        feedback_service: Arc<ob_semantic_matcher::FeedbackService>,
+    ) -> Self {
+        self.feedback_service = Some(feedback_service);
+        self
+    }
 }
 
 /// Tool handlers with database access, EntityGateway client, and UI session store
@@ -111,6 +123,8 @@ pub struct ToolHandlers {
     learned_data: Option<SharedLearnedData>,
     /// Embedder for semantic operations (optional)
     embedder: Option<SharedEmbedder>,
+    /// Feedback service for learning loop
+    feedback_service: Option<Arc<ob_semantic_matcher::FeedbackService>>,
 }
 
 impl ToolHandlers {
@@ -499,6 +513,9 @@ impl ToolHandlers {
     }
 
     /// Execute DSL against the database
+    ///
+    /// Optional parameters:
+    /// - `intent_feedback_id`: Links to learning loop (from dsl_generate flow)
     async fn dsl_execute(&self, args: Value) -> Result<Value> {
         let source = args["source"]
             .as_str()
@@ -513,7 +530,10 @@ impl ToolHandlers {
         // Extract user_intent if provided, otherwise use a default
         let user_intent = args["intent"].as_str().unwrap_or("MCP tool execution");
 
-        // Start generation log (no intent_feedback_id for direct MCP calls)
+        // Extract intent_feedback_id if provided (links to learning loop)
+        let intent_feedback_id = args["intent_feedback_id"].as_i64();
+
+        // Start generation log with optional learning loop linkage
         let log_id = self
             .generation_log
             .start_log(
@@ -522,7 +542,7 @@ impl ToolHandlers {
                 None, // session_id
                 None, // cbu_id
                 None, // model
-                None, // intent_feedback_id - MCP direct execution
+                intent_feedback_id,
             )
             .await
             .ok();
@@ -1183,6 +1203,9 @@ impl ToolHandlers {
             .ok_or_else(|| anyhow!("instruction required"))?;
         let domain = args["domain"].as_str();
         let execute = args["execute"].as_bool().unwrap_or(false);
+        let session_id = args["session_id"]
+            .as_str()
+            .and_then(|s| uuid::Uuid::parse_str(s).ok());
 
         // Get verb searcher and create intent pipeline
         let searcher = self.get_verb_searcher().await?;
@@ -1191,6 +1214,50 @@ impl ToolHandlers {
         // Process through structured pipeline
         let result = pipeline.process(instruction, domain).await?;
 
+        // Capture feedback for learning loop
+        let feedback_id = if let Some(ref feedback_svc) = self.feedback_service {
+            let top_verb = result.verb_candidates.first();
+            let match_result = top_verb.map(|v| ob_semantic_matcher::MatchResult {
+                verb_name: v.verb.clone(),
+                pattern_phrase: v.matched_phrase.clone(),
+                similarity: v.score,
+                match_method: ob_semantic_matcher::MatchMethod::Semantic,
+                category: "mcp".to_string(),
+                is_agent_bound: true,
+            });
+
+            match feedback_svc
+                .capture_match(
+                    session_id.unwrap_or_else(uuid::Uuid::new_v4),
+                    instruction,
+                    ob_semantic_matcher::feedback::InputSource::Command,
+                    match_result.as_ref(),
+                    &[], // alternatives
+                    domain,
+                    None, // workflow_phase
+                )
+                .await
+            {
+                Ok(interaction_id) => {
+                    // Look up the feedback row ID for FK linking
+                    sqlx::query_scalar::<_, i64>(
+                        r#"SELECT id FROM "ob-poc".intent_feedback WHERE interaction_id = $1"#,
+                    )
+                    .bind(interaction_id)
+                    .fetch_optional(&self.pool)
+                    .await
+                    .ok()
+                    .flatten()
+                }
+                Err(e) => {
+                    tracing::warn!("Failed to capture MCP feedback: {}", e);
+                    None
+                }
+            }
+        } else {
+            None
+        };
+
         // Build response
         let response = json!({
             "success": result.valid,
